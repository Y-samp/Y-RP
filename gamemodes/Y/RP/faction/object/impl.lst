#pragma ctrlchar 0x5c
#pragma pack false
#pragma semicolon true
#pragma tabsize 8
#file "impl.inc"
#line 4

#file "D:\Dev\PAWN\YCore\pawno\include\YSI\y_hooks.inc"
#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Internal\y_compilerpass.inc"
#line 2





























































































#line 99

#line 109
static stock __COMPILER_SECOND_PASS() {}

#line 116

#line 120

#line 126

#line 129




#line 135

	#pragma warning push
	#pragma warning disable 207
	#pragma disablerecursion
	#pragma warning pop
#line 144


#line 147















#line 163

#line 188

#line 190



#file "D:\Dev\PAWN\YCore\pawno\include\YSI\y_hooks.inc"
#line 5

#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\y_hooks.inc"
#line 2





























































#line 70


#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Internal\y_unique.inc"
#line 2


























































#line 61

#line 65

#line 69




#line 110
	static stock const UNIQUE_SYMBOL_DOESNT_EXIST;
#line 114

#line 118

#line 122

#line 135

#line 139



#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\y_hooks.inc"
#line 73

#line 78

#line 84

#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\y_hooks/macros.inc"
#line 2



























































































#line 96

#line 98

#line 103

#line 107



#line 111


#line 114

#line 118

#line 120

#line 125

#line 127



#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\y_hooks.inc"
#line 86

#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Internal\y_unique.inc"
#line 2


























































#line 61

#line 65

#line 69




#line 79
		static stock const UNIQUE_SYMBOL_LESS_THAN_100 = (0);
#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Internal\y_unique\_000_to_099.inc"
#line 1
static stock const Y_UNIQUE_000_to_099_CALLED;

#line 6

#line 12
		#endinput

#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Internal\y_unique.inc"
#line 114

#line 118

#line 122

#line 135

#line 139



#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\y_hooks.inc"
#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\y_cell.inc"
#line 2























































































#line 93

#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Internal\y_version.inc"
#line 2































































































#line 101

#file "D:\Dev\PAWN\YCore\pawno\include\a_samp.inc"
#line 1






#line 11
#pragma library samp

#pragma tabsize 4



#file "D:\Dev\PAWN\YCore\pawno\include\core.inc"
#line 1





#line 10
#pragma library Core

native heapspace();

native funcidx(const name[]);

native numargs();
native getarg(arg, index=0);
native setarg(arg, index=0, value);

native tolower(c);
native toupper(c);
native swapchars(c);

native random(max);

native min(value1, value2);
native max(value1, value2);
native clamp(value, min=cellmin, max=cellmax);

native getproperty(id=0, const name[]="", value=cellmin, string[]="");
native setproperty(id=0, const name[]="", value=cellmin, const string[]="");
native deleteproperty(id=0, const name[]="", value=cellmin);
native existproperty(id=0, const name[]="", value=cellmin);



#file "D:\Dev\PAWN\YCore\pawno\include\a_samp.inc"
#file "D:\Dev\PAWN\YCore\pawno\include\float.inc"
#line 1









#line 14
#pragma library Float


enum floatround_method {
  floatround_round,
  floatround_floor,
  floatround_ceil,
  floatround_tozero,
  floatround_unbiased
}
enum anglemode {
  radian,
  degrees,
  grades
}



native Float:float(value);



native Float:floatstr(const string[]);



native Float:floatmul(Float:oper1, Float:oper2);



native Float:floatdiv(Float:dividend, Float:divisor);



native Float:floatadd(Float:oper1, Float:oper2);



native Float:floatsub(Float:oper1, Float:oper2);



native Float:floatfract(Float:value);



native floatround(Float:value, floatround_method:method=floatround_round);





native floatcmp(Float:oper1, Float:oper2);



native Float:floatsqroot(Float:value);



native Float:floatpower(Float:value, Float:exponent);



native Float:floatlog(Float:value, Float:base=10.0);




native Float:floatsin(Float:value, anglemode:mode=radian);
native Float:floatcos(Float:value, anglemode:mode=radian);
native Float:floattan(Float:value, anglemode:mode=radian);



native Float:floatabs(Float:value);



#pragma rational Float


native Float:operator*(Float:oper1, Float:oper2) = floatmul;
native Float:operator/(Float:oper1, Float:oper2) = floatdiv;
native Float:operator+(Float:oper1, Float:oper2) = floatadd;
native Float:operator-(Float:oper1, Float:oper2) = floatsub;
native Float:operator=(oper) = float;

stock Float:operator++(Float:oper)
    return oper+1.0;

stock Float:operator--(Float:oper)
    return oper-1.0;

stock Float:operator-(Float:oper)
    return oper^Float:cellmin;                                                      

stock Float:operator*(Float:oper1, oper2)
    return floatmul(oper1, float(oper2));                               

stock Float:operator/(Float:oper1, oper2)
    return floatdiv(oper1, float(oper2));

stock Float:operator/(oper1, Float:oper2)
    return floatdiv(float(oper1), oper2);

stock Float:operator+(Float:oper1, oper2)
    return floatadd(oper1, float(oper2));                               

stock Float:operator-(Float:oper1, oper2)
    return floatsub(oper1, float(oper2));

stock Float:operator-(oper1, Float:oper2)
    return floatsub(float(oper1), oper2);

stock bool:operator==(Float:oper1, Float:oper2)
    return floatcmp(oper1, oper2) == 0;

stock bool:operator==(Float:oper1, oper2)
    return floatcmp(oper1, float(oper2)) == 0;                           

stock bool:operator!=(Float:oper1, Float:oper2)
    return floatcmp(oper1, oper2) != 0;

stock bool:operator!=(Float:oper1, oper2)
    return floatcmp(oper1, float(oper2)) != 0;                           

stock bool:operator>(Float:oper1, Float:oper2)
    return floatcmp(oper1, oper2) > 0;

stock bool:operator>(Float:oper1, oper2)
    return floatcmp(oper1, float(oper2)) > 0;

stock bool:operator>(oper1, Float:oper2)
    return floatcmp(float(oper1), oper2) > 0;

stock bool:operator>=(Float:oper1, Float:oper2)
    return floatcmp(oper1, oper2) >= 0;

stock bool:operator>=(Float:oper1, oper2)
    return floatcmp(oper1, float(oper2)) >= 0;

stock bool:operator>=(oper1, Float:oper2)
    return floatcmp(float(oper1), oper2) >= 0;

stock bool:operator<(Float:oper1, Float:oper2)
    return floatcmp(oper1, oper2) < 0;

stock bool:operator<(Float:oper1, oper2)
    return floatcmp(oper1, float(oper2)) < 0;

stock bool:operator<(oper1, Float:oper2)
    return floatcmp(float(oper1), oper2) < 0;

stock bool:operator<=(Float:oper1, Float:oper2)
    return floatcmp(oper1, oper2) <= 0;

stock bool:operator<=(Float:oper1, oper2)
    return floatcmp(oper1, float(oper2)) <= 0;

stock bool:operator<=(oper1, Float:oper2)
    return floatcmp(float(oper1), oper2) <= 0;

stock bool:operator!(Float:oper)
    return (_:oper & cellmax) == 0;


forward operator%(Float:oper1, Float:oper2);
forward operator%(Float:oper1, oper2);
forward operator%(oper1, Float:oper2);



#file "D:\Dev\PAWN\YCore\pawno\include\a_samp.inc"
#file "D:\Dev\PAWN\YCore\pawno\include\string.inc"
#line 1





#line 10
#pragma library String

native strlen(const string[]);
native strpack(dest[], const source[], maxlength=sizeof dest);
native strunpack(dest[], const source[], maxlength=sizeof dest);
native strcat(dest[], const source[], maxlength=sizeof dest);

native strmid(dest[], const source[], start, end, maxlength=sizeof dest);
native bool: strins(string[], const substr[], pos, maxlength=sizeof string);
native bool: strdel(string[], start, end);

native strcmp(const string1[], const string2[], bool:ignorecase=false, length=cellmax);
native strfind(const string[], const sub[], bool:ignorecase=false, pos=0);

native strval(const string[]);
native valstr(dest[], value, bool:pack=false);
native bool: ispacked(const string[]);

native uudecode(dest[], const source[], maxlength=sizeof dest);
native uuencode(dest[], const source[], numbytes, maxlength=sizeof dest);
native memcpy(dest[], const source[], index=0, numbytes, maxlength=sizeof dest);


#file "D:\Dev\PAWN\YCore\pawno\include\a_samp.inc"
#file "D:\Dev\PAWN\YCore\pawno\include\file.inc"
#line 1





#line 10
#pragma library File

enum filemode
    {
    io_read,                                 
    io_write,                                   
    io_readwrite,                                                          
    io_append,                                            
    }

enum seek_whence
    {
    seek_start,
    seek_current,
    seek_end,
    }

const EOF = -1;

native File:fopen(const name[], filemode: mode = io_readwrite);
native bool:fclose(File: handle);
native File:ftemp();
native bool:fremove(const name[]);

native fwrite(File: handle, const string[]);
native fread(File: handle, string[], size = sizeof string, bool: pack = false);
native bool:fputchar(File: handle, value, bool: utf8 = true);
native fgetchar(File: handle, value, bool: utf8 = true);
native fblockwrite(File: handle, const buffer[], size = sizeof buffer);
native fblockread(File: handle, buffer[], size = sizeof buffer);

native fseek(File: handle, position = 0, seek_whence: whence = seek_start);
native flength(File: handle);
native fexist(const pattern[]);
native bool:fmatch(name[], const pattern[], index = 0, size = sizeof name);


#file "D:\Dev\PAWN\YCore\pawno\include\a_samp.inc"
#file "D:\Dev\PAWN\YCore\pawno\include\time.inc"
#line 1





#line 10
#pragma library Time

native gettime(&hour=0, &minute=0, &second=0);
native getdate(&year=0, &month=0, &day=0);
native tickcount(&granularity=0);


#file "D:\Dev\PAWN\YCore\pawno\include\a_samp.inc"
#file "D:\Dev\PAWN\YCore\pawno\include\datagram.inc"
#line 1





#line 10
#pragma library DGram

native sendstring(const message[], const destination[]="");
native sendpacket(const packet[], size, const destination[]="");

native listenport(port);

forward @receivestring(const message[], const source[]);
forward @receivepacket(const packet[], size, const source[]);


#file "D:\Dev\PAWN\YCore\pawno\include\a_samp.inc"
#file "D:\Dev\PAWN\YCore\pawno\include\a_players.inc"
#line 1






#line 11
#pragma library players

#line 32

#line 39

#line 51

#line 57


native SetSpawnInfo(playerid, team, skin, Float:x, Float:y, Float:z, Float:rotation, weapon1, weapon1_ammo, weapon2, weapon2_ammo, weapon3, weapon3_ammo);
native SpawnPlayer(playerid);


native SetPlayerPos(playerid, Float:x, Float:y, Float:z);
native SetPlayerPosFindZ(playerid, Float:x, Float:y, Float:z);
native GetPlayerPos(playerid, &Float:x, &Float:y, &Float:z);
native SetPlayerFacingAngle(playerid,Float:ang);
native GetPlayerFacingAngle(playerid,&Float:ang);
native IsPlayerInRangeOfPoint(playerid, Float:range, Float:x, Float:y, Float:z);
native Float:GetPlayerDistanceFromPoint(playerid, Float:X, Float:Y, Float:Z);
native IsPlayerStreamedIn(playerid, forplayerid);
native SetPlayerInterior(playerid,interiorid);
native GetPlayerInterior(playerid);
native SetPlayerHealth(playerid, Float:health);
native GetPlayerHealth(playerid, &Float:health);
native SetPlayerArmour(playerid, Float:armour);
native GetPlayerArmour(playerid, &Float:armour);
native SetPlayerAmmo(playerid, weaponslot, ammo);
native GetPlayerAmmo(playerid);
native GetPlayerWeaponState(playerid);
native GetPlayerTargetPlayer(playerid);
native GetPlayerTargetActor(playerid);
native SetPlayerTeam(playerid, teamid);
native GetPlayerTeam(playerid);
native SetPlayerScore(playerid,score);
native GetPlayerScore(playerid);
native GetPlayerDrunkLevel(playerid);
native SetPlayerDrunkLevel(playerid, level);
native SetPlayerColor(playerid,color);
native GetPlayerColor(playerid);
native SetPlayerSkin(playerid, skinid);
native GetPlayerSkin(playerid);
native GivePlayerWeapon(playerid, weaponid, ammo);
native ResetPlayerWeapons(playerid);
native SetPlayerArmedWeapon(playerid, weaponid);
native GetPlayerWeaponData(playerid, slot, &weapons, &ammo);
native GivePlayerMoney(playerid,money);
native ResetPlayerMoney(playerid);
native SetPlayerName(playerid, const name[]);
native GetPlayerMoney(playerid);
native GetPlayerState(playerid);
native GetPlayerIp(playerid, name[], len);
native GetPlayerPing(playerid);
native GetPlayerWeapon(playerid);
native GetPlayerKeys(playerid, &keys, &updown, &leftright);
native GetPlayerName(playerid, const name[], len);
native SetPlayerTime(playerid, hour, minute);
native GetPlayerTime(playerid, &hour, &minute);
native TogglePlayerClock(playerid, toggle);
native SetPlayerWeather(playerid, weather);
native ForceClassSelection(playerid);
native SetPlayerWantedLevel(playerid, level);
native GetPlayerWantedLevel(playerid);
native SetPlayerFightingStyle(playerid, style);
native GetPlayerFightingStyle(playerid);
native SetPlayerVelocity(playerid, Float:X, Float:Y, Float:Z);
native GetPlayerVelocity( playerid, &Float:X, &Float:Y, &Float:Z );
native PlayCrimeReportForPlayer(playerid, suspectid, crime);
native PlayAudioStreamForPlayer(playerid, url[], Float:posX = 0.0, Float:posY = 0.0, Float:posZ = 0.0, Float:distance = 50.0, usepos = 0);
native StopAudioStreamForPlayer(playerid);
native SetPlayerShopName(playerid, shopname[]);
native SetPlayerSkillLevel(playerid, skill, level);
native GetPlayerSurfingVehicleID(playerid);
native GetPlayerSurfingObjectID(playerid);
native RemoveBuildingForPlayer(playerid, modelid, Float:fX, Float:fY, Float:fZ, Float:fRadius);
native GetPlayerLastShotVectors(playerid, &Float:fOriginX, &Float:fOriginY, &Float:fOriginZ, &Float:fHitPosX, &Float:fHitPosY, &Float:fHitPosZ);



#line 130

native SetPlayerAttachedObject(playerid, index, modelid, bone, Float:fOffsetX = 0.0, Float:fOffsetY = 0.0, Float:fOffsetZ = 0.0, Float:fRotX = 0.0, Float:fRotY = 0.0, Float:fRotZ = 0.0, Float:fScaleX = 1.0, Float:fScaleY = 1.0, Float:fScaleZ = 1.0, materialcolor1 = 0, materialcolor2 = 0);
native RemovePlayerAttachedObject(playerid, index);
native IsPlayerAttachedObjectSlotUsed(playerid, index);
native EditAttachedObject(playerid, index);


native PlayerText:CreatePlayerTextDraw(playerid, Float:x, Float:y, text[]);
native PlayerTextDrawDestroy(playerid, PlayerText:text);
native PlayerTextDrawLetterSize(playerid, PlayerText:text, Float:x, Float:y);
native PlayerTextDrawTextSize(playerid, PlayerText:text, Float:x, Float:y);
native PlayerTextDrawAlignment(playerid, PlayerText:text, alignment);
native PlayerTextDrawColor(playerid, PlayerText:text, color);
native PlayerTextDrawUseBox(playerid, PlayerText:text, use);
native PlayerTextDrawBoxColor(playerid, PlayerText:text, color);
native PlayerTextDrawSetShadow(playerid, PlayerText:text, size);
native PlayerTextDrawSetOutline(playerid, PlayerText:text, size);
native PlayerTextDrawBackgroundColor(playerid, PlayerText:text, color);
native PlayerTextDrawFont(playerid, PlayerText:text, font);
native PlayerTextDrawSetProportional(playerid, PlayerText:text, set);
native PlayerTextDrawSetSelectable(playerid, PlayerText:text, set);
native PlayerTextDrawShow(playerid, PlayerText:text);
native PlayerTextDrawHide(playerid, PlayerText:text);
native PlayerTextDrawSetString(playerid, PlayerText:text, string[]);
native PlayerTextDrawSetPreviewModel(playerid, PlayerText:text, modelindex);
native PlayerTextDrawSetPreviewRot(playerid, PlayerText:text, Float:fRotX, Float:fRotY, Float:fRotZ, Float:fZoom = 1.0);
native PlayerTextDrawSetPreviewVehCol(playerid, PlayerText:text, color1, color2);


native SetPVarInt(playerid, varname[], int_value);
native GetPVarInt(playerid, varname[]);
native SetPVarString(playerid, varname[], string_value[]);
native GetPVarString(playerid, varname[], string_return[], len);
native SetPVarFloat(playerid, varname[], Float:float_value);
native Float:GetPVarFloat(playerid, varname[]);
native DeletePVar(playerid, varname[]);


#line 172

native GetPVarsUpperIndex(playerid);
native GetPVarNameAtIndex(playerid, index, ret_varname[], ret_len);
native GetPVarType(playerid, varname[]);

#line 178
native SetPlayerChatBubble(playerid, text[], color, Float:drawdistance, expiretime);


native PutPlayerInVehicle(playerid, vehicleid, seatid);
native GetPlayerVehicleID(playerid);
native GetPlayerVehicleSeat(playerid);
native RemovePlayerFromVehicle(playerid);
native TogglePlayerControllable(playerid, toggle);
native PlayerPlaySound(playerid, soundid, Float:x, Float:y, Float:z);
native ApplyAnimation(playerid, animlib[], animname[], Float:fDelta, loop, lockx, locky, freeze, time, forcesync = 0);
native ClearAnimations(playerid, forcesync = 0);
native GetPlayerAnimationIndex(playerid); 
native GetAnimationName(index, animlib[], len1, animname[], len2); 
native GetPlayerSpecialAction(playerid);
native SetPlayerSpecialAction(playerid,actionid);
native DisableRemoteVehicleCollisions(playerid, disable);


native SetPlayerCheckpoint(playerid, Float:x, Float:y, Float:z, Float:size);
native DisablePlayerCheckpoint(playerid);
native SetPlayerRaceCheckpoint(playerid, type, Float:x, Float:y, Float:z, Float:nextx, Float:nexty, Float:nextz, Float:size);
native DisablePlayerRaceCheckpoint(playerid);
native SetPlayerWorldBounds(playerid,Float:x_max,Float:x_min,Float:y_max,Float:y_min);
native SetPlayerMarkerForPlayer(playerid, showplayerid, color);
native ShowPlayerNameTagForPlayer(playerid, showplayerid, show);

#line 208

native SetPlayerMapIcon(playerid, iconid, Float:x, Float:y, Float:z, markertype, color, style = 0);
native RemovePlayerMapIcon(playerid, iconid);

native AllowPlayerTeleport(playerid, allow);


native SetPlayerCameraPos(playerid,Float:x, Float:y, Float:z);

#line 219

native SetPlayerCameraLookAt(playerid, Float:x, Float:y, Float:z, cut = 2);
native SetCameraBehindPlayer(playerid);
native GetPlayerCameraPos(playerid, &Float:x, &Float:y, &Float:z);
native GetPlayerCameraFrontVector(playerid, &Float:x, &Float:y, &Float:z);
native GetPlayerCameraMode(playerid);
native EnablePlayerCameraTarget(playerid, enable);
native GetPlayerCameraTargetObject(playerid);
native GetPlayerCameraTargetVehicle(playerid);
native GetPlayerCameraTargetPlayer(playerid);
native GetPlayerCameraTargetActor(playerid);
native Float:GetPlayerCameraAspectRatio(playerid);
native Float:GetPlayerCameraZoom(playerid);
native AttachCameraToObject(playerid, objectid);
native AttachCameraToPlayerObject(playerid, playerobjectid);
native InterpolateCameraPos(playerid, Float:FromX, Float:FromY, Float:FromZ, Float:ToX, Float:ToY, Float:ToZ, time, cut = 2);
native InterpolateCameraLookAt(playerid, Float:FromX, Float:FromY, Float:FromZ, Float:ToX, Float:ToY, Float:ToZ, time, cut = 2);


native IsPlayerConnected(playerid);
native IsPlayerInVehicle(playerid, vehicleid);
native IsPlayerInAnyVehicle(playerid);
native IsPlayerInCheckpoint(playerid);
native IsPlayerInRaceCheckpoint(playerid);


native SetPlayerVirtualWorld(playerid, worldid);
native GetPlayerVirtualWorld(playerid);


native EnableStuntBonusForPlayer(playerid, enable);
native EnableStuntBonusForAll(enable);


#line 256

native TogglePlayerSpectating(playerid, toggle);
native PlayerSpectatePlayer(playerid, targetplayerid, mode = 1);
native PlayerSpectateVehicle(playerid, targetvehicleid, mode = 1);


#line 265

native StartRecordingPlayerData(playerid, recordtype, recordname[]);
native StopRecordingPlayerData(playerid);

native SelectTextDraw(playerid, hovercolor); 
native CancelSelectTextDraw(playerid);	


native CreateExplosionForPlayer(playerid, Float:X, Float:Y, Float:Z, type, Float:Radius);
#file "D:\Dev\PAWN\YCore\pawno\include\a_samp.inc"
#file "D:\Dev\PAWN\YCore\pawno\include\a_vehicles.inc"
#line 1






#line 11
#pragma library vehicles

#line 27

#line 31


native CreateVehicle(vehicletype, Float:x, Float:y, Float:z, Float:rotation, color1, color2, respawn_delay, addsiren=0);
native DestroyVehicle(vehicleid);
native IsVehicleStreamedIn(vehicleid, forplayerid);
native GetVehiclePos(vehicleid, &Float:x, &Float:y, &Float:z);
native SetVehiclePos(vehicleid, Float:x, Float:y, Float:z);
native GetVehicleZAngle(vehicleid, &Float:z_angle);
native GetVehicleRotationQuat(vehicleid, &Float:w, &Float:x, &Float:y, &Float:z);
native Float:GetVehicleDistanceFromPoint(vehicleid, Float:X, Float:Y, Float:Z);
native SetVehicleZAngle(vehicleid, Float:z_angle);
native SetVehicleParamsForPlayer(vehicleid,playerid,objective,doorslocked);
native ManualVehicleEngineAndLights();
native SetVehicleParamsEx(vehicleid, engine, lights, alarm, doors, bonnet, boot, objective);
native GetVehicleParamsEx(vehicleid, &engine, &lights, &alarm, &doors, &bonnet, &boot, &objective);
native GetVehicleParamsSirenState(vehicleid);
native SetVehicleParamsCarDoors(vehicleid, driver, passenger, backleft, backright);
native GetVehicleParamsCarDoors(vehicleid, &driver, &passenger, &backleft, &backright);
native SetVehicleParamsCarWindows(vehicleid, driver, passenger, backleft, backright);
native GetVehicleParamsCarWindows(vehicleid, &driver, &passenger, &backleft, &backright);
native SetVehicleToRespawn(vehicleid);
native LinkVehicleToInterior(vehicleid, interiorid);
native AddVehicleComponent(vehicleid, componentid);
native RemoveVehicleComponent(vehicleid, componentid);
native ChangeVehicleColor(vehicleid, color1, color2);
native ChangeVehiclePaintjob(vehicleid, paintjobid);
native SetVehicleHealth(vehicleid, Float:health);
native GetVehicleHealth(vehicleid, &Float:health);
native AttachTrailerToVehicle(trailerid, vehicleid);
native DetachTrailerFromVehicle(vehicleid);
native IsTrailerAttachedToVehicle(vehicleid);
native GetVehicleTrailer(vehicleid);
native SetVehicleNumberPlate(vehicleid, numberplate[]);
native GetVehicleModel(vehicleid);
native GetVehicleComponentInSlot(vehicleid, slot); 
native GetVehicleComponentType(component); 
native RepairVehicle(vehicleid); 
native GetVehicleVelocity(vehicleid, &Float:X, &Float:Y, &Float:Z);
native SetVehicleVelocity(vehicleid, Float:X, Float:Y, Float:Z);
native SetVehicleAngularVelocity(vehicleid, Float:X, Float:Y, Float:Z);
native GetVehicleDamageStatus(vehicleid, &panels, &doors, &lights, &tires);
native UpdateVehicleDamageStatus(vehicleid, panels, doors, lights, tires);

#line 83

native GetVehicleModelInfo(vehiclemodel, infotype, &Float:X, &Float:Y, &Float:Z);


native SetVehicleVirtualWorld(vehicleid, worldid);
native GetVehicleVirtualWorld(vehicleid);
#file "D:\Dev\PAWN\YCore\pawno\include\a_samp.inc"
#file "D:\Dev\PAWN\YCore\pawno\include\a_objects.inc"
#line 1






#line 11
#pragma library objects



native CreateObject(modelid, Float:X, Float:Y, Float:Z, Float:rX, Float:rY, Float:rZ, Float:DrawDistance = 0.0);
native AttachObjectToVehicle(objectid, vehicleid, Float:OffsetX, Float:OffsetY, Float:OffsetZ, Float:RotX, Float:RotY, Float:RotZ);
native AttachObjectToObject(objectid, attachtoid, Float:OffsetX, Float:OffsetY, Float:OffsetZ, Float:RotX, Float:RotY, Float:RotZ, SyncRotation = 1);
native AttachObjectToPlayer(objectid, playerid, Float:OffsetX, Float:OffsetY, Float:OffsetZ, Float:RotX, Float:RotY, Float:RotZ);
native SetObjectPos(objectid, Float:X, Float:Y, Float:Z);
native GetObjectPos(objectid, &Float:X, &Float:Y, &Float:Z);
native SetObjectRot(objectid, Float:RotX, Float:RotY, Float:RotZ);
native GetObjectRot(objectid, &Float:RotX, &Float:RotY, &Float:RotZ);
native GetObjectModel(objectid);
native SetObjectNoCameraCol(objectid);
native IsValidObject(objectid);
native DestroyObject(objectid);
native MoveObject(objectid, Float:X, Float:Y, Float:Z, Float:Speed, Float:RotX = -1000.0, Float:RotY = -1000.0, Float:RotZ = -1000.0);
native StopObject(objectid);
native IsObjectMoving(objectid);
native EditObject(playerid, objectid);
native EditPlayerObject(playerid, objectid);
native SelectObject(playerid);
native CancelEdit(playerid);
native CreatePlayerObject(playerid, modelid, Float:X, Float:Y, Float:Z, Float:rX, Float:rY, Float:rZ, Float:DrawDistance = 0.0);
native AttachPlayerObjectToVehicle(playerid, objectid, vehicleid, Float:fOffsetX, Float:fOffsetY, Float:fOffsetZ, Float:fRotX, Float:fRotY, Float:RotZ);
native SetPlayerObjectPos(playerid, objectid, Float:X, Float:Y, Float:Z);
native GetPlayerObjectPos(playerid, objectid, &Float:X, &Float:Y, &Float:Z);
native SetPlayerObjectRot(playerid, objectid, Float:RotX, Float:RotY, Float:RotZ);
native GetPlayerObjectRot(playerid, objectid, &Float:RotX, &Float:RotY, &Float:RotZ);
native GetPlayerObjectModel(playerid, objectid);
native SetPlayerObjectNoCameraCol(playerid, objectid);
native IsValidPlayerObject(playerid, objectid);
native DestroyPlayerObject(playerid, objectid);
native MovePlayerObject(playerid, objectid, Float:X, Float:Y, Float:Z, Float:Speed, Float:RotX = -1000.0, Float:RotY = -1000.0, Float:RotZ = -1000.0);
native StopPlayerObject(playerid, objectid);
native IsPlayerObjectMoving(playerid, objectid);
native AttachPlayerObjectToPlayer(objectplayer, objectid, attachplayer, Float:OffsetX, Float:OffsetY, Float:OffsetZ, Float:rX, Float:rY, Float:rZ);

#line 63

#line 67

native SetObjectMaterial(objectid, materialindex, modelid, txdname[], texturename[], materialcolor=0);
native SetPlayerObjectMaterial(playerid, objectid, materialindex, modelid, txdname[], texturename[], materialcolor=0);

native SetObjectMaterialText(objectid, text[], materialindex = 0, materialsize = 90, fontface[] = "Arial", fontsize = 24, bold = 1, fontcolor = 0xFFFFFFFF, backcolor = 0, textalignment = 0);
native SetPlayerObjectMaterialText(playerid, objectid, text[], materialindex = 0, materialsize = 90, fontface[] = "Arial", fontsize = 24, bold = 1, fontcolor = 0xFFFFFFFF, backcolor = 0, textalignment = 0);

native SetObjectsDefaultCameraCol(disable);
#file "D:\Dev\PAWN\YCore\pawno\include\a_samp.inc"
#file "D:\Dev\PAWN\YCore\pawno\include\a_actor.inc"
#line 1






#line 11
#pragma library actors

native CreateActor(modelid, Float:X, Float:Y, Float:Z, Float:Rotation);
native DestroyActor(actorid);

native IsActorStreamedIn(actorid, forplayerid);

native SetActorVirtualWorld(actorid, vworld);
native GetActorVirtualWorld(actorid);

native ApplyActorAnimation(actorid, animlib[], animname[], Float:fDelta, loop, lockx, locky, freeze, time);
native ClearActorAnimations(actorid);

native SetActorPos(actorid, Float:X, Float:Y, Float:Z);
native GetActorPos(actorid, &Float:X, &Float:Y, &Float:Z);
native SetActorFacingAngle(actorid, Float:ang);
native GetActorFacingAngle(actorid, &Float:ang);

native SetActorHealth(actorid, Float:health);
native GetActorHealth(actorid, &Float:health);
native SetActorInvulnerable(actorid, invulnerable = true);
native IsActorInvulnerable(actorid);

native IsValidActor(actorid);
#file "D:\Dev\PAWN\YCore\pawno\include\a_samp.inc"
#file "D:\Dev\PAWN\YCore\pawno\include\a_sampdb.inc"
#line 1





#line 10
#pragma library sampdb

native DB:db_open(name[]);
native db_close(DB:db);
native DBResult:db_query(DB:db, query[]);
native db_free_result(DBResult:dbresult);
native db_num_rows(DBResult:dbresult);
native db_next_row(DBResult:dbresult);
native db_num_fields(DBResult:dbresult);
native db_field_name(DBResult:dbresult, field, result[], maxlength);
native db_get_field(DBResult:dbresult, field, result[], maxlength);
native db_get_field_int(DBResult:result, field = 0);
native Float:db_get_field_float(DBResult:result, field = 0);
native db_get_field_assoc(DBResult:dbresult, const field[], result[], maxlength);
native db_get_field_assoc_int(DBResult:result, const field[]);
native Float:db_get_field_assoc_float(DBResult:result, const field[]);
native db_get_mem_handle(DB:db);
native db_get_result_mem_handle(DBResult:result);

native db_debug_openfiles();
native db_debug_openresults();
#file "D:\Dev\PAWN\YCore\pawno\include\a_samp.inc"
#line 28


#line 51






native print(const string[]);
native printf(const format[], {Float,_}:...);
native format(output[], len, const format[], {Float,_}:...);
native SendClientMessage(playerid, color, const message[]);
native SendClientMessageToAll(color, const message[]);
native SendPlayerMessageToPlayer(playerid, senderid, const message[]);
native SendPlayerMessageToAll(senderid, const message[]);
native SendDeathMessage(killer, killee, weapon);
native SendDeathMessageToPlayer(playerid, killer, killee, weapon);
native GameTextForAll(const string[],time,style);
native GameTextForPlayer(playerid,const string[],time,style);
native SetTimer(funcname[], interval, repeating);
native SetTimerEx(funcname[], interval, repeating, const format[], {Float,_}:...);
native KillTimer(timerid);
native GetTickCount();
native GetMaxPlayers();
native CallRemoteFunction(const function[], const format[], {Float,_}:...);
native CallLocalFunction(const function[], const format[], {Float,_}:...);
native Float:VectorSize(Float:x, Float:y, Float:z);
native Float:asin(Float:value);
native Float:acos(Float:value);
native Float:atan(Float:value);
native Float:atan2(Float:x, Float:y);
native GetPlayerPoolSize();
native GetVehiclePoolSize();
native GetActorPoolSize();


native SHA256_PassHash(password[], salt[], ret_hash[], ret_hash_len); 


native SetSVarInt(varname[], int_value);
native GetSVarInt(varname[]);
native SetSVarString(varname[], string_value[]);
native GetSVarString(varname[], string_return[], len);
native SetSVarFloat(varname[], Float:float_value);
native Float:GetSVarFloat(varname[]);
native DeleteSVar(varname[]);


#line 101

native GetSVarsUpperIndex();
native GetSVarNameAtIndex(index, ret_varname[], ret_len);
native GetSVarType(varname[]);


native SetGameModeText(const string[]);
native SetTeamCount(count);
native AddPlayerClass(modelid, Float:spawn_x, Float:spawn_y, Float:spawn_z, Float:z_angle, weapon1, weapon1_ammo, weapon2, weapon2_ammo, weapon3, weapon3_ammo);
native AddPlayerClassEx(teamid, modelid, Float:spawn_x, Float:spawn_y, Float:spawn_z, Float:z_angle, weapon1, weapon1_ammo, weapon2, weapon2_ammo, weapon3, weapon3_ammo);
native AddStaticVehicle(modelid, Float:spawn_x, Float:spawn_y, Float:spawn_z, Float:z_angle, color1, color2);
native AddStaticVehicleEx(modelid, Float:spawn_x, Float:spawn_y, Float:spawn_z, Float:z_angle, color1, color2, respawn_delay, addsiren=0);
native AddStaticPickup(model, type, Float:X, Float:Y, Float:Z, virtualworld = 0);
native CreatePickup(model, type, Float:X, Float:Y, Float:Z, virtualworld = 0);
native DestroyPickup(pickup);
native ShowNameTags(show);
native ShowPlayerMarkers(mode);
native GameModeExit();
native SetWorldTime(hour);
native GetWeaponName(weaponid, const weapon[], len);
native EnableTirePopping(enable); 
native EnableVehicleFriendlyFire();
native AllowInteriorWeapons(allow);
native SetWeather(weatherid);
native SetGravity(Float:gravity);
native AllowAdminTeleport(allow);
native SetDeathDropAmount(amount);
native CreateExplosion(Float:X, Float:Y, Float:Z, type, Float:Radius);
native EnableZoneNames(enable);
native UsePlayerPedAnims();		
native DisableInteriorEnterExits();  
native SetNameTagDrawDistance(Float:distance); 
native DisableNameTagLOS(); 
native LimitGlobalChatRadius(Float:chat_radius);
native LimitPlayerMarkerRadius(Float:marker_radius);


native ConnectNPC(name[], script[]);
native IsPlayerNPC(playerid);


native IsPlayerAdmin(playerid);
native Kick(playerid);
native Ban(playerid);
native BanEx(playerid, const reason[]);
native SendRconCommand(command[]);
native GetPlayerNetworkStats(playerid, retstr[], retstr_size);
native GetNetworkStats(retstr[], retstr_size);
native GetPlayerVersion(playerid, const version[], len); 
native BlockIpAddress(ip_address[], timems);
native UnBlockIpAddress(ip_address[]);


native GetServerVarAsString(const varname[], buffer[], len);
native GetServerVarAsInt(const varname[]);
native GetServerVarAsBool(const varname[]);

native GetConsoleVarAsString(const varname[], buffer[], len);
native GetConsoleVarAsInt(const varname[]);
native GetConsoleVarAsBool(const varname[]);


native GetServerTickRate();
native NetStats_GetConnectedTime(playerid);
native NetStats_MessagesReceived(playerid);
native NetStats_BytesReceived(playerid);
native NetStats_MessagesSent(playerid);
native NetStats_BytesSent(playerid);
native NetStats_MessagesRecvPerSecond(playerid);
native Float:NetStats_PacketLossPercent(playerid);
native NetStats_ConnectionStatus(playerid);
native NetStats_GetIpPort(playerid, ip_port[], ip_port_len);


native Menu:CreateMenu(const title[], columns, Float:x, Float:y, Float:col1width, Float:col2width = 0.0);
native DestroyMenu(Menu:menuid);
native AddMenuItem(Menu:menuid, column, const menutext[]);
native SetMenuColumnHeader(Menu:menuid, column, const columnheader[]);
native ShowMenuForPlayer(Menu:menuid, playerid);
native HideMenuForPlayer(Menu:menuid, playerid);
native IsValidMenu(Menu:menuid);
native DisableMenu(Menu:menuid);
native DisableMenuRow(Menu:menuid, row);
native Menu:GetPlayerMenu(playerid);


#line 189

native Text:TextDrawCreate(Float:x, Float:y, text[]);
native TextDrawDestroy(Text:text);
native TextDrawLetterSize(Text:text, Float:x, Float:y);
native TextDrawTextSize(Text:text, Float:x, Float:y);
native TextDrawAlignment(Text:text, alignment);
native TextDrawColor(Text:text, color);
native TextDrawUseBox(Text:text, use);
native TextDrawBoxColor(Text:text, color);
native TextDrawSetShadow(Text:text, size);
native TextDrawSetOutline(Text:text, size);
native TextDrawBackgroundColor(Text:text, color);
native TextDrawFont(Text:text, font);
native TextDrawSetProportional(Text:text, set);
native TextDrawSetSelectable(Text:text, set);
native TextDrawShowForPlayer(playerid, Text:text);
native TextDrawHideForPlayer(playerid, Text:text);
native TextDrawShowForAll(Text:text);
native TextDrawHideForAll(Text:text);
native TextDrawSetString(Text:text, string[]);
native TextDrawSetPreviewModel(Text:text, modelindex);
native TextDrawSetPreviewRot(Text:text, Float:fRotX, Float:fRotY, Float:fRotZ, Float:fZoom = 1.0);
native TextDrawSetPreviewVehCol(Text:text, color1, color2);


native GangZoneCreate(Float:minx, Float:miny, Float:maxx, Float:maxy);
native GangZoneDestroy(zone);
native GangZoneShowForPlayer(playerid, zone, color);
native GangZoneShowForAll(zone, color);
native GangZoneHideForPlayer(playerid, zone);
native GangZoneHideForAll(zone);
native GangZoneFlashForPlayer(playerid, zone, flashcolor);
native GangZoneFlashForAll(zone, flashcolor);
native GangZoneStopFlashForPlayer(playerid, zone);
native GangZoneStopFlashForAll(zone);


native Text3D:Create3DTextLabel(text[], color, Float:X, Float:Y, Float:Z, Float:DrawDistance, virtualworld, testLOS=0);
native Delete3DTextLabel(Text3D:id);
native Attach3DTextLabelToPlayer(Text3D:id, playerid, Float:OffsetX, Float:OffsetY, Float:OffsetZ);
native Attach3DTextLabelToVehicle(Text3D:id, vehicleid, Float:OffsetX, Float:OffsetY, Float:OffsetZ);
native Update3DTextLabelText(Text3D:id, color, text[]);


native PlayerText3D:CreatePlayer3DTextLabel(playerid, text[], color, Float:X, Float:Y, Float:Z, Float:DrawDistance, attachedplayer=(0xFFFF), attachedvehicle=(0xFFFF), testLOS=0);
native DeletePlayer3DTextLabel(playerid, PlayerText3D:id);
native UpdatePlayer3DTextLabelText(playerid, PlayerText3D:id, color, text[]);


#line 244

native ShowPlayerDialog(playerid, dialogid, style, caption[], info[], button1[], button2[]);






#line 262


#line 267


#line 313


#line 334

#line 339





forward OnGameModeInit();
forward OnGameModeExit();
forward OnFilterScriptInit();
forward OnFilterScriptExit();
forward OnPlayerConnect(playerid);
forward OnPlayerDisconnect(playerid, reason);
forward OnPlayerSpawn(playerid);
forward OnPlayerDeath(playerid, killerid, reason);
forward OnVehicleSpawn(vehicleid);
forward OnVehicleDeath(vehicleid, killerid);
forward OnPlayerText(playerid, text[]);
forward OnPlayerCommandText(playerid, cmdtext[]);
forward OnPlayerRequestClass(playerid, classid);
forward OnPlayerEnterVehicle(playerid, vehicleid, ispassenger);
forward OnPlayerExitVehicle(playerid, vehicleid);
forward OnPlayerStateChange(playerid, newstate, oldstate);
forward OnPlayerEnterCheckpoint(playerid);
forward OnPlayerLeaveCheckpoint(playerid);
forward OnPlayerEnterRaceCheckpoint(playerid);
forward OnPlayerLeaveRaceCheckpoint(playerid);
forward OnRconCommand(cmd[]);
forward OnPlayerRequestSpawn(playerid);
forward OnObjectMoved(objectid);
forward OnPlayerObjectMoved(playerid, objectid);
forward OnPlayerPickUpPickup(playerid, pickupid);
forward OnVehicleMod(playerid, vehicleid, componentid);
forward OnEnterExitModShop(playerid, enterexit, interiorid);
forward OnVehiclePaintjob(playerid, vehicleid, paintjobid);
forward OnVehicleRespray(playerid, vehicleid, color1, color2);
forward OnVehicleDamageStatusUpdate(vehicleid, playerid);
forward OnUnoccupiedVehicleUpdate(vehicleid, playerid, passenger_seat, Float:new_x, Float:new_y, Float:new_z, Float:vel_x, Float:vel_y, Float:vel_z);
forward OnPlayerSelectedMenuRow(playerid, row);
forward OnPlayerExitedMenu(playerid);
forward OnPlayerInteriorChange(playerid, newinteriorid, oldinteriorid);
forward OnPlayerKeyStateChange(playerid, newkeys, oldkeys);
forward OnRconLoginAttempt( ip[], password[], success );
forward OnPlayerUpdate(playerid);
forward OnPlayerStreamIn(playerid, forplayerid);
forward OnPlayerStreamOut(playerid, forplayerid);
forward OnVehicleStreamIn(vehicleid, forplayerid);
forward OnVehicleStreamOut(vehicleid, forplayerid);
forward OnActorStreamIn(actorid, forplayerid);
forward OnActorStreamOut(actorid, forplayerid);
forward OnDialogResponse(playerid, dialogid, response, listitem, inputtext[]);
forward OnPlayerTakeDamage(playerid, issuerid, Float:amount, weaponid, bodypart);
forward OnPlayerGiveDamage(playerid, damagedid, Float:amount, weaponid, bodypart);
forward OnPlayerGiveDamageActor(playerid, damaged_actorid, Float:amount, weaponid, bodypart);
forward OnPlayerClickMap(playerid, Float:fX, Float:fY, Float:fZ);
forward OnPlayerClickTextDraw(playerid, Text:clickedid);
forward OnPlayerClickPlayerTextDraw(playerid, PlayerText:playertextid);
forward OnIncomingConnection(playerid, ip_address[], port);
forward OnTrailerUpdate(playerid, vehicleid);
forward OnVehicleSirenStateChange(playerid, vehicleid, newstate);

#line 399
forward OnPlayerClickPlayer(playerid, clickedplayerid, source);

#line 404

forward OnPlayerEditObject( playerid, playerobject, objectid, response, 
Float:fX, Float:fY, Float:fZ, Float:fRotX, Float:fRotY, Float:fRotZ );

forward OnPlayerEditAttachedObject( playerid, response, index, modelid, boneid,
Float:fOffsetX, Float:fOffsetY, Float:fOffsetZ,
Float:fRotX, Float:fRotY, Float:fRotZ,
Float:fScaleX, Float:fScaleY, Float:fScaleZ );

#line 415

forward OnPlayerSelectObject(playerid, type, objectid, modelid, Float:fX, Float:fY, Float:fZ);

#line 423

forward OnPlayerWeaponShot(playerid, weaponid, hittype, hitid, Float:fX, Float:fY, Float:fZ);



#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Internal\y_version.inc"
#file "D:\Dev\PAWN\YCore\pawno\include\a_http.inc"
#line 1







#line 11




#line 21

native HTTP(index, type, url[], data[], callback[]);



#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Internal\y_version.inc"
#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Internal\y_natives.inc"
#line 2































































#line 69

#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Internal\y_globaltags.inc"
#line 2































































#line 69


#line 76


#line 79



#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Internal\y_natives.inc"
#line 72












































#line 120



#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Internal\y_version.inc"
#line 107

#line 111

#line 115

#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Internal\..\YSI_Server\y_scriptinit.inc"
#line 2













































































#line 83

#line 85

#line 87

forward _ScriptInit_FixState();

#line 93

forward @CO_ScriptInit();

public @CO_ScriptInit()
{
	return 0 + 1;
}

#line 103

#line 108

stock
	bool:YSI_FILTERSCRIPT = false;














#line 127

#line 134

public OnFilterScriptInit()
{
	YSI_FILTERSCRIPT = true;
	state _script_init_fix_state : true;
	state _ALS : _ALS_go;

	
#line 145

	
#line 168
	ScriptInit_OnFilterScriptInit();
	return 1;
}

public OnGameModeInit()
{
	state _ALS : _ALS_go;
	if (!YSI_FILTERSCRIPT)
	{
		state _script_init_fix_state : false;

		
#line 183

		
#line 200
	}
	ScriptInit_OnGameModeInit();
	return 1;
}














public OnFilterScriptExit()
{
	ScriptInit_OnFilterScriptExit();
	if (YSI_FILTERSCRIPT)
	{
		ScriptInit_OnScriptExit();
	}
	return 1;
}

public OnGameModeExit()
{
	ScriptInit_OnGameModeExit();
	if (!YSI_FILTERSCRIPT)
	{
		ScriptInit_OnScriptExit();
	}
	return 1;
}














#line 260

forward ScriptInit_OnFilterScriptInit(); public ScriptInit_OnFilterScriptInit() <_ALS : _ALS_x0, _ALS : _ALS_x1> { return 1; } public ScriptInit_OnFilterScriptInit() <> { return 1; }
#line 268

forward ScriptInit_OnGameModeInit(); public ScriptInit_OnGameModeInit() <_ALS : _ALS_x0, _ALS : _ALS_x1> { return 1; } public ScriptInit_OnGameModeInit() <> { return 1; }
#line 276

forward ScriptInit_OnFilterScriptExit(); public ScriptInit_OnFilterScriptExit() <_ALS : _ALS_x0, _ALS : _ALS_x1> { return 1; } public ScriptInit_OnFilterScriptExit() <> { return 1; }
#line 284

forward ScriptInit_OnGameModeExit(); public ScriptInit_OnGameModeExit() <_ALS : _ALS_x0, _ALS : _ALS_x1> { return 1; } public ScriptInit_OnGameModeExit() <> { return 1; }
#line 292

forward ScriptInit_OnScriptExit(); public ScriptInit_OnScriptExit() <_ALS : _ALS_x0, _ALS : _ALS_x1> { return 1; } public ScriptInit_OnScriptExit() <> { return 1; }
#line 300

















public _ScriptInit_FixState() <_script_init_fix_state : true>
{
}

public _ScriptInit_FixState() <_script_init_fix_state : false>
{
}

static stock _ScriptInit_IncludeStates() <_ALS : _ALS_x0, _ALS : _ALS_x1, _ALS : _ALS_x2, _ALS : _ALS_x3>
{
}

static stock _ScriptInit_IncludeStates() <_ALS : _ALS_go>
{
}



#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Internal\y_version.inc"
#line 117

#line 119

#line 123

#line 125

#line 127

#line 142

#line 148

#line 151










#line 162

#line 191

#line 197

#line 200

	forward YVers_Callback(index, code, data[]);

	public ScriptInit_OnScriptInit()
	{
#line 218
		print(" ");
		print(" ");
		print(" ");
		print(" ======================================= ");
		print(" |                                     | ");
		print(" |        YSI version " #4 "." #00 "." #0001 "        | ");
		print(" |        By Alex \"Y_Less\" Cole        | ");


		print(" |                                     | ");
		print(" ======================================= ");
		print(" ");























#line 256
		return 1;
	}

#line 264

#line 266

















	public YVers_Callback(index, code, data[])
	{
		if (code == 200)
		{




			new
				pos = strfind(data, "\n") + 1;
			if (strcmp(data[pos], #4 "." #00 "." #0001, false, 9))
			{

				print(" ");
				print(" ========================================== ");
				print(" |                                        | ");
				printf(" |  A new version (v%.9s) of YSI is  | ", data[pos]);
				print(" |            available from:             | ");
				print(" |                                        | ");
				print(" |     www.y-less.com/YSI/YSI_1.0.zip     | ");

				if (data[0] == '2')
				{
					print(" |                                        | ");
					print(" | Changelog:                             | ");

					new
						last = pos + 13;
					for ( ; ; )
					{
						pos = strfind(data[last], "\n", false);

						if (pos == -1)
						{

							break;
						}
						pos += last;
						data[pos - 1] = '\0';
						printf(" | %38s | ", data[last]);
						last = pos + 1;
					}
				}
				print(" |                                        | ");
				print(" ========================================== ");
				print(" ");
			}
		}
	}

#line 334


#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\y_cell.inc"
#line 96

#line 98






















stock Cell_ReverseBits({_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D}:data)
{


	#emit LOAD.S.pri           data
	#emit PUSH.pri
	#emit CONST.alt            0b10101010101010101010101010101010
	#emit AND
	#emit SHR.C.pri            1
	#emit SWAP.pri
	#emit CONST.alt            0b01010101010101010101010101010101
	#emit AND
	#emit SHL.C.pri            1
	#emit POP.alt
	#emit OR



	#emit PUSH.pri
	#emit CONST.alt            0b11001100110011001100110011001100
	#emit AND
	#emit SHR.C.pri            2
	#emit SWAP.pri
	#emit CONST.alt            0b00110011001100110011001100110011
	#emit AND
	#emit SHL.C.pri            2
	#emit POP.alt
	#emit OR



	#emit PUSH.pri
	#emit CONST.alt            0b11110000111100001111000011110000
	#emit AND
	#emit SHR.C.pri            4
	#emit SWAP.pri
	#emit CONST.alt            0b00001111000011110000111100001111
	#emit AND
	#emit SHL.C.pri            4
	#emit POP.alt
	#emit OR



	#emit PUSH.pri
	#emit MOVE.alt

	#emit SHR.C.pri            24
	#emit XCHG
	#emit SHL.C.pri            24
	#emit OR
	#emit SWAP.pri

	#emit PUSH.pri
	#emit CONST.alt            0x00FF0000
	#emit AND
	#emit SHR.C.pri            8
	#emit SWAP.pri

	#emit CONST.alt            0x0000FF00
	#emit AND
	#emit SHL.C.pri            8

	#emit POP.alt
	#emit OR
	#emit POP.alt
	#emit OR

	#emit RETN


	return 0;
}

#line 195






















stock Cell_ReverseNibbles({_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D}:data)
{


	#emit LOAD.S.pri           data
	#emit PUSH.pri
	#emit CONST.alt            0b11110000111100001111000011110000
	#emit AND
	#emit SHR.C.pri            4
	#emit SWAP.pri
	#emit CONST.alt            0b00001111000011110000111100001111
	#emit AND
	#emit SHL.C.pri            4
	#emit POP.alt
	#emit OR



	#emit PUSH.pri
	#emit MOVE.alt

	#emit SHR.C.pri            24
	#emit XCHG
	#emit SHL.C.pri            24
	#emit OR
	#emit SWAP.pri

	#emit PUSH.pri
	#emit CONST.alt            0x00FF0000
	#emit AND
	#emit SHR.C.pri            8
	#emit SWAP.pri

	#emit CONST.alt            0x0000FF00
	#emit AND
	#emit SHL.C.pri            8

	#emit POP.alt
	#emit OR
	#emit POP.alt
	#emit OR

	#emit RETN


	return 0;
}

#line 266






















stock Cell_ReverseBytes({_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D}:data)
{


	#emit LOAD.S.pri           data
	#emit PUSH.pri
	#emit MOVE.alt

	#emit SHR.C.pri            24
	#emit XCHG
	#emit SHL.C.pri            24
	#emit OR
	#emit SWAP.pri

	#emit PUSH.pri
	#emit CONST.alt            0x00FF0000
	#emit AND
	#emit SHR.C.pri            8
	#emit SWAP.pri

	#emit CONST.alt            0x0000FF00
	#emit AND
	#emit SHL.C.pri            8

	#emit POP.alt
	#emit OR
	#emit POP.alt
	#emit OR

	#emit RETN


	return 0;
}

#line 324


























stock Cell_CountBits({_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D}:data)
{


	#emit LOAD.S.pri           data 
	#emit PUSH.pri
	#emit SHR.C.pri            1
	#emit CONST.alt            0x55555555
	#emit AND                  
	#emit POP.alt
	#emit SUB.alt


	#emit PUSH.pri
	#emit SHR.C.pri            2
	#emit CONST.alt            0x33333333
	#emit AND
	#emit SWAP.pri             
	#emit AND                  
	#emit POP.alt
	#emit ADD


	#emit MOVE.alt
	#emit SHR.C.pri            4
	#emit ADD
	#emit CONST.alt            0xF0F0F0F
	#emit AND
	#emit SMUL.C               0x1010101
	#emit SHR.C.pri            24
	#emit RETN


	return 0;
}

#line 387




























stock Cell_GetLowestBit({_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D}:data)
{
	static const
		scDeBruijn[] =
			{
				 0,  1, 28,  2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17,  4,  8, 
				31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18,  6, 11,  5, 10,  9
			};


	#emit LOAD.S.pri           data
	#emit MOVE.alt
	#emit NEG
	#emit AND
	#emit SMUL.C               0x077CB531
	#emit SHR.C.pri            27

	#emit CONST.alt            scDeBruijn
	#emit LIDX

	#emit RETN


	return 0;
}

#line 442
































stock Cell_GetLowestBitEx({_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D}:data)
{



	static const
		scDeBruijn[] =
			{
				 1,  2, 29,  3, 30, 15, 25,  4, 31, 23, 21, 16, 26, 18,  5,  9, 
				32, 28, 14, 24, 22, 20, 17,  8, 27, 13, 19,  7, 12,  6, 11, 10
			};










	if (data)
	{

		#emit MOVE.alt
		#emit NEG
		#emit AND
		#emit SMUL.C               0x077CB531
		#emit SHR.C.pri            27

		#emit CONST.alt            scDeBruijn
		#emit LIDX
	}
	{} 
	#emit RETN


	return 0;
}

#line 515

























stock Cell_GetLowestComponent({_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D}:data)
{

	#emit LOAD.S.pri           data
	#emit MOVE.alt
	#emit NEG
	#emit AND
	#emit RETN


	return 0;
}

#line 554






























stock Cell_CompressRightPrecomputed({_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D}:x, m, masks[5])
{
	new t;
	return
		x = x & m,
		t = x & masks[0], x = x ^ t | (t >>>  1),
		t = x & masks[1], x = x ^ t | (t >>>  2),
		t = x & masks[2], x = x ^ t | (t >>>  4),
		t = x & masks[3], x = x ^ t | (t >>>  8),
		t = x & masks[4],     x ^ t | (t >>> 16);
}

#line 597
















stock Cell_ExpandLeftPrecomputed({_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D}:x, m, masks[5])
{
	new t;
	return
		t = x << 16, x = (((x ^ t) & masks[4]) ^ x),
		t = x <<  8, x = (((x ^ t) & masks[3]) ^ x),
		t = x <<  4, x = (((x ^ t) & masks[2]) ^ x),
		t = x <<  2, x = (((x ^ t) & masks[1]) ^ x),
		t = x <<  1, m & (((x ^ t) & masks[0]) ^ x);
}

#line 625















stock Cell_PrecomputeMaskPermutation(m)
{

	new
		mk = ~m << 1,
		mp,
		mv,
		masks[5];

	for (new i = 0; i != 5; ++i)
	{

		mp = mk ^ (mk <<  1),
		mp = mp ^ (mp <<  2),
		mp = mp ^ (mp <<  4),
		mp = mp ^ (mp <<  8),
		mp = mp ^ (mp << 16),

		masks[i] = mv = mp & m,

		m = m ^ mv | (mv >>> (1 << i)),
		mk = mk & ~mp;
	}
	return masks;
}

#line 667













stock Cell_CompressRight({_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D}:x, m)
{






	return Cell_CompressRightPrecomputed(x, m, Cell_PrecomputeMaskPermutation(m));
}

#line 692













stock Cell_ExpandLeft({_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D}:x, m)
{







	return Cell_ExpandLeftPrecomputed(x, m, Cell_PrecomputeMaskPermutation(m));
}

#line 721



#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\y_hooks.inc"
#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\y_utils.inc"
#line 2


















































































#line 88

#line 90

#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Core\y_debug.inc"
#line 2














































































































#line 116

#line 118

#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Core\..\YSI_Internal\y_funcinc.inc"
#line 2


























































#line 64

forward _@_y_funcinc_@_();

public _@_y_funcinc_@_()
{
	new _funcinc_a[1 char];


	printf("");
	strunpack(_funcinc_a, "");
	memcpy("", "", 0, 0, 0);
	format("", 0, "");
	strfind("", "", false, 0);
	strcat(_funcinc_a, "", 0);
	strlen("");
	CallRemoteFunction("", "");
	CallLocalFunction("", "");
	SetTimerEx("", 0, 0, "");
	heapspace();
	setproperty(0, "", 0, "");
	getproperty(0, "", 0, _funcinc_a);
	memset("", 0, 0);
	strcmp("", "");
}



#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Core\y_debug.inc"
#line 120

#line 122

#line 126

stock YSI_gDebugLevel = 0;

#line 131

#line 133
















#line 163

#line 169

#line 175

#line 181

#line 187

#line 193

#line 200

#line 206

#line 208














#line 236

#line 242

#line 248

#line 254

#line 260

#line 266

#line 273

#line 276

#line 279

#line 282

#line 285

#line 288

stock Debug_Print0(const str[], {Float,_}:...) <ysi_debug : on>
{
	static tmp1, tmp2;
	#emit POP.pri
	#emit STOR.pri     tmp1
	#emit POP.alt
	#emit STOR.alt     tmp2
	#emit SYSREQ.C     printf
	#emit PUSH         tmp2
	#emit PUSH         tmp1
	#pragma unused str
	return 0;
}

stock Debug_Print0(const str[], {Float,_}:...) <>
{
	#pragma unused str
	return 0;
}

stock Debug_PrintArray(arr[], size)
{
	new
		str[96];
	switch (size)
	{
		case 0:
			str = "<>";
		case 1:
			format(str, sizeof (str), "<%d>", arr[0]);
		case 2:
			format(str, sizeof (str), "<%d, %d>", arr[0], arr[1]);
		case 3:
			format(str, sizeof (str), "<%d, %d, %d>", arr[0], arr[1], arr[2]);
		case 4:
			format(str, sizeof (str), "<%d, %d, %d, %d>", arr[0], arr[1], arr[2], arr[3]);
		case 5:
			format(str, sizeof (str), "<%d, %d, %d, %d, %d>", arr[0], arr[1], arr[2], arr[3], arr[4]);
		default:
			format(str, sizeof (str), "<%d, %d, %d, %d, %d, ... (+ %d)>", arr[0], arr[1], arr[2], arr[3], arr[4], size - 5);
	}
	return str;
}

public YVers_OnScriptInit()
{
	Debug_SetState();
	new
		s;

	#emit CONST.pri YSI_FILTERSCRIPT
	#emit STOR.S.pri s
	if (s)
	{

#line 347
			return 1;
#line 349
	}
	Debug_Print0("\7\7\7\7\7*** YSI Fatal Error: " #"YSI_FILTERSCRIPT == 0");
	while (s != 10000000) ++s;
	#emit CONST.pri 0
	#emit SCTRL     6
	return 1;
}

static stock Debug_SetState() <ysi_debug : off>
{
}

static stock Debug_SetState() <>
{
	state ysi_debug : on;
}

#line 371

stock DebugLevel(level = -1)
{
	if (0 <= level <= 7)
	{
		YSI_gDebugLevel = level;
	}
	return YSI_gDebugLevel;
}



#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\y_utils.inc"
#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Storage\y_amx.inc"
#line 2


























































#line 64







#line 72

#line 76

#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Storage\..\YSI_Internal\y_thirdpartyinclude.inc"
#line 1





#line 14

#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Storage\..\YSI_Internal\..\amx\amx.inc"
#line 1




















#line 25

#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Storage\..\YSI_Internal\..\amx\phys_memory.inc"
#line 1




















#line 25

#line 27

#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Storage\..\YSI_Internal\..\amx\amx_base.inc"
#line 1




















#line 25

static stock GetAmxBaseAddress_helper() {
	return 0;
}


stock GetAmxBaseAddressNow() {
	new cod, dat;
	#emit lctrl 0
	#emit stor.s.pri cod
	#emit lctrl 1
	#emit stor.s.pri dat


	new code_start = cod - dat;


	new fn_addr;
	#emit const.pri GetAmxBaseAddress_helper
	#emit stor.s.pri fn_addr


	new fn_addr_reloc, call_addr;
	GetAmxBaseAddress_helper();
	#emit lctrl 6
	#emit stor.s.pri call_addr
	call_addr = call_addr - 12 + code_start;
	#emit lref.s.pri call_addr
	#emit stor.s.pri fn_addr_reloc

	return fn_addr_reloc - fn_addr - cod;
}

stock GetAmxBaseAddress() {
	static amx_base = 0;
	if (amx_base == 0) {
		amx_base = GetAmxBaseAddressNow();
	}
	return amx_base;
}


#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Storage\..\YSI_Internal\..\amx\phys_memory.inc"
#line 29

static stock GetDat() {
	#emit lctrl 1
	#emit retn
	return 0; 
}

static stock AbsToRel(address) {
	return address - (GetAmxBaseAddress() + GetDat());
}

static stock RelToAbs(address) {
	return address + (GetAmxBaseAddress() + GetDat());
}


stock refabs(...) {
	assert(numargs() == 1);
	new address;
	#emit load.s.pri 12
	#emit stor.s.pri address
	return RelToAbs(address);
}

stock ReadPhysMemory(address, dest[], num = sizeof(dest)) {
	new rel_addr = AbsToRel(address);


	new cur_dest;
	#emit load.s.pri dest
	#emit stor.s.pri cur_dest


	new cur_addr = rel_addr;


	for (new i = 0; i < num; i++, cur_addr += 4, cur_dest += 4) {
		#emit lref.s.pri cur_addr
		#emit sref.s.pri cur_dest
	}

	#emit stack 12
	#emit retn

	return 0; 
}

stock WritePhysMemory(address, src[], num = sizeof(src)) {
	new rel_addr = AbsToRel(address);


	new cur_src;
	#emit load.s.pri src
	#emit stor.s.pri cur_src


	new cur_addr = rel_addr;


	for (new i = 0; i < num; i++, cur_addr += 4, cur_src += 4) {
		#emit lref.s.pri cur_src
		#emit sref.s.pri cur_addr
	}

	#emit stack 12
	#emit retn

	return 0; 
}

stock ReadPhysMemoryCell(address) {
	new rel_addr = AbsToRel(address);
	#emit lref.s.pri rel_addr
	#emit stack 4
	#emit retn
	return 0; 
}

stock WritePhysMemoryCell(address, what) {
	new rel_addr = AbsToRel(address);
	#emit load.s.pri what
	#emit sref.s.pri rel_addr
	#emit stack 4
	#emit retn
	return 0; 
}


#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Storage\..\YSI_Internal\..\amx\amx.inc"
#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Storage\..\YSI_Internal\..\amx\shellcode.inc"
#line 1




















#line 25

#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Storage\..\YSI_Internal\..\amx\amx_header.inc"
#line 1




















#line 25

#line 27

#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Storage\..\YSI_Internal\..\amx\amx_memory.inc"
#line 1




















#line 25

#line 27


stock ref(...) {
	assert(numargs() == 1);
	#emit load.s.pri 12 
	#emit retn
	return 0; 
}

stock deref(v) {
	#pragma unused v
	static gFake[1];
	#emit load.s.pri 12 
	#emit stor.s.pri 16 
	#emit retn
	return gFake; 
}

stock ReadAmxMemory(address) {
	#emit lref.s.pri address
	#emit retn
	return 0; 
}

stock ReadAmxMemoryArray(address, values[], size = sizeof(values)) {
	for (new i = 0; i < size; i++) {
		values[i] = ReadAmxMemory(address + i * 4);
	}
}

stock WriteAmxMemory(address, value) {
	#emit load.s.pri value
	#emit sref.s.pri address
	#emit retn
	return 0; 
}

stock WriteAmxMemoryArray(address, const values[], size = sizeof(values)) {
	for (new i = 0; i < size; i++) {
		WriteAmxMemory(address + i * 4, values[i]);
	}
}


#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Storage\..\YSI_Internal\..\amx\amx_header.inc"
#line 29

#line 32

#line 35

enum AMX_HDR {
	AMX_HDR_SIZE,
	AMX_HDR_MAGIC,
	AMX_HDR_FILE_VERSION,
	AMX_HDR_AMX_VERSION,
	AMX_HDR_FLAGS,
	AMX_HDR_DEFSIZE,
	AMX_HDR_COD,
	AMX_HDR_DAT,
	AMX_HDR_HEA,
	AMX_HDR_STP,
	AMX_HDR_CIP,
	AMX_HDR_PUBLICS,
	AMX_HDR_NATIVES,
	AMX_HDR_LIBRARIES,
	AMX_HDR_PUBVARS,
	AMX_HDR_TAGS,
	AMX_HDR_NAMETABLE
}

const AMX_HDR_OFFSET_SIZE = 0;
const AMX_HDR_OFFSET_MAGIC = 4;
const AMX_HDR_OFFSET_FILE_VERSION = 6;
const AMX_HDR_OFFSET_AMX_VERSION = 7;
const AMX_HDR_OFFSET_FLAGS = 8;
const AMX_HDR_OFFSET_DEFSIZE = 10;
const AMX_HDR_OFFSET_COD = 12;
const AMX_HDR_OFFSET_DAT = 16;
const AMX_HDR_OFFSET_HEA = 20;
const AMX_HDR_OFFSET_STP = 24;
const AMX_HDR_OFFSET_CIP = 28;
const AMX_HDR_OFFSET_PUBLICS = 32;
const AMX_HDR_OFFSET_NATIVES = 36;
const AMX_HDR_OFFSET_LIBRARIES = 40;
const AMX_HDR_OFFSET_PUBVARS = 44;
const AMX_HDR_OFFSET_TAGS = 48;
const AMX_HDR_OFFSET_NAMETABLE = 52;

enum AMX_FUNCSTUBNT {
	AMX_FUNCSTUBNT_ADDRESS,
	AMX_FUNCSTUBNT_NAMEOFS
}
#line 79


forward bool:GetPublicInfo(index, info[AMX_FUNCSTUBNT]);
forward GetPublicIndexFromAddress(address);
forward GetPublicIndexFromName(const name[]);
forward GetPublicAddressFromName(const name[]);
forward GetPublicAddressFromIndex(index);
forward bool:GetPublicNameFromIndex(index, name[], size = sizeof(name));
forward bool:GetPublicNameFromAddress(address, name[], size = sizeof(name));
forward HookPublic(index, address);


forward bool:GetTagInfo(index, info[AMX_FUNCSTUBNT]);
forward GetTagIndexFromID(id);
forward GetTagIndexFromName(const name[]);
forward GetTagIDFromName(const name[]);
forward GetTagIDFromIndex(index);
forward bool:GetTagNameFromIndex(index, name[], size = sizeof(name));
forward bool:GetTagNameFromID(id, name[], size = sizeof(name));


forward bool:GetNativeInfo(index, info[AMX_FUNCSTUBNT]);
forward GetNativeIndexFromAddress(address);
forward GetNativeIndexFromName(const name[]);
forward GetNativeAddressFromName(const name[]);
forward GetNativeAddressFromIndex(index);
forward bool:GetNativeNameFromIndex(index, name[], size = sizeof(name));
forward bool:GetNativeNameFromAddress(address, name[], size = sizeof(name));
forward HookNative(index, address);


forward bool:GetPubVarInfo(index, info[AMX_FUNCSTUBNT]);
forward GetPubVarIndexFromName(const name[]);
forward GetPubVarIndexFromAddress(address);
forward GetPubVarAddressFromName(const name[]);
forward GetPubVarAddressFromIndex(index);
forward bool:GetPubVarNameFromIndex(index, name[], size = sizeof(name));
forward bool:GetPubVarNameFromAddress(address, name[], size = sizeof(name));


forward GetRawAmxHeader(plain_amxhdr[((60) / 4)]);
forward GetAmxHeaderNow(amxhdr[AMX_HDR]);
forward GetAmxHeader(amxhdr[AMX_HDR]);
forward GetAmxHeaderComponent(AMX_HDR:comp);
forward PrintAmxHeader();

stock GetRawAmxHeader(plain_amxhdr[((60) / 4)]) {
	new address;
	#emit lctrl 1  
	#emit neg      
	#emit stor.s.pri address

	for (new i = 0; i < ((60) / 4); i++) {
		plain_amxhdr[i] = ReadAmxMemory(address);
		address += 4;
	}
}

static stock copy_1(&dest, const source[], start) {
	#emit load.s.pri source
	#emit load.s.alt start
	#emit add
	#emit load.s.alt dest
	#emit movs 1
}

static stock copy_2(&dest, const source[], start) {
	#emit load.s.pri source
	#emit load.s.alt start
	#emit add
	#emit load.s.alt dest
	#emit movs 2
}

static stock copy_4(&dest, const source[], start) {
	#emit load.s.pri source
	#emit load.s.alt start
	#emit add
	#emit load.s.alt dest
	#emit movs 4
}

stock GetAmxHeaderNow(amxhdr[AMX_HDR]) {
	new plain_amxhdr[((60) / 4)];
	GetRawAmxHeader(plain_amxhdr);

	copy_4(amxhdr[AMX_HDR_SIZE], plain_amxhdr, AMX_HDR_OFFSET_SIZE);
	copy_2(amxhdr[AMX_HDR_MAGIC], plain_amxhdr, AMX_HDR_OFFSET_MAGIC);
	copy_1(amxhdr[AMX_HDR_FILE_VERSION], plain_amxhdr, AMX_HDR_OFFSET_FILE_VERSION);
	copy_1(amxhdr[AMX_HDR_AMX_VERSION], plain_amxhdr, AMX_HDR_OFFSET_AMX_VERSION);
	copy_2(amxhdr[AMX_HDR_FLAGS], plain_amxhdr, AMX_HDR_OFFSET_FLAGS);
	copy_2(amxhdr[AMX_HDR_DEFSIZE], plain_amxhdr, AMX_HDR_OFFSET_DEFSIZE);
	copy_4(amxhdr[AMX_HDR_COD], plain_amxhdr, AMX_HDR_OFFSET_COD);
	copy_4(amxhdr[AMX_HDR_DAT], plain_amxhdr, AMX_HDR_OFFSET_DAT);
	copy_4(amxhdr[AMX_HDR_HEA], plain_amxhdr, AMX_HDR_OFFSET_HEA);
	copy_4(amxhdr[AMX_HDR_STP], plain_amxhdr, AMX_HDR_OFFSET_STP);
	copy_4(amxhdr[AMX_HDR_CIP], plain_amxhdr, AMX_HDR_OFFSET_CIP);
	copy_4(amxhdr[AMX_HDR_PUBLICS], plain_amxhdr, AMX_HDR_OFFSET_PUBLICS);
	copy_4(amxhdr[AMX_HDR_NATIVES], plain_amxhdr, AMX_HDR_OFFSET_NATIVES);
	copy_4(amxhdr[AMX_HDR_LIBRARIES], plain_amxhdr, AMX_HDR_OFFSET_LIBRARIES);
	copy_4(amxhdr[AMX_HDR_PUBVARS], plain_amxhdr, AMX_HDR_OFFSET_PUBVARS);
	copy_4(amxhdr[AMX_HDR_TAGS], plain_amxhdr, AMX_HDR_OFFSET_TAGS);
	copy_4(amxhdr[AMX_HDR_NAMETABLE], plain_amxhdr, AMX_HDR_OFFSET_NAMETABLE);
}

static gHdr[AMX_HDR];
static bool:gInitialized = false;

stock ResetStaticAmxHeader() {
	GetAmxHeaderNow(gHdr);
	gInitialized = true;
}

#line 195

stock GetAmxHeader(amxhdr[AMX_HDR]) {
	if (!gInitialized) ResetStaticAmxHeader();
	amxhdr = gHdr;
}

stock GetAmxHeaderComponent(AMX_HDR:comp) {
	if (!gInitialized) ResetStaticAmxHeader();
	return gHdr[comp];
}

stock PrintAmxHeader() {
	if (!gInitialized) ResetStaticAmxHeader();
	printf("------------------------");
	printf("AMX Header:");
	printf("------------------------");
	printf("size         %d", gHdr[AMX_HDR_SIZE]);
	printf("magic        %x", gHdr[AMX_HDR_MAGIC]);
	printf("file_version %d", gHdr[AMX_HDR_FILE_VERSION]);
	printf("amx_version  %d", gHdr[AMX_HDR_AMX_VERSION]);
	printf("flags        %d", gHdr[AMX_HDR_FLAGS]);
	printf("defsize      %d", gHdr[AMX_HDR_DEFSIZE]);
	printf("cod          0x%08x", gHdr[AMX_HDR_COD]);
	printf("dat          0x%08x", gHdr[AMX_HDR_DAT]);
	printf("hea          0x%08x", gHdr[AMX_HDR_HEA]);
	printf("stp          0x%08x", gHdr[AMX_HDR_STP]);
	printf("cip          0x%08x", gHdr[AMX_HDR_CIP]);
	printf("publics      0x%08x", gHdr[AMX_HDR_PUBLICS]);
	printf("natives      0x%08x", gHdr[AMX_HDR_NATIVES]);
	printf("libraries    0x%08x", gHdr[AMX_HDR_LIBRARIES]);
	printf("pubvars      0x%08x", gHdr[AMX_HDR_PUBVARS]);
	printf("tags         0x%08x", gHdr[AMX_HDR_TAGS]);
	printf("nametable    0x%08x", gHdr[AMX_HDR_NAMETABLE]);
	printf("------------------------");
}



static stock NtCompare(s1, const s2[]) {
	new index;
	new c1, c2;
	new diff;

	do {
		c1 = ReadAmxMemory(s1++) & 0xFF;
		c2 = s2[index++];
		diff = c1 - c2;
		if (diff != 0) {
			break;
		}
	} while (!(c1 & c2 == 0));

	return diff;
}



static stock NtCopy(src, dest[], size = sizeof(dest)) {
	new i = 0;
	new c;

	do {
		c = ReadAmxMemory(src++) & 0xFF;
		dest[i++] = c;
	} while (c != '\0' && i <= size);

	dest[i] = '\0'; 

	return i;
}

stock GetNumPublics(amxhdr[AMX_HDR]) {
	new num_publics = (amxhdr[AMX_HDR_NATIVES] - amxhdr[AMX_HDR_PUBLICS]) / amxhdr[AMX_HDR_DEFSIZE];
	return num_publics;
}

stock GetPublicIndexFromAddress(address) {
	if (!gInitialized) ResetStaticAmxHeader();

	new num_publics = GetNumPublics(gHdr);
	new off = gHdr[AMX_HDR_PUBLICS] - gHdr[AMX_HDR_DAT];


	for (new i = 0; i < num_publics; i++) {
		if (ReadAmxMemory(off) == address) {
			return i;
		}
		off += gHdr[AMX_HDR_DEFSIZE];
	}

	return -1;
}

stock bool:GetPublicInfo(index, info[AMX_FUNCSTUBNT]) {
	if (!gInitialized) ResetStaticAmxHeader();

	new num_publics = GetNumPublics(gHdr);

	if (index < 0 || index >= num_publics) {
		return false;
	}

	new off = gHdr[AMX_HDR_PUBLICS] - gHdr[AMX_HDR_DAT] + index * gHdr[AMX_HDR_DEFSIZE];
	info[AMX_FUNCSTUBNT_ADDRESS] = ReadAmxMemory(off);
	info[AMX_FUNCSTUBNT_NAMEOFS] = ReadAmxMemory(off + 4);

	return true;
}

stock GetPublicIndexFromName(const name[]) {
	if (!gInitialized) ResetStaticAmxHeader();

	new num_publics = GetNumPublics(gHdr);


	new first = 0;
	new last = num_publics - 1;
	new mid;

	while (first <= last) {
		mid = (first + last) / 2;

		new off = gHdr[AMX_HDR_PUBLICS] - gHdr[AMX_HDR_DAT] + mid * gHdr[AMX_HDR_DEFSIZE];
		new nameofs = ReadAmxMemory(off + 4) - gHdr[AMX_HDR_DAT];

		new diff = NtCompare(nameofs, name);
		if (diff < 0) {
			first = mid + 1;
		} else if (diff > 0) {
			last = mid - 1;
		} else {
			return mid;
		}
	}

	return -1;
}

stock GetPublicAddressFromIndex(index) {
	new info[AMX_FUNCSTUBNT];
	GetPublicInfo(index, info);
	return info[AMX_FUNCSTUBNT_ADDRESS];
}

stock GetPublicAddressFromName(const name[]) {
	return GetPublicAddressFromIndex(GetPublicIndexFromName(name));
}

stock bool:GetPublicNameFromIndex(index, name[], size = sizeof(name)) {
	new info[AMX_FUNCSTUBNT];
	if (!GetPublicInfo(index, info)) {
		return false;
	}
	return (NtCopy(info[AMX_FUNCSTUBNT_NAMEOFS]
	        - GetAmxHeaderComponent(AMX_HDR_DAT), name, size) > 0);
}

stock bool:GetPublicNameFromAddress(address, name[], size = sizeof(name)) {
	return GetPublicNameFromIndex(GetPublicIndexFromAddress(address), name, size);
}

stock HookPublic(index, address) {
	if (!gInitialized) ResetStaticAmxHeader();

	new num_publics = GetNumPublics(gHdr);

	if (index < 0 || index >= num_publics) {
		return 0;
	}

	new off = gHdr[AMX_HDR_PUBLICS] - gHdr[AMX_HDR_DAT] + index * gHdr[AMX_HDR_DEFSIZE];
	new old_address = ReadAmxMemory(off);
	WriteAmxMemory(off, address);

	return old_address;
}

stock GetNumNatives(amxhdr[AMX_HDR]) {
	return (amxhdr[AMX_HDR_LIBRARIES] - amxhdr[AMX_HDR_NATIVES]) / amxhdr[AMX_HDR_DEFSIZE];
}

stock GetNativeIndexFromAddress(address) {
	if (!gInitialized) ResetStaticAmxHeader();

	new num_natives = GetNumNatives(gHdr);
	new off = gHdr[AMX_HDR_NATIVES] - gHdr[AMX_HDR_DAT];


	for (new i = 0; i < num_natives; i++) {
		if (ReadAmxMemory(off) == address) {
			return i;
		}
		off += gHdr[AMX_HDR_DEFSIZE];
	}

	return -1;
}

stock bool:GetNativeInfo(index, info[AMX_FUNCSTUBNT]) {
	if (!gInitialized) ResetStaticAmxHeader();


	info[AMX_FUNCSTUBNT_ADDRESS] = -1;

	new num_natives = GetNumNatives(gHdr);

	if (index < 0 || index >= num_natives) {
		return false;
	}

	new off = gHdr[AMX_HDR_NATIVES] - gHdr[AMX_HDR_DAT] + index * gHdr[AMX_HDR_DEFSIZE];
	info[AMX_FUNCSTUBNT_ADDRESS] = ReadAmxMemory(off);
	info[AMX_FUNCSTUBNT_NAMEOFS] = ReadAmxMemory(off + 4);

	return true;
}

stock GetNativeIndexFromName(const name[]) {
	if (!gInitialized) ResetStaticAmxHeader();

	new num_natives = GetNumNatives(gHdr);
	new off = gHdr[AMX_HDR_NATIVES] - gHdr[AMX_HDR_DAT];


	for (new i = 0; i < num_natives; i++) {
		new nameofs = ReadAmxMemory(off + 4) - gHdr[AMX_HDR_DAT];

		new diff = NtCompare(nameofs, name);
		if (diff == 0) {
			return i;
		}

		off += gHdr[AMX_HDR_DEFSIZE];
	}

	return -1;
}

stock GetNativeAddressFromIndex(index) {
	new info[AMX_FUNCSTUBNT];
	GetNativeInfo(index, info);
	return info[AMX_FUNCSTUBNT_ADDRESS];
}

stock GetNativeAddressFromName(const name[]) {
	return GetNativeAddressFromIndex(GetNativeIndexFromName(name));
}

stock bool:GetNativeNameFromIndex(index, name[], size = sizeof(name)) {
	new info[AMX_FUNCSTUBNT];
	if (!GetNativeInfo(index, info)) {
		return false;
	}
	return (NtCopy(info[AMX_FUNCSTUBNT_NAMEOFS]
	        - GetAmxHeaderComponent(AMX_HDR_DAT), name, size) > 0);
}

stock bool:GetNativeNameFromAddress(address, name[], size = sizeof(name)) {
	return GetNativeNameFromIndex(GetNativeIndexFromAddress(address), name, size);
}

stock HookNative(index, address) {
	if (!gInitialized) ResetStaticAmxHeader();

	new num_natives = GetNumNatives(gHdr);

	if (index < 0 || index >= num_natives) {
		return 0;
	}

	new off = gHdr[AMX_HDR_NATIVES] - gHdr[AMX_HDR_DAT] + index * gHdr[AMX_HDR_DEFSIZE];
	new old_address = ReadAmxMemory(off);
	WriteAmxMemory(off, address);

	return old_address;
}

stock GetNumPubVars(amxhdr[AMX_HDR]) {
	return (amxhdr[AMX_HDR_TAGS] - amxhdr[AMX_HDR_PUBVARS]) / amxhdr[AMX_HDR_DEFSIZE];
}

stock bool:GetPubVarInfo(index, info[AMX_FUNCSTUBNT]) {
	if (!gInitialized) ResetStaticAmxHeader();

	new num_pubvars = GetNumPubVars(gHdr);

	if (index < 0 || index >= num_pubvars) {
		return false;
	}

	new off = gHdr[AMX_HDR_PUBVARS] - gHdr[AMX_HDR_DAT] + index * gHdr[AMX_HDR_DEFSIZE];
	info[AMX_FUNCSTUBNT_ADDRESS] = ReadAmxMemory(off);
	info[AMX_FUNCSTUBNT_NAMEOFS] = ReadAmxMemory(off + 4);

	return true;
}

stock GetPubVarIndexFromName(const name[]) {
	if (!gInitialized) ResetStaticAmxHeader();

	new num_pubvars = GetNumPubVars(gHdr);


	new first = 0;
	new last = num_pubvars - 1;
	new mid;

	while (first <= last) {
		mid = (first + last) / 2;

		new off = gHdr[AMX_HDR_PUBVARS] - gHdr[AMX_HDR_DAT] + mid * gHdr[AMX_HDR_DEFSIZE];
		new nameofs = ReadAmxMemory(off + 4) - gHdr[AMX_HDR_DAT];

		new diff = NtCompare(nameofs, name);
		if (diff < 0) {
			first = mid + 1;
		} else if (diff > 0) {
			last = mid - 1;
		} else {
			return mid;
		}
	}

	return -1;
}

stock GetPubVarIndexFromAddress(address) {
	if (!gInitialized) ResetStaticAmxHeader();

	new num_pubvars = GetNumPubVars(gHdr);
	new off = gHdr[AMX_HDR_PUBVARS] - gHdr[AMX_HDR_DAT];


	for (new i = 0; i < num_pubvars; i++) {
		if (ReadAmxMemory(off) == address) {
			return i;
		}
		off += gHdr[AMX_HDR_DEFSIZE];
	}

	return -1;
}

stock GetPubVarAddressFromIndex(index) {
	new info[AMX_FUNCSTUBNT];
	GetPubVarInfo(index, info);
	return info[AMX_FUNCSTUBNT_ADDRESS];
}

stock GetPubVarAddressFromName(const name[]) {
	return GetPubVarAddressFromIndex(GetPubVarIndexFromName(name));
}

stock bool:GetPubVarNameFromIndex(index, name[], size = sizeof(name)) {
	new info[AMX_FUNCSTUBNT];
	if (!GetPubVarInfo(index, info)) {
		return false;
	}
	return (NtCopy(info[AMX_FUNCSTUBNT_NAMEOFS]
	        - GetAmxHeaderComponent(AMX_HDR_DAT), name, size) > 0);
}

stock bool:GetPubVarNameFromAddress(address, name[], size = sizeof(name)) {
	return GetPubVarNameFromIndex(GetPubVarIndexFromAddress(address), name, size);
}

static stock GetNumTagsInternal(amxhdr[AMX_HDR]) {
	return (amxhdr[AMX_HDR_NAMETABLE] - amxhdr[AMX_HDR_TAGS]) / amxhdr[AMX_HDR_DEFSIZE];
}

stock GetNumTags(amxhdr[AMX_HDR]) {
	return GetNumTagsInternal(amxhdr) + 1;
}

stock bool:GetTagInfo(index, info[AMX_FUNCSTUBNT]) {
	if (index == 0) {
		info[AMX_FUNCSTUBNT_ADDRESS] = (0x80000000);
		info[AMX_FUNCSTUBNT_NAMEOFS] = 0;
		return true;
	}
	if (!gInitialized) ResetStaticAmxHeader();

	new num_tags = GetNumTagsInternal(gHdr);

	if (index < 0 || index >= num_tags) {
		return false;
	}

	new off = gHdr[AMX_HDR_TAGS] - gHdr[AMX_HDR_DAT] + index * gHdr[AMX_HDR_DEFSIZE];
	info[AMX_FUNCSTUBNT_ADDRESS] = ReadAmxMemory(off) | (0x80000000);
	info[AMX_FUNCSTUBNT_NAMEOFS] = ReadAmxMemory(off + 4);

	return true;
}

stock GetTagIndexFromName(const name[]) {
	if (name[0] == '_' && name[1] == '\0')
		return 0;
	if (!gInitialized) ResetStaticAmxHeader();

	new num_tags = GetNumTagsInternal(gHdr);


	new first = 0;
	new last = num_tags - 1;
	new mid;

	while (first <= last) {
		mid = (first + last) / 2;

		new off = gHdr[AMX_HDR_TAGS] - gHdr[AMX_HDR_DAT] + mid * gHdr[AMX_HDR_DEFSIZE];
		new nameofs = ReadAmxMemory(off + 4) - gHdr[AMX_HDR_DAT];

		new diff = NtCompare(nameofs, name);
		if (diff < 0) {
			first = mid + 1;
		} else if (diff > 0) {
			last = mid - 1;
		} else {
			return mid;
		}
	}

	return -1;
}

stock GetTagIndexFromID(id) {
	id &= ~(0x80000000);
	if (id == 0)
		return 0;
	if (!gInitialized) ResetStaticAmxHeader();

	new num_tags = GetNumTagsInternal(gHdr);
	new off = gHdr[AMX_HDR_TAGS] - gHdr[AMX_HDR_DAT];


	for (new i = 0; i < num_tags; i++) {
		if (ReadAmxMemory(off) == id) {
			return i;
		}
		off += gHdr[AMX_HDR_DEFSIZE];
	}

	return -1;
}

stock GetTagIDFromIndex(index) {
	if (index == 0)
		return (0x80000000);
	new info[AMX_FUNCSTUBNT];
	GetTagInfo(index, info);
	return info[AMX_FUNCSTUBNT_ADDRESS];
}

stock GetTagIDFromName(const name[]) {
	if (name[0] == '_' && name[1] == '\0')
		return (0x80000000);
	return GetTagIDFromIndex(GetTagIndexFromName(name));
}

stock bool:GetTagNameFromIndex(index, name[], size = sizeof(name)) {
	if (index == 0)
	{
		name[0] = '_';
		name[1] = '\0';
		return true;
	}
	new info[AMX_FUNCSTUBNT];
	if (!GetTagInfo(index, info)) {
		return false;
	}
	return (NtCopy(info[AMX_FUNCSTUBNT_NAMEOFS]
	        - GetAmxHeaderComponent(AMX_HDR_DAT), name, size) > 0);
}

stock bool:GetTagNameFromID(id, name[], size = sizeof(name)) {
	if (id == 0)
	{
		name[0] = '_';
		name[1] = '\0';
		return true;
	}
	return GetTagNameFromIndex(GetTagIndexFromID(id), name, size);
}

stock bool:IsTagIDStrong(tag) {
	return !!(tag & (0x40000000));
}

stock bool:IsTagIDWeak(tag) {
	return !(tag & (0x40000000));
}

stock bool:IsTagIDEmpty(tag) {
	return !(tag & ~(0x80000000));
}

stock bool:IsTagNameStrong(tag[]) {
	return ('A' <= tag[0] <= 'Z');
}

stock bool:IsTagNameWeak(tag[]) {
	return !('A' <= tag[0] <= 'Z');
}

stock bool:IsTagNameEmpty(tag[]) {
	return (tag[0] == '_' && tag[1] == '\0');
}

stock bool:IsTagIndexStrong(tag) {
	new info[AMX_FUNCSTUBNT];
	return (GetTagInfo(index, info) && IsTagIDStrong(info[AMX_FUNCSTUBNT_ADDRESS]);
}

stock bool:IsTagIndexWeak(tag) {
	new info[AMX_FUNCSTUBNT];
	return (GetTagInfo(index, info) && IsTagIDWeak(info[AMX_FUNCSTUBNT_ADDRESS]);
}

stock bool:IsTagIndexEmpty(tag) {
	return (tag == 0);
}

#line 719



#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Storage\..\YSI_Internal\..\amx\shellcode.inc"
#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Storage\..\YSI_Internal\..\amx\dynamic_call.inc"
#line 1




















#line 25

#line 27

#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Storage\..\YSI_Internal\..\amx\amx_jit.inc"
#line 1




















#line 25

stock GetJITGeneratorVersion() {
	#emit zero.pri
	#emit lctrl 7
	#emit retn
	return 0;
}

stock GetAmxJITBaseAddress() {



	#emit zero.pri
	#emit lctrl 8
	#emit retn
	return 0;
}



#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Storage\..\YSI_Internal\..\amx\dynamic_call.inc"
#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Storage\..\YSI_Internal\..\amx\opcode.inc"
#line 1




















#line 25

#line 27

	#pragma warning push
	#pragma warning disable 207
	#pragma disablerecursion
	#pragma warning pop


	#pragma warning disable 238
#line 36

enum Opcode {
  OP_NONE,         OP_LOAD_PRI,     OP_LOAD_ALT,
  OP_LOAD_S_PRI,   OP_LOAD_S_ALT,   OP_LREF_PRI,
  OP_LREF_ALT,     OP_LREF_S_PRI,   OP_LREF_S_ALT,
  OP_LOAD_I,       OP_LODB_I,       OP_CONST_PRI,
  OP_CONST_ALT,    OP_ADDR_PRI,     OP_ADDR_ALT,
  OP_STOR_PRI,     OP_STOR_ALT,     OP_STOR_S_PRI,
  OP_STOR_S_ALT,   OP_SREF_PRI,     OP_SREF_ALT,
  OP_SREF_S_PRI,   OP_SREF_S_ALT,   OP_STOR_I,
  OP_STRB_I,       OP_LIDX,         OP_LIDX_B,
  OP_IDXADDR,      OP_IDXADDR_B,    OP_ALIGN_PRI,
  OP_ALIGN_ALT,    OP_LCTRL,        OP_SCTRL,
  OP_MOVE_PRI,     OP_MOVE_ALT,     OP_XCHG,
  OP_PUSH_PRI,     OP_PUSH_ALT,     OP_PUSH_R,
  OP_PUSH_C,       OP_PUSH,         OP_PUSH_S,
  OP_POP_PRI,      OP_POP_ALT,      OP_STACK,
  OP_HEAP,         OP_PROC,         OP_RET,
  OP_RETN,         OP_CALL,         OP_CALL_PRI,
  OP_JUMP,         OP_JREL,         OP_JZER,
  OP_JNZ,          OP_JEQ,          OP_JNEQ,
  OP_JLESS,        OP_JLEQ,         OP_JGRTR,
  OP_JGEQ,         OP_JSLESS,       OP_JSLEQ,
  OP_JSGRTR,       OP_JSGEQ,        OP_SHL,
  OP_SHR,          OP_SSHR,         OP_SHL_C_PRI,
  OP_SHL_C_ALT,    OP_SHR_C_PRI,    OP_SHR_C_ALT,
  OP_SMUL,         OP_SDIV,         OP_SDIV_ALT,
  OP_UMUL,         OP_UDIV,         OP_UDIV_ALT,
  OP_ADD,          OP_SUB,          OP_SUB_ALT,
  OP_AND,          OP_OR,           OP_XOR,
  OP_NOT,          OP_NEG,          OP_INVERT,
  OP_ADD_C,        OP_SMUL_C,       OP_ZERO_PRI,
  OP_ZERO_ALT,     OP_ZERO,         OP_ZERO_S,
  OP_SIGN_PRI,     OP_SIGN_ALT,     OP_EQ,
  OP_NEQ,          OP_LESS,         OP_LEQ,
  OP_GRTR,         OP_GEQ,          OP_SLESS,
  OP_SLEQ,         OP_SGRTR,        OP_SGEQ,
  OP_EQ_C_PRI,     OP_EQ_C_ALT,     OP_INC_PRI,
  OP_INC_ALT,      OP_INC,          OP_INC_S,
  OP_INC_I,        OP_DEC_PRI,      OP_DEC_ALT,
  OP_DEC,          OP_DEC_S,        OP_DEC_I,
  OP_MOVS,         OP_CMPS,         OP_FILL,
  OP_HALT,         OP_BOUNDS,       OP_SYSREQ_PRI,
  OP_SYSREQ_C,     OP_FILE,         OP_LINE,
  OP_SYMBOL,       OP_SRANGE,       OP_JUMP_PRI,
  OP_SWITCH,       OP_CASETBL,      OP_SWAP_PRI,
  OP_SWAP_ALT,     OP_PUSH_ADR,     OP_NOP,
  OP_SYSREQ_D,     OP_SYMTAG,       OP_BREAK,
  OP_LAST_
};

const NUM_OPCODES = _:OP_LAST_;

static stock Opcode:ReadOpcodeNearThis(offset = 0) {
	new ret_addr;


	#emit load.s.alt 4
	#emit lctrl 0
	#emit add
	#emit move.alt
	#emit lctrl 1
	#emit xchg
	#emit sub
	#emit load.s.alt offset
	#emit add

	#emit stor.s.pri ret_addr
	#emit lref.s.pri ret_addr

	#emit stack 4
	#emit retn

	return OP_NONE; 
}

static stock bool:HaveToRelocateOpcodes() {
	return ReadOpcodeNearThis(-8) != OP_CALL;
}


stock Opcode:RelocateOpcodeNow(Opcode:opcode) {
	if (!HaveToRelocateOpcodes()) {
		return opcode;
	}
	switch (opcode) {
		case OP_LOAD_PRI: {
			return ReadOpcodeNearThis(4);
			#emit load.pri 0
		}
		case OP_LOAD_ALT: {
			return ReadOpcodeNearThis(4);
			#emit load.alt 0
		}
		case OP_LOAD_S_PRI: {
			return ReadOpcodeNearThis(4);
			#emit load.s.pri 0
		}
		case OP_LOAD_S_ALT: {
			return ReadOpcodeNearThis(4);
			#emit load.s.alt 0
		}
		case OP_LREF_PRI: {
			return ReadOpcodeNearThis(4);
			#emit lref.pri 0
		}
		case OP_LREF_ALT: {
			return ReadOpcodeNearThis(4);
			#emit lref.alt 0
		}
		case OP_LREF_S_PRI: {
			return ReadOpcodeNearThis(4);
			#emit lref.s.pri 0
		}
		case OP_LREF_S_ALT: {
			return ReadOpcodeNearThis(4);
			#emit lref.s.alt 0
		}
		case OP_LOAD_I: {
			return ReadOpcodeNearThis(4);
			#emit load.i
		}
		case OP_LODB_I: {
			return ReadOpcodeNearThis(4);
			#emit lodb.i 1
		}
		case OP_CONST_PRI: {
			return ReadOpcodeNearThis(4);
			#emit const.pri 0
		}
		case OP_CONST_ALT: {
			return ReadOpcodeNearThis(4);
			#emit const.alt 0
		}
		case OP_ADDR_PRI: {
			return ReadOpcodeNearThis(4);
			#emit addr.pri 0
		}
		case OP_ADDR_ALT: {
			return ReadOpcodeNearThis(4);
			#emit addr.alt 0
		}
		case OP_STOR_PRI: {
			return ReadOpcodeNearThis(4);
			#emit stor.pri 0
		}
		case OP_STOR_ALT: {
			return ReadOpcodeNearThis(4);
			#emit stor.alt 0
		}
		case OP_STOR_S_PRI: {
			return ReadOpcodeNearThis(4);
			#emit stor.s.pri 0
		}
		case OP_STOR_S_ALT: {
			return ReadOpcodeNearThis(4);
			#emit stor.s.alt 0
		}
		case OP_SREF_PRI: {
			return ReadOpcodeNearThis(4);
			#emit sref.pri 0
		}
		case OP_SREF_ALT: {
			return ReadOpcodeNearThis(4);
			#emit sref.alt 0
		}
		case OP_SREF_S_PRI: {
			return ReadOpcodeNearThis(4);
			#emit sref.s.pri 0
		}
		case OP_SREF_S_ALT: {
			return ReadOpcodeNearThis(4);
			#emit sref.s.alt 0
		}
		case OP_STOR_I: {
			return ReadOpcodeNearThis(4);
			#emit stor.i
		}
		case OP_STRB_I: {
			return ReadOpcodeNearThis(4);
			#emit strb.i 1
		}
		case OP_LIDX: {
			return ReadOpcodeNearThis(4);
			#emit lidx
		}
		case OP_LIDX_B: {
			return ReadOpcodeNearThis(4);
			#emit lidx.b 0
		}
		case OP_IDXADDR: {
			return ReadOpcodeNearThis(4);
			#emit idxaddr
		}
		case OP_IDXADDR_B: {
			return ReadOpcodeNearThis(4);
			#emit idxaddr.b 0
		}
		case OP_ALIGN_PRI: {
			return ReadOpcodeNearThis(4);
			#emit align.pri 0
		}
		case OP_ALIGN_ALT: {
			return ReadOpcodeNearThis(4);
			#emit align.alt 0
		}
		case OP_LCTRL: {
			return ReadOpcodeNearThis(4);
			#emit lctrl 0
		}
		case OP_SCTRL: {
			return ReadOpcodeNearThis(4);
			#emit sctrl 0
		}
		case OP_MOVE_PRI: {
			return ReadOpcodeNearThis(4);
			#emit move.pri
		}
		case OP_MOVE_ALT: {
			return ReadOpcodeNearThis(4);
			#emit move.alt
		}
		case OP_XCHG: {
			return ReadOpcodeNearThis(4);
			#emit xchg
		}
		case OP_PUSH_PRI: {
			return ReadOpcodeNearThis(4);
			#emit push.pri
		}
		case OP_PUSH_ALT: {
			return ReadOpcodeNearThis(4);
			#emit push.alt
		}
		case OP_PUSH_C: {
			return ReadOpcodeNearThis(4);
			#emit push.c 0
		}
		case OP_PUSH: {
			return ReadOpcodeNearThis(4);
			#emit push 0
		}
		case OP_PUSH_S: {
			return ReadOpcodeNearThis(4);
			#emit push.s 0
		}
		case OP_POP_PRI: {
			return ReadOpcodeNearThis(4);
			#emit pop.pri
		}
		case OP_POP_ALT: {
			return ReadOpcodeNearThis(4);
			#emit pop.alt
		}
		case OP_STACK: {
			return ReadOpcodeNearThis(4);
			#emit stack 0
		}
		case OP_HEAP: {
			return ReadOpcodeNearThis(4);
			#emit heap 0
		}
		case OP_PROC: {
			return ReadOpcodeNearThis(4);
			#emit proc
		}
		case OP_RET: {
			return ReadOpcodeNearThis(4);
			#emit ret
		}
		case OP_RETN: {
			return ReadOpcodeNearThis(4);
			#emit retn
		}
		case OP_CALL: {

			return ReadOpcodeNearThis(-8);
		}
		case OP_JUMP: {
			return ReadOpcodeNearThis(4);
			#emit jump 0
		}
		case OP_JZER: {
			return ReadOpcodeNearThis(4);
			#emit jzer 0
		}
		case OP_JNZ: {
			return ReadOpcodeNearThis(4);
			#emit jnz 0
		}
		case OP_JEQ: {
			return ReadOpcodeNearThis(4);
			#emit jeq 0
		}
		case OP_JNEQ: {
			return ReadOpcodeNearThis(4);
			#emit jneq 0
		}
		case OP_JLESS: {
			return ReadOpcodeNearThis(4);
			#emit jless 0
		}
		case OP_JLEQ: {
			return ReadOpcodeNearThis(4);
			#emit jleq 0
		}
		case OP_JGRTR: {
			return ReadOpcodeNearThis(4);
			#emit jgrtr 0
		}
		case OP_JGEQ: {
			return ReadOpcodeNearThis(4);
			#emit jgeq 0
		}
		case OP_JSLESS: {
			return ReadOpcodeNearThis(4);
			#emit jsless 0
		}
		case OP_JSLEQ: {
			return ReadOpcodeNearThis(4);
			#emit jsleq 0
		}
		case OP_JSGRTR: {
			return ReadOpcodeNearThis(4);
			#emit jsgrtr 0
		}
		case OP_JSGEQ: {
			return ReadOpcodeNearThis(4);
			#emit jsgeq 0
		}
		case OP_SHL: {
			return ReadOpcodeNearThis(4);
			#emit shl
		}
		case OP_SHR: {
			return ReadOpcodeNearThis(4);
			#emit shr
		}
		case OP_SSHR: {
			return ReadOpcodeNearThis(4);
			#emit sshr
		}
		case OP_SHL_C_PRI: {
			return ReadOpcodeNearThis(4);
			#emit shl.c.pri 0
		}
		case OP_SHL_C_ALT: {
			return ReadOpcodeNearThis(4);
			#emit shl.c.alt 0
		}
		case OP_SHR_C_PRI: {
			return ReadOpcodeNearThis(4);
			#emit shr.c.pri 0
		}
		case OP_SHR_C_ALT: {
			return ReadOpcodeNearThis(4);
			#emit shr.c.alt 0
		}
		case OP_SMUL: {
			return ReadOpcodeNearThis(4);
			#emit smul
		}
		case OP_SDIV: {
			return ReadOpcodeNearThis(4);
			#emit sdiv
		}
		case OP_SDIV_ALT: {
			return ReadOpcodeNearThis(4);
			#emit sdiv.alt
		}
		case OP_UMUL: {
			return ReadOpcodeNearThis(4);
			#emit umul
		}
		case OP_UDIV: {
			return ReadOpcodeNearThis(4);
			#emit udiv
		}
		case OP_UDIV_ALT: {
			return ReadOpcodeNearThis(4);
			#emit udiv.alt
		}
		case OP_ADD: {
			return ReadOpcodeNearThis(4);
			#emit add
		}
		case OP_SUB: {
			return ReadOpcodeNearThis(4);
			#emit sub
		}
		case OP_SUB_ALT: {
			return ReadOpcodeNearThis(4);
			#emit sub.alt
		}
		case OP_AND: {
			return ReadOpcodeNearThis(4);
			#emit and
		}
		case OP_OR: {
			return ReadOpcodeNearThis(4);
			#emit or
		}
		case OP_XOR: {
			return ReadOpcodeNearThis(4);
			#emit xor
		}
		case OP_NOT: {
			return ReadOpcodeNearThis(4);
			#emit not
		}
		case OP_NEG: {
			return ReadOpcodeNearThis(4);
			#emit neg
		}
		case OP_INVERT: {
			return ReadOpcodeNearThis(4);
			#emit invert
		}
		case OP_ADD_C: {
			return ReadOpcodeNearThis(4);
			#emit add.c 0
		}
		case OP_SMUL_C: {
			return ReadOpcodeNearThis(4);
			#emit smul.c 0
		}
		case OP_ZERO_PRI: {
			return ReadOpcodeNearThis(4);
			#emit zero.pri
		}
		case OP_ZERO_ALT: {
			return ReadOpcodeNearThis(4);
			#emit zero.alt
		}
		case OP_ZERO: {
			return ReadOpcodeNearThis(4);
			#emit zero 0
		}
		case OP_ZERO_S: {
			return ReadOpcodeNearThis(4);
			#emit zero.s 0
		}
		case OP_SIGN_PRI: {
			return ReadOpcodeNearThis(4);
			#emit sign.pri
		}
		case OP_SIGN_ALT: {
			return ReadOpcodeNearThis(4);
			#emit sign.alt
		}
		case OP_EQ: {
			return ReadOpcodeNearThis(4);
			#emit eq
		}
		case OP_NEQ: {
			return ReadOpcodeNearThis(4);
			#emit neq
		}
		case OP_LESS: {
			return ReadOpcodeNearThis(4);
			#emit less
		}
		case OP_LEQ: {
			return ReadOpcodeNearThis(4);
			#emit leq
		}
		case OP_GRTR: {
			return ReadOpcodeNearThis(4);
			#emit grtr
		}
		case OP_GEQ: {
			return ReadOpcodeNearThis(4);
			#emit geq
		}
		case OP_SLESS: {
			return ReadOpcodeNearThis(4);
			#emit sless
		}
		case OP_SLEQ: {
			return ReadOpcodeNearThis(4);
			#emit sleq
		}
		case OP_SGRTR: {
			return ReadOpcodeNearThis(4);
			#emit sgrtr
		}
		case OP_SGEQ: {
			return ReadOpcodeNearThis(4);
			#emit sgeq
		}
		case OP_EQ_C_PRI: {
			return ReadOpcodeNearThis(4);
			#emit eq.c.pri 0
		}
		case OP_EQ_C_ALT: {
			return ReadOpcodeNearThis(4);
			#emit eq.c.alt 0
		}
		case OP_INC_PRI: {
			return ReadOpcodeNearThis(4);
			#emit inc.pri
		}
		case OP_INC_ALT: {
			return ReadOpcodeNearThis(4);
			#emit inc.alt
		}
		case OP_INC: {
			return ReadOpcodeNearThis(4);
			#emit inc 0
		}
		case OP_INC_S: {
			return ReadOpcodeNearThis(4);
			#emit inc.s 0
		}
		case OP_INC_I: {
			return ReadOpcodeNearThis(4);
			#emit inc.i
		}
		case OP_DEC_PRI: {
			return ReadOpcodeNearThis(4);
			#emit dec.pri
		}
		case OP_DEC_ALT: {
			return ReadOpcodeNearThis(4);
			#emit dec.alt
		}
		case OP_DEC: {
			return ReadOpcodeNearThis(4);
			#emit dec 0
		}
		case OP_DEC_S: {
			return ReadOpcodeNearThis(4);
			#emit dec.s 0
		}
		case OP_DEC_I: {
			return ReadOpcodeNearThis(4);
			#emit dec.i
		}
		case OP_MOVS: {
			return ReadOpcodeNearThis(4);
			#emit movs 0
		}
		case OP_CMPS: {
			return ReadOpcodeNearThis(4);
			#emit cmps 0
		}
		case OP_FILL: {
			return ReadOpcodeNearThis(4);
			#emit fill 0
		}
		case OP_HALT: {
			return ReadOpcodeNearThis(4);
			#emit halt 0
		}
		case OP_BOUNDS: {
			return ReadOpcodeNearThis(4);
			#emit bounds 0
		}
		case OP_SYSREQ_C: {
			return ReadOpcodeNearThis(4);
			#emit sysreq.c 0
		}
		case OP_SWITCH: {
			static T = 1;
#line 601
				if (T) return ReadOpcodeNearThis(12);
#line 605
			switch (0) {
				case 0: {}
			}
		}
		case OP_CASETBL: {
			new x = 0;
			switch (x) { case 0: return ReadOpcodeNearThis(20); }
		}
		case OP_SWAP_PRI: {
			return ReadOpcodeNearThis(4);
			#emit swap.pri
		}
		case OP_SWAP_ALT: {
			return ReadOpcodeNearThis(4);
			#emit swap.alt
		}
		case OP_PUSH_ADR: {
			return ReadOpcodeNearThis(4);
			#emit push.adr 0
		}
		case OP_NOP: {
			return ReadOpcodeNearThis(4);
			#emit nop
		}
		case OP_SYSREQ_D: {


			new bool:is_crashdetect;
			#emit zero.pri
			#emit lctrl 0xFF
			#emit stor.s.pri is_crashdetect
			if (is_crashdetect) {



				return RelocateOpcodeNow(OP_NOP) - Opcode:0x1EA;
			} else {
				return RelocateOpcodeNow(OP_NOP) - Opcode:0x4F;
			}
		}
		case OP_BREAK: {
			return ReadOpcodeNearThis(4);
			#emit break
		}
	}
	return opcode;
}

static stock Opcode:opcode_table[NUM_OPCODES];
static stock bool:opcode_table_is_ready = false;

static stock InitOpcodeTable() {
	for (new i = 0; i < NUM_OPCODES; i++) {
		opcode_table[i] = RelocateOpcodeNow(Opcode:i);
	}
	opcode_table_is_ready = true;
}

stock Opcode:RelocateOpcode(Opcode:opcode) {
	if (!opcode_table_is_ready) {
		InitOpcodeTable();
	}
	return opcode_table[_:opcode];
}

stock Opcode:UnrelocateOpcode(Opcode:opcode) {
	if (!opcode_table_is_ready) {
		InitOpcodeTable();
	}
	if (OP_NONE <= opcode < Opcode:NUM_OPCODES) {
		return opcode;
	}
	for (new i = 0; i < NUM_OPCODES; i++) {
		if (opcode_table[i] == opcode) {
			return Opcode:i;
		}
	}
	return opcode;
}


#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Storage\..\YSI_Internal\..\amx\dynamic_call.inc"
#line 32

#line 36

forward bool:Push(arg);
forward bool:PushString(const string[]);
forward bool:Pop(&arg = 0);
forward Call(address, bool:auto_pop = true);
forward SysreqC(index, bool:auto_pop = true);
forward SysreqD(address, bool:auto_pop = true);
forward CallN(address, args_to_push, bool:auto_pop = true);
forward SysreqCN(index, args_to_push, bool:auto_pop = true);
forward SysreqDN(address, args_to_push, bool:auto_pop = true);
forward CallFunction(address, {Float,_}:...);
forward CallNative(index, {Float,_}:...);
forward CallNativeByAddress(address, {Float,_}:...);

static stock g_nargs = 0;
static stock g_args[256];

forward DynamicCallFunctionInclusion_();

public DynamicCallFunctionInclusion_() {




	numargs();
}

stock bool:Push(arg) {
	if (g_nargs < sizeof(g_args)) {
		g_args[g_nargs++] = arg;
		return true;
	}
	return false;
}

stock bool:PushString(const string[]) {
	new address;
	#emit load.s.pri string
	#emit stor.s.pri address
	return Push(address);
}

stock bool:Pop(&arg = 0) {
	if (g_nargs > 0) {
		arg = g_args[--g_nargs];
		return true;
	}
	return false;
}

stock Call(address, bool:auto_pop = true) {
	new arg = 0;
	new index = g_nargs;
	new bytes = g_nargs * 4;
	new retval;

	while (--index >= 0) {
		arg = g_args[index];
		#emit push.s arg
	}

	#emit load.s.pri bytes
	#emit push.pri

	#emit lctrl 6
	#emit add.c 0x24
	#emit lctrl 8
	#emit push.pri
	#emit load.s.pri address
	#emit sctrl 6

	#emit stor.s.pri retval

	if (auto_pop) {
		g_nargs = 0;
	}

	return retval;
}

stock CallN(address, args_to_push, bool:auto_pop = true) {

	new arg = 0;
	new index = g_nargs;
	new bytes = args_to_push * 4;
	new end = g_nargs - args_to_push;
	new retval;

	if (end < 0) {
		return cellmin;
	}

	while (--index >= end) {
		arg = g_args[index];
		#emit push.s arg
	}

	#emit load.s.pri bytes
	#emit push.pri

	#emit lctrl 6
	#emit add.c 0x24
	#emit lctrl 8
	#emit push.pri
	#emit load.s.pri address
	#emit sctrl 6

	#emit stor.s.pri retval

	if (auto_pop) {
		g_nargs = end;
	}

	return retval;
}

stock CallFunction(address, {Float,_}:...) {
	new arg_bytes, arg_begin, arg_end;


	#emit load.s.pri 0x8
	#emit const.alt 4
	#emit sub
	#emit stor.s.pri arg_bytes
	#emit move.alt


	#emit lctrl 5
	#emit add.c 0xc
	#emit add
	#emit stor.s.pri arg_end


	#emit lctrl 5
	#emit add.c 0x10
	#emit stor.s.pri arg_begin

	new arg = arg_end;
	while (arg >= arg_begin) {
		#emit lref.s.pri arg
		#emit load.i
		#emit push.pri
		arg -= 4;
	}


	#emit push.s arg_bytes
	#emit lctrl 6
	#emit add.c 0x24
	#emit lctrl 8
	#emit push.pri
	#emit load.s.pri address
	#emit sctrl 6



	#emit stack 0x10
	#emit retn

	return 0; 
}

stock SysreqC(index, bool:auto_pop = true) {
	new arg = 0;
	new i = g_nargs;
	new bytes = g_nargs * 4;
	new tmp;
	new Opcode:sysreq_c = RelocateOpcode(OP_SYSREQ_C);
	new retval;

	if (GetJITGeneratorVersion()) {
		return cellmin;
	}

	while (--i >= 0) {
		arg = g_args[i];
		#emit push.s arg
	}

	#emit load.s.pri bytes
	#emit push.pri


	#emit lctrl 0  
	#emit move.alt
	#emit lctrl 6  
	#emit add
	#emit move.alt
	#emit lctrl 1  
	#emit sub.alt
	#emit add.c 0x5c
	#emit stor.s.pri tmp


	#emit load.s.pri sysreq_c
	#emit sref.s.pri tmp


	#emit load.s.pri tmp
	#emit add.c 4
	#emit stor.s.pri tmp


	#emit load.s.pri index
	#emit sref.s.pri tmp

	#emit nop
	#emit nop


	#emit stor.s.pri retval


	#emit lctrl 4
	#emit load.s.alt bytes
	#emit add
	#emit add.c 4
	#emit sctrl 4

	if (auto_pop) {
		g_nargs = 0;
	}

	return retval;
}

stock SysreqD(address, bool:auto_pop = true) {
	new arg = 0;
	new i = g_nargs;
	new bytes = g_nargs * 4;
	new tmp;
	new Opcode:sysreq_d = RelocateOpcode(OP_SYSREQ_D);
	new retval;

	if (GetJITGeneratorVersion()) {
		return cellmin;
	}

	while (--i >= 0) {
		arg = g_args[i];
		#emit push.s arg
	}

	#emit load.s.pri bytes
	#emit push.pri


	#emit lctrl 0  
	#emit move.alt
	#emit lctrl 6  
	#emit add
	#emit move.alt
	#emit lctrl 1 
	#emit sub.alt
	#emit add.c 0x5c
	#emit stor.s.pri tmp


	#emit load.s.pri sysreq_d
	#emit sref.s.pri tmp


	#emit load.s.pri tmp
	#emit add.c 4
	#emit stor.s.pri tmp


	#emit load.s.pri address
	#emit sref.s.pri tmp

	#emit nop
	#emit nop

	#emit stor.s.pri retval


	#emit lctrl 4
	#emit load.s.alt bytes
	#emit add
	#emit add.c 4
	#emit sctrl 4

	if (auto_pop) {
		g_nargs = 0;
	}

	return retval;
}

stock SysreqCN(index, args_to_push, bool:auto_pop = true) {
	new arg = 0;
	new i = g_nargs;
	new bytes = args_to_push * 4;
	new tmp;
	new Opcode:sysreq_c = RelocateOpcode(OP_SYSREQ_C);
	new end = g_nargs - args_to_push;
	new retval;

	if (GetJITGeneratorVersion()) {
		return cellmin;
	}

	if (end < 0) {
		return cellmin;
	}

	while (--i >= end) {
		arg = g_args[i];
		#emit push.s arg
	}
	#emit load.s.pri bytes
	#emit push.pri


	#emit lctrl 0  
	#emit move.alt
	#emit lctrl 6  
	#emit add
	#emit move.alt
	#emit lctrl 1  
	#emit sub.alt
	#emit add.c 0x5c
	#emit stor.s.pri tmp


	#emit load.s.pri sysreq_c
	#emit sref.s.pri tmp


	#emit load.s.pri tmp
	#emit add.c 4
	#emit stor.s.pri tmp


	#emit load.s.pri index
	#emit sref.s.pri tmp

	#emit nop
	#emit nop

	#emit stor.s.pri retval


	#emit lctrl 4
	#emit load.s.alt bytes
	#emit add
	#emit add.c 4
	#emit sctrl 4

	if (auto_pop) {
		g_nargs = end;
	}

	return retval;
}

stock SysreqDN(address, args_to_push, bool:auto_pop = true) {
	new arg = 0;
	new i = g_nargs;
	new bytes = args_to_push * 4;
	new tmp;
	new Opcode:sysreq_d = RelocateOpcode(OP_SYSREQ_D);
	new end = g_nargs - args_to_push;
	new retval;

	if (GetJITGeneratorVersion()) {
		return cellmin;
	}

	if (end < 0) {
		return cellmin;
	}

	while (--i >= end) {
		arg = g_args[i];
		#emit push.s arg
	}

	#emit load.s.pri bytes
	#emit push.pri


	#emit lctrl 0  
	#emit move.alt
	#emit lctrl 6  
	#emit add
	#emit move.alt
	#emit lctrl 1 
	#emit sub.alt
	#emit add.c 0x5c
	#emit stor.s.pri tmp


	#emit load.s.pri sysreq_d
	#emit sref.s.pri tmp


	#emit load.s.pri tmp
	#emit add.c 4
	#emit stor.s.pri tmp


	#emit load.s.pri address
	#emit sref.s.pri tmp

	#emit nop
	#emit nop

	#emit stor.s.pri retval


	#emit lctrl 4
	#emit load.s.alt bytes
	#emit add
	#emit add.c 4
	#emit sctrl 4

	if (auto_pop) {
		g_nargs = end;
	}

	return retval;
}

stock CallNative(index, {Float,_}:...) {
	new arg_bytes, arg_begin, arg_end;
	new Opcode:sysreq_c = RelocateOpcode(OP_SYSREQ_C);

	if (GetJITGeneratorVersion()) {
		return cellmin;
	}


	#emit load.s.pri 0x8
	#emit const.alt 4
	#emit sub
	#emit stor.s.pri arg_bytes
	#emit move.alt


	#emit lctrl 5
	#emit add.c 0xc
	#emit add
	#emit stor.s.pri arg_end


	#emit lctrl 5
	#emit add.c 0x10
	#emit stor.s.pri arg_begin

	new arg = arg_end;
	new tmp;

	while (arg >= arg_begin) {
		#emit lref.s.pri arg
		#emit load.i
		#emit push.pri
		arg -= 4;
	}


	#emit push.s arg_bytes


	#emit lctrl 0  
	#emit move.alt
	#emit lctrl 6  
	#emit add
	#emit move.alt
	#emit lctrl 1 
	#emit sub.alt
	#emit add.c 0x5c
	#emit stor.s.pri tmp


	#emit load.s.pri sysreq_c
	#emit sref.s.pri tmp


	#emit load.s.pri tmp
	#emit add.c 4
	#emit stor.s.pri tmp


	#emit load.s.pri index
	#emit sref.s.pri tmp

	#emit nop
	#emit nop

	new retval;
	#emit stor.s.pri retval


	#emit lctrl 4
	#emit load.s.alt arg_bytes
	#emit add
	#emit add.c 4
	#emit sctrl 4

	return retval;
}


stock CallNativeByAddress(address, {Float,_}:...) {
	new arg_bytes, arg_begin, arg_end;
	new Opcode:sysreq_d = RelocateOpcode(OP_SYSREQ_D);

	if (GetJITGeneratorVersion()) {
		return cellmin;
	}


	#emit load.s.pri 0x8
	#emit const.alt 4
	#emit sub
	#emit stor.s.pri arg_bytes
	#emit move.alt


	#emit lctrl 5
	#emit add.c 0xc
	#emit add
	#emit stor.s.pri arg_end


	#emit lctrl 5
	#emit add.c 0x10
	#emit stor.s.pri arg_begin

	new arg = arg_end;
	new tmp;

	while (arg >= arg_begin) {
		#emit lref.s.pri arg
		#emit load.i
		#emit push.pri
		arg -= 4;
	}


	#emit push.s arg_bytes


	#emit lctrl 0  
	#emit move.alt
	#emit lctrl 6  
	#emit add
	#emit move.alt
	#emit lctrl 1 
	#emit sub.alt
	#emit add.c 0x5c
	#emit stor.s.pri tmp


	#emit load.s.pri sysreq_d
	#emit sref.s.pri tmp


	#emit load.s.pri tmp
	#emit add.c 4
	#emit stor.s.pri tmp


	#emit load.s.pri address
	#emit sref.s.pri tmp

	#emit nop
	#emit nop

	new retval;
	#emit stor.s.pri retval


	#emit lctrl 4
	#emit load.s.alt arg_bytes
	#emit add
	#emit add.c 4
	#emit sctrl 4

	return retval;
}


#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Storage\..\YSI_Internal\..\amx\shellcode.inc"
#line 29

stock RunShellcode(code_ptr, bool:align = true) {
	if (align) {
		code_ptr = ((code_ptr + 15) >>> 4) << 4;
	}
	return SysreqD(code_ptr);
}


#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Storage\..\YSI_Internal\..\amx\amx.inc"
#line 28

const AMX_OFFSET_BASE = 0;
const AMX_OFFSET_DATA = 4;
const AMX_OFFSET_CALLBACK = 8;
const AMX_OFFSET_DEBUG = 12;
const AMX_OFFSET_CIP = 16;
const AMX_OFFSET_FRM = 20;
const AMX_OFFSET_HEA = 24;
const AMX_OFFSET_HLW = 28;
const AMX_OFFSET_STK = 32;
const AMX_OFFSET_STP = 36;
const AMX_OFFSET_FLAGS = 40;
const AMX_OFFSET_USERTAGS = 44;
const AMX_OFFSET_USERDATA = 60;
const AMX_OFFSET_ERROR = 76;
const AMX_OFFSET_PARAMCOUNT = 80;
const AMX_OFFSET_PRI = 84;
const AMX_OFFSET_ALT = 88;
const AMX_OFFSET_RESET_STK = 92;
const AMX_OFFSET_RESET_HEA = 96;
const AMX_OFFSET_SYSREQ_D = 100;



stock GetAmxAddress() {
	static address = 0;
	if (address == 0) {
		static const code[] = {
			0x90909090, 0x90909090, 0x90909090, 0x90909090, 
			0x0424448b, 0xC3C3C3C3


		};
		address = RunShellcode(refabs(code));
	}
	return address;
}


stock ReadAmxCell(offset) {
	new amx = GetAmxAddress();
	return ReadPhysMemoryCell(amx + offset);
}


stock WriteAmxCell(offset, value) {
	new amx = GetAmxAddress();
	WritePhysMemoryCell(amx + offset, value);
}


#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Storage\..\YSI_Internal\y_thirdpartyinclude.inc"
#line 24

#line 34

#line 44

#line 57

#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Storage\..\YSI_Internal\..\amx\asm.inc"
#line 1




















#line 25

#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Storage\..\YSI_Internal\..\amx\asm_macros.inc"
#line 1




















#line 25



#line 29

#line 31

#line 33


#line 173

#line 178


#line 241


#line 304


#line 502

#line 512




#line 529

#line 543

#line 557


#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Storage\..\YSI_Internal\..\amx\asm.inc"
#line 32

enum AsmError {
	ASM_ERROR_NONE,
	ASM_ERROR_OPCODE,
	ASM_ERROR_OPERAND,
	ASM_ERROR_SPACE,
};

enum AsmContext {
	AsmContext_buffer,
	AsmContext_buffer_size,
	AsmContext_buffer_offset,
	AsmContext_error,
	AsmContext_error_handler,  
};

stock const ASM_ARGUMENTS_OFFSET    =  0x0C;
stock const ASM_LOCALS_OFFSET       = -0x04;
stock const ASM_CALLER_FRAME_OFFSET =  0x00;
stock const ASM_RETURN_ADDR_OFFSET  =  0x04;

stock const ASM_CTRL_COD = 0;
stock const ASM_CTRL_DAT = 1;
stock const ASM_CTRL_HEA = 2;
stock const ASM_CTRL_STP = 3;
stock const ASM_CTRL_STK = 4;
stock const ASM_CTRL_FRM = 5;
stock const ASM_CTRL_CIP = 6;
stock const ASM_CTRL_JIT = 7;
stock const ASM_CTRL_JMP = 8;

static gPreviousWriteOffset = cellmin;



static stock AsmError:AsmRaiseError(ctx[AsmContext], AsmError:error) {
	if (error != ASM_ERROR_NONE) {
		AsmSetError(ctx, error);
		if (ctx[AsmContext_error_handler] != 0) {
			CallFunction(ctx[AsmContext_error_handler], ref(ctx));
		}
	}
	return error;
}

static stock AsmError:AsmEmitCell(ctx[AsmContext], value) {
	if (ctx[AsmContext_buffer_offset] >= ctx[AsmContext_buffer_size]) {
		return AsmRaiseError(ctx, ASM_ERROR_SPACE);
	}

	WriteAmxMemory(ctx[AsmContext_buffer] + ctx[AsmContext_buffer_offset], value);
	ctx[AsmContext_buffer_offset] += 4;

	return ASM_ERROR_NONE;
}



stock AsmError:AsmEmitOpcode(ctx[AsmContext], Opcode:opcode) {
	if (opcode <= OP_NONE || _:opcode >= NUM_OPCODES) {
		return AsmRaiseError(ctx, ASM_ERROR_OPCODE);
	}
	return AsmEmitCell(ctx, _:RelocateOpcode(opcode));
}

stock AsmError:AsmEmitOperand(ctx[AsmContext], value) {
	return AsmEmitCell(ctx, value);
}

stock AsmError:AsmEmitInstruction(ctx[AsmContext], Opcode:opcode, ...) {

	gPreviousWriteOffset = ctx[AsmContext_buffer_offset];

	new AsmError:error = ASM_ERROR_NONE;

	error = AsmEmitOpcode(ctx, opcode);
	if (error != ASM_ERROR_NONE) {
		return error;
	}

	static const STATIC_ARGS = 2;
	new num_opers = numargs() - STATIC_ARGS;

	for (new i = 0; i < num_opers; i++) {
		error = AsmEmitOperand(ctx, getarg(STATIC_ARGS + i));
		if (error != ASM_ERROR_NONE) {
			return error;
		}
	}

	return ASM_ERROR_NONE;
}

stock AsmGetJumpAddressFromOffset(ctx[AsmContext], offset) {
	new amxhdr[AMX_HDR];
	GetAmxHeader(amxhdr);

	new next_offset = 2 * 4; 
	new base = GetAmxBaseAddress() + amxhdr[AMX_HDR_DAT];
	new dest = ctx[AsmContext_buffer] + ctx[AsmContext_buffer_offset] + next_offset + offset;

	return base + dest;
}

stock AsmError:AsmEmitJumpInstruction(ctx[AsmContext], Opcode:opcode, offset) {
	return AsmEmitInstruction(ctx, opcode, AsmGetJumpAddressFromOffset(ctx, offset));
}

stock AsmError:AsmInitPtr(ctx[AsmContext], buffer, size) {
	ctx[AsmContext_buffer] = buffer;
	ctx[AsmContext_buffer_size] = size;
	ctx[AsmContext_buffer_offset] = 0;
	ctx[AsmContext_error_handler] = 0;
	return ASM_ERROR_NONE;
}

stock AsmGetPreviousWriteOffset() {
	return gPreviousWriteOffset;
}

stock AsmGetBufferSize(ctx[AsmContext]) {
	return ctx[AsmContext_buffer_size] - ctx[AsmContext_buffer_offset];
}

stock AsmError:AsmInit(ctx[AsmContext], buffer[], size = sizeof(buffer)) {
	AsmInitPtr(ctx, ref(buffer), size * 4);
}

stock AsmGetCode(const ctx[AsmContext]) {
	new amxhdr[AMX_HDR];
	GetAmxHeader(amxhdr);
	return ctx[AsmContext_buffer] + amxhdr[AMX_HDR_DAT] - amxhdr[AMX_HDR_COD];
}

stock AsmGetCodeSize(const ctx[AsmContext]) {
	return ctx[AsmContext_buffer_offset];
}

stock AsmError:AsmGetError(ctx[AsmContext]) {
	return AsmError:ctx[AsmContext_error];
}

stock AsmSetError(ctx[AsmContext], AsmError:error) {
	ctx[AsmContext_error] = _:error;
}

stock AsmClearError(ctx[AsmContext]) {
	AsmSetError(ctx, ASM_ERROR_NONE);
}

stock AsmGetErrorHandler(const ctx[AsmContext]) {
	return ctx[AsmContext_error_handler];
}

stock AsmError:AsmSetErrorHandler(ctx[AsmContext], error_handler) {
	ctx[AsmContext_error_handler] = error_handler;
	return ASM_ERROR_NONE;
}

stock AsmError:AsmSetErrorHandlerName(ctx[AsmContext], error_handler[]) {
	ctx[AsmContext_error_handler] = GetPublicAddressFromName(error_handler);
	return ASM_ERROR_NONE;
}



stock AsmError:AsmEmitAdd(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_ADD);
}

stock AsmError:AsmEmitAddC(ctx[AsmContext], value) {
	return AsmEmitInstruction(ctx, OP_ADD_C, value);
}

stock AsmError:AsmEmitAddrAlt(ctx[AsmContext], offset) {
	return AsmEmitInstruction(ctx, OP_ADDR_ALT, offset);
}

stock AsmError:AsmEmitAddrPri(ctx[AsmContext], offset) {
	return AsmEmitInstruction(ctx, OP_ADDR_PRI, offset);
}

stock AsmError:AsmEmitAlignAlt(ctx[AsmContext], number) {
	return AsmEmitInstruction(ctx, OP_ALIGN_ALT, number);
}

stock AsmError:AsmEmitAlignPri(ctx[AsmContext], number) {
	return AsmEmitInstruction(ctx, OP_ALIGN_PRI, number);
}

stock AsmError:AsmEmitAnd(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_AND);
}

stock AsmError:AsmEmitBounds(ctx[AsmContext], bound) {
	return AsmEmitInstruction(ctx, OP_BOUDNS, bound);
}

stock AsmError:AsmEmitBreak(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_BREAK);
}

stock AsmError:AsmEmitCall(ctx[AsmContext], address) {
	return AsmEmitInstruction(ctx, OP_CALL, address);
}

stock AsmError:AsmEmitCallAbs(ctx[AsmContext], address) {
	new hdr[AMX_HDR];
	GetAmxHeader(hdr);
	return AsmEmitInstruction(ctx, OP_CALL, address + GetAmxBaseAddress() + hdr[AMX_HDR_COD]);
}

stock AsmError:AsmEmitCmps(ctx[AsmContext], nbytes) {
	return AsmEmitInstruction(ctx, OP_CMPS, nbytes);
}

stock AsmError:AsmEmitConstAlt(ctx[AsmContext], value) {
	return AsmEmitInstruction(ctx, OP_CONST_ALT, value);
}

stock AsmError:AsmEmitConstPri(ctx[AsmContext], value) {
	return AsmEmitInstruction(ctx, OP_CONST_PRI, value);
}

stock AsmError:AsmEmitDec(ctx[AsmContext], address) {
	return AsmEmitInstruction(ctx, OP_DEC, address);
}

stock AsmError:AsmEmitDecAlt(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_DEC_ALT);
}

stock AsmError:AsmEmitDecI(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_DEC_I);
}

stock AsmError:AsmEmitDecPri(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_DEC_PRI);
}

stock AsmError:AsmEmitDecS(ctx[AsmContext], offset) {
	return AsmEmitInstruction(ctx, OP_DEC_S, offset);
}

stock AsmError:AsmEmitEq(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_EQ);
}

stock AsmError:AsmEmitEqCAlt(ctx[AsmContext], value) {
	return AsmEmitInstruction(ctx, OP_EQ_C_ALT, value);
}

stock AsmError:AsmEmitEqCPri(ctx[AsmContext], value) {
	return AsmEmitInstruction(ctx, OP_EQ_C_PRI, value);
}

stock AsmError:AsmEmitFill(ctx[AsmContext], nbytes) {
	return AsmEmitInstruction(ctx, OP_FILL, nbytes);
}

stock AsmError:AsmEmitGeq(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_GEQ);
}

stock AsmError:AsmEmitGrtr(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_GRTR);
}

stock AsmError:AsmEmitHalt(ctx[AsmContext], code) {
	return AsmEmitInstruction(ctx, OP_HALT, code);
}

stock AsmError:AsmEmitHeap(ctx[AsmContext], nbytes) {
	return AsmEmitInstruction(ctx, OP_HEAP, nbytes);
}

stock AsmError:AsmEmitIdxaddr(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_IDXADDR);
}

stock AsmError:AsmEmitIdxaddrB(ctx[AsmContext], shift) {
	return AsmEmitInstruction(ctx, OP_IDXADDR_B, shift);
}

stock AsmError:AsmEmitInc(ctx[AsmContext], address) {
	return AsmEmitInstruction(ctx, OP_INC, address);
}

stock AsmError:AsmEmitIncAlt(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_INC_ALT);
}

stock AsmError:AsmEmitIncI(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_INC_I);
}

stock AsmError:AsmEmitIncPri(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_INC_PRI);
}

stock AsmError:AsmEmitIncS(ctx[AsmContext], offset) {
	return AsmEmitInstruction(ctx, OP_INC_S, offset);
}

stock AsmError:AsmEmitInvert(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_INVERT);
}

stock AsmError:AsmEmitJeq(ctx[AsmContext], address) {
	return AsmEmitInstruction(ctx, OP_JEQ, address);
}

stock AsmError:AsmEmitJeqRel(ctx[AsmContext], offset) {
	return AsmEmitJumpInstruction(ctx, OP_JEQ, offset);
}

stock AsmError:AsmEmitJgeq(ctx[AsmContext], address) {
	return AsmEmitInstruction(ctx, OP_JGEQ, address);
}

stock AsmError:AsmEmitJgeqRel(ctx[AsmContext], offset) {
	return AsmEmitJumpInstruction(ctx, OP_JGEQ, offset);
}

stock AsmError:AsmEmitJgrtr(ctx[AsmContext], address) {
	return AsmEmitInstruction(ctx, OP_JGRTR, address);
}

stock AsmError:AsmEmitJgrtrRel(ctx[AsmContext], offset) {
	return AsmEmitJumpInstruction(ctx, OP_JGRTR, offset);
}

stock AsmError:AsmEmitJleq(ctx[AsmContext], address) {
	return AsmEmitInstruction(ctx, OP_JLEQ, address);
}

stock AsmError:AsmEmitJleqRel(ctx[AsmContext], offset) {
	return AsmEmitJumpInstruction(ctx, OP_JLEQ, offset);
}

stock AsmError:AsmEmitJless(ctx[AsmContext], address) {
	return AsmEmitInstruction(ctx, OP_JLESS, address);
}

stock AsmError:AsmEmitJlessRel(ctx[AsmContext], offset) {
	return AsmEmitJumpInstruction(ctx, OP_JLESS, offset);
}

stock AsmError:AsmEmitJneq(ctx[AsmContext], address) {
	return AsmEmitInstruction(ctx, OP_JNEQ, address);
}

stock AsmError:AsmEmitJneqRel(ctx[AsmContext], offset) {
	return AsmEmitJumpInstruction(ctx, OP_JNEQ, offset);
}

stock AsmError:AsmEmitJnz(ctx[AsmContext], address) {
	return AsmEmitInstruction(ctx, OP_JNZ, address);
}

stock AsmError:AsmEmitJnzRel(ctx[AsmContext], offset) {
	return AsmEmitJumpInstruction(ctx, OP_JNZ, offset);
}

stock AsmError:AsmEmitJsgeq(ctx[AsmContext], address) {
	return AsmEmitInstruction(ctx, OP_JSGEQ, address);
}

stock AsmError:AsmEmitJsgeqRel(ctx[AsmContext], offset) {
	return AsmEmitJumpInstruction(ctx, OP_JSGEQ, offset);
}

stock AsmError:AsmEmitJsgrtr(ctx[AsmContext], address) {
	return AsmEmitInstruction(ctx, OP_JSTRTR, address);
}

stock AsmError:AsmEmitJsgrtrRel(ctx[AsmContext], offset) {
	return AsmEmitJumpInstruction(ctx, OP_JSTRTR, offset);
}

stock AsmError:AsmEmitJsleq(ctx[AsmContext], address) {
	return AsmEmitInstruction(ctx, OP_JSLEQ, address);
}

stock AsmError:AsmEmitJsleqRel(ctx[AsmContext], offset) {
	return AsmEmitJumpInstruction(ctx, OP_JSLEQ, offset);
}

stock AsmError:AsmEmitJsless(ctx[AsmContext], address) {
	return AsmEmitInstruction(ctx, OP_JSLESS, address);
}

stock AsmError:AsmEmitJslessRel(ctx[AsmContext], offset) {
	return AsmEmitJumpInstruction(ctx, OP_JSLESS, offset);
}

stock AsmError:AsmEmitJump(ctx[AsmContext], address) {
	return AsmEmitInstruction(ctx, OP_JUMP, address);
}

stock AsmError:AsmEmitJumpRel(ctx[AsmContext], offset) {
	return AsmEmitJumpInstruction(ctx, OP_JUMP, offset);
}

stock AsmError:AsmEmitJzer(ctx[AsmContext], address) {
	return AsmEmitInstruction(ctx, OP_JZER, address);
}

stock AsmError:AsmEmitJzerRel(ctx[AsmContext], offset) {
	return AsmEmitJumpInstruction(ctx, OP_JZER, offset);
}

stock AsmError:AsmEmitJrel(ctx[AsmContext], offset) {
	return AsmEmitInstruction(ctx, OP_JREL, offset);
}

stock AsmError:AsmEmitLctrl(ctx[AsmContext], index) {
	assert(index >= 0 && index <= 8);
	return AsmEmitInstruction(ctx, OP_LCTRL, index);
}

stock AsmError:AsmEmitLeq(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_LEQ);
}

stock AsmError:AsmEmitLess(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_LESS);
}

stock AsmError:AsmEmitLidx(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_LIDX);
}

stock AsmError:AsmEmitLidxB(ctx[AsmContext], shift) {
	return AsmEmitInstruction(ctx, OP_LIDX_B, shift);
}

stock AsmError:AsmEmitLoadAlt(ctx[AsmContext], address) {
	return AsmEmitInstruction(ctx, OP_LOAD_ALT, address);
}

stock AsmError:AsmEmitLoadPri(ctx[AsmContext], address) {
	return AsmEmitInstruction(ctx, OP_LOAD_PRI, address);
}

stock AsmError:AsmEmitLoad(ctx[AsmContext], address) {
	return AsmEmitInstruction(ctx, OP_LOAD_ALT, address);
}

stock AsmError:AsmEmitLoadI(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_LOAD_I);
}

stock AsmError:AsmEmitLoadSAlt(ctx[AsmContext], offset) {
	return AsmEmitInstruction(ctx, OP_LOAD_S_ALT, offset);
}

stock AsmError:AsmEmitLoadSPri(ctx[AsmContext], offset) {
	return AsmEmitInstruction(ctx, OP_LOAD_S_PRI, offset);
}

stock AsmError:AsmEmitLodbI(ctx[AsmContext], nbytes) {
	assert(nbytes == 1 || nbytes == 2 || nbytes == 4);
	return AsmEmitInstruction(ctx, OP_LODB_I, nbytes);
}

stock AsmError:AsmEmitLrefAlt(ctx[AsmContext], address) {
	return AsmEmitInstruction(ctx, OP_LREF_ALT, address);
}

stock AsmError:AsmEmitLrefPri(ctx[AsmContext], address) {
	return AsmEmitInstruction(ctx, OP_LREF_PRI, address);
}

stock AsmError:AsmEmitLrefSAlt(ctx[AsmContext], offset) {
	return AsmEmitInstruction(ctx, OP_LREF_S_ALT, offset);
}

stock AsmError:AsmEmitLrefSPri(ctx[AsmContext], offset) {
	return AsmEmitInstruction(ctx, OP_LREF_S_PRI, offset);
}

stock AsmError:AsmEmitMoveAlt(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_MOVE_ALT);
}

stock AsmError:AsmEmitMovePri(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_MOVE_PRI);
}

stock AsmError:AsmEmitMovs(ctx[AsmContext], nbytes) {
	return AsmEmitInstruction(ctx, OP_MOVS, nbytes);
}

stock AsmError:AsmEmitNeg(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_NEG);
}

stock AsmError:AsmEmitNeq(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_NEQ);
}

stock AsmError:AsmEmitNop(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_NOP);
}

stock AsmError:AsmEmitNot(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_NOT);
}

stock AsmError:AsmEmitOr(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_OR);
}

stock AsmError:AsmEmitPopAlt(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_POP_ALT);
}

stock AsmError:AsmEmitPopPri(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_POP_PRI);
}

stock AsmError:AsmEmitProc(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_PROC);
}

stock AsmError:AsmEmitPushAdr(ctx[AsmContext], offset) {
	return AsmEmitInstruction(ctx, OP_PUSH_ADR, offset);
}

stock AsmError:AsmEmitPushAlt(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_PUSH_ALT);
}

stock AsmError:AsmEmitPushC(ctx[AsmContext], value) {
	return AsmEmitInstruction(ctx, OP_PUSH_C, value);
}

stock AsmError:AsmEmitPushPri(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_PUSH_PRI);
}

stock AsmError:AsmEmitPush(ctx[AsmContext], address) {
	return AsmEmitInstruction(ctx, OP_PUSH, address);
}

stock AsmError:AsmEmitPushS(ctx[AsmContext], offset) {
	return AsmEmitInstruction(ctx, OP_PUSH_S, offset);
}

stock AsmError:AsmEmitRet(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_RET);
}

stock AsmError:AsmEmitRetn(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_RETN);
}

stock AsmError:AsmEmitSctrl(ctx[AsmContext], index) {
	assert(index == 2 || 4 <= index <= 6 || index == 8);
	return AsmEmitInstruction(ctx, OP_SCTRL, index);
}

stock AsmError:AsmEmitSdiv(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_SDIV);
}

stock AsmError:AsmEmitSdivAlt(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_SDIV_ALT);
}

stock AsmError:AsmEmitSgeq(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_SGEQ);
}

stock AsmError:AsmEmitSgrtr(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_SGRTR);
}

stock AsmError:AsmEmitShl(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_SHL);
}

stock AsmError:AsmEmitShlCAlt(ctx[AsmContext], shift) {
	return AsmEmitInstruction(ctx, OP_SHL_C_PRI, shift);
}

stock AsmError:AsmEmitShlCPri(ctx[AsmContext], shift) {
	return AsmEmitInstruction(ctx, OP_SHL_C_PRI, shift);
}

stock AsmError:AsmEmitShrCAlt(ctx[AsmContext], shift) {
	return AsmEmitInstruction(ctx, OP_SHR_C_PRI, shift);
}

stock AsmError:AsmEmitShrCPri(ctx[AsmContext], shift) {
	return AsmEmitInstruction(ctx, OP_SHR_C_PRI, shift);
}

stock AsmError:AsmEmitShr(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_SHR);
}

stock AsmError:AsmEmitSignAlt(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_SIGN_ALT);
}

stock AsmError:AsmEmitSignPri(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_SIGN_PRI);
}

stock AsmError:AsmEmitSleq(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_SLEQ);
}

stock AsmError:AsmEmitSless(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_SLESS);
}

stock AsmError:AsmEmitSmul(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_SMUL);
}

stock AsmError:AsmEmitSmulC(ctx[AsmContext], value) {
	return AsmEmitInstruction(ctx, OP_SMUL_C, value);
}

stock AsmError:AsmEmitSshr(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_SSHR);
}

stock AsmError:AsmEmitSrefAlt(ctx[AsmContext], address) {
	return AsmEmitInstruction(ctx, OP_SREF_ALT, address);
}

stock AsmError:AsmEmitSrefPri(ctx[AsmContext], address) {
	return AsmEmitInstruction(ctx, OP_SREF_PRI, address);
}

stock AsmError:AsmEmitSrefSAlt(ctx[AsmContext], offset) {
	return AsmEmitInstruction(ctx, OP_SREF_S_ALT, offset);
}

stock AsmError:AsmEmitSrefSPri(ctx[AsmContext], offset) {
	return AsmEmitInstruction(ctx, OP_SREF_S_PRI, offset);
}

stock AsmError:AsmEmitStack(ctx[AsmContext], nbytes) {
	return AsmEmitInstruction(ctx, OP_STACK, nbytes);
}

stock AsmError:AsmEmitStorAlt(ctx[AsmContext], address) {
	return AsmEmitInstruction(ctx, OP_STOR_ALT, address);
}

stock AsmError:AsmEmitStorPri(ctx[AsmContext], address) {
	return AsmEmitInstruction(ctx, OP_STOR_PRI, address);
}

stock AsmError:AsmEmitStorI(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_STOR_I);
}

stock AsmError:AsmEmitStorSAlt(ctx[AsmContext], offset) {
	return AsmEmitInstruction(ctx, OP_STOR_S_ALT, offset);
}

stock AsmError:AsmEmitStorSPri(ctx[AsmContext], offset) {
	return AsmEmitInstruction(ctx, OP_STOR_S_PRI, offset);
}

stock AsmError:AsmEmitStrbI(ctx[AsmContext], nbytes) {
	assert(nbytes == 1 || nbytes == 2 || nbytes == 4);
	return AsmEmitInstruction(ctx, OP_STRB_I, nbytes);
}

stock AsmError:AsmEmitSub(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_SUB);
}

stock AsmError:AsmEmitSubAlt(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_SUB_ALT);
}

stock AsmError:AsmEmitSwapAlt(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_SWAP_ALT);
}

stock AsmError:AsmEmitSwapPri(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_SWAP_PRI);
}

stock AsmError:AsmEmitSysreqC(ctx[AsmContext], index) {
	return AsmEmitInstruction(ctx, OP_SYSREQ_C, index);
}

stock AsmError:AsmEmitSysreqD(ctx[AsmContext], address) {
	return AsmEmitInstruction(ctx, OP_SYSREQ_D, address);
}

stock AsmError:AsmEmitSysreqPri(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_SYSREQ_PRI);
}

stock AsmError:AsmEmitUdiv(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_UDIV);
}

stock AsmError:AsmEmitUdivAlt(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_UDIV_ALT);
}

stock AsmError:AsmEmitUmul(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_UMUL);
}

stock AsmError:AsmEmitXchg(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_XCHG);
}

stock AsmError:AsmEmitXor(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_XOR);
}

stock AsmError:AsmEmitZero(ctx[AsmContext], address) {
	return AsmEmitInstruction(ctx, OP_ZERO, address);
}

stock AsmError:AsmEmitZeroAlt(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_ZERO_ALT);
}

stock AsmError:AsmEmitZeroPri(ctx[AsmContext]) {
	return AsmEmitInstruction(ctx, OP_ZERO_PRI);
}

stock AsmError:AsmEmitZeroS(ctx[AsmContext], offset) {
	return AsmEmitInstruction(ctx, OP_ZERO_S, offset);
}



stock AsmError:AsmEmitSysreq(ctx[AsmContext], const name[]) {
	return AsmEmitSysreqC(ctx, GetNativeIndexFromName(name));
}

stock AsmError:AsmEmitPopArgs(ctx[AsmContext], n) {
	return AsmEmitStack(ctx, (n + 1) * 4);
}

stock AsmError:AsmEmitPushArg(ctx[AsmContext], n) {
	return AsmEmitPushS(ctx, AsmGetArgOffset(n));
}

stock AsmError:AsmEmitPushNumArgs(ctx[AsmContext], n) {
	return AsmEmitPushC(ctx, 4 * n);
}



stock AsmGetArgOffset(n) {
	return ASM_ARGUMENTS_OFFSET + 4 * n;
}


#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Storage\..\YSI_Internal\y_thirdpartyinclude.inc"
#line 67

#line 77

#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Storage\..\YSI_Internal\..\amx\codescan.inc"
#line 1




















#line 25












































#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Storage\..\YSI_Internal\..\amx\frame_info.inc"
#line 1




















#line 25

#line 29

stock GetCurrentFrame() {
	#emit lctrl 5
	#emit push.pri
	#emit lref.s.pri 0xfffffffc

	#emit stack 4
	#emit retn

	return 0; 
}

stock GetFramePreviousFrame(frm_addr) {
	#emit lref.s.pri frm_addr
	#emit retn

	return 0; 
}

stock GetFrameReturn(frm_addr) {
	#emit load.s.pri frm_addr
	#emit add.c 4

	#emit push.pri
	#emit lref.s.pri 0xfffffffc

	#emit stack 4
	#emit retn

	return 0; 
}

stock SetFramePreviousFrame(frm_addr, addr) {
	#emit load.s.pri frm_addr

	#emit push.pri
	#emit load.s.alt addr
	#emit sref.s.alt 0xfffffffc

	#emit stack 4
	#emit retn
}

stock SetFrameReturn(frm_addr, addr) {
	#emit load.s.pri frm_addr
	#emit add.c 4

	#emit push.pri
	#emit load.s.alt addr
	#emit sref.s.alt 0xfffffffc

	#emit stack 4
	#emit retn
}

stock SetFrameParameterSize(frm_addr, size) {
	#emit load.s.pri frm_addr
	#emit add.c 8

	#emit push.pri
	#emit load.s.pri size
	#emit sref.s.pri 0xfffffffc

	#emit stack 4
	#emit retn
}

stock SetFrameParameterCount(frm_addr, count) {
	return SetFrameParameterSize(frm_add, count << 2);
}

stock GetFrameTotalSize(frm_addr) {
	return GetFrameLocalSize(frm_addr) + GetFrameHeaderSize(frm_addr) + GetFrameParameterSize(frm_addr);
}

stock GetFrameTotalCount(frm_addr) {
	return GetFrameTotalSize(frm_addr) / 4;
}

stock GetFrameNextFrame(frm_addr) {


	new cur_frm = GetCurrentFrame();

	while (cur_frm != 0) {
		new prev_frm = GetFramePreviousFrame(cur_frm);
		if (prev_frm == frm_addr) {
			break;
		}
		cur_frm = prev_frm;
	}

	return cur_frm;
}

stock GetFrameLocalSize(frm_addr) {

	new next_frm = GetFrameNextFrame(frm_addr);


	new frm_bottom = next_frm + GetFrameHeaderSize(next_frm) + GetFrameParameterSize(next_frm);

	return frm_addr - frm_bottom;
}

stock GetFrameLocalCount(frm_addr) {
	return GetFrameLocalSize(frm_addr) / 4;
}

stock GetFrameHeaderSize(frm_addr) {
	#pragma unused frm_addr
	return 12;
}

stock GetFrameHeaderCount(frm_addr) {
	return GetFrameHeaderSize(frm_addr) / 4;
}

stock GetFrameParameterSize(frm_addr) {
	#emit load.s.pri frm_addr
	#emit add.c 8

	#emit push.pri
	#emit lref.s.pri 0xfffffffc

	#emit stack 4
	#emit retn

	return 0; 
}

stock GetFrameParameterCount(frm_addr) {
	return GetFrameParameterSize(frm_addr) / 4;
}

stock GetFrameParameter(frm_addr, param, idx = -1) {
	if (idx == -1) {
		#emit load.s.pri param
		#emit shl.c.pri 2

		#emit load.s.alt frm_addr
		#emit add

		#emit add.c 12

		#emit push.pri
		#emit lref.s.pri 0xfffffffc

		#emit stack 4
		#emit retn
	} else {
		#emit load.s.pri param
		#emit shl.c.pri 2

		#emit load.s.alt frm_addr
		#emit add

		#emit add.c 12

		#emit push.pri
		#emit lref.s.alt 0xfffffffc

		#emit load.s.pri idx
		#emit lidx

		#emit stack 4
		#emit retn
	}

	return 0; 
}

stock GetFrameVariable(frm_addr, param, idx = -1) {
	if (idx == -1) {
		#emit load.s.pri param
		#emit load.s.alt frm_addr
		#emit add

		#emit push.pri
		#emit lref.s.pri 0xfffffffc

		#emit stack 4
		#emit retn
	} else {
		#emit load.s.pri param
		#emit load.s.alt frm_addr
		#emit add

		#emit push.pri
		#emit lref.s.alt 0xfffffffc

		#emit load.s.pri idx
		#emit lidx

		#emit stack 4
		#emit retn
	}

	return 0; 
}

stock GetFrameLocal(frm_addr, param) {
	if (param < 0) {

		#emit load.s.pri param
		#emit load.s.alt frm_addr
		#emit add

		#emit push.pri
		#emit lref.s.pri 0xfffffffc

		#emit stack 4
		#emit retn
	} else {
		#emit load.s.pri param
		#emit shl.c.pri 2

		#emit const.alt 0xfffffffc
		#emit sub.alt

		#emit load.s.alt frm_addr
		#emit add

		#emit push.pri
		#emit lref.s.pri 0xfffffffc

		#emit stack 4
		#emit retn
	}

	return 0; 
}

stock SetFrameParameter(frm_addr, param, value, idx = -1) {
	if (idx == -1) {
		#emit load.s.pri param
		#emit shl.c.pri 2

		#emit load.s.alt frm_addr
		#emit add

		#emit add.c 12

		#emit push.pri
		#emit load.s.pri value
		#emit sref.s.pri 0xfffffffc

		#emit stack 4
		#emit retn
	} else {
		#emit load.s.pri param
		#emit shl.c.pri 2

		#emit load.s.alt frm_addr
		#emit add

		#emit add.c 12

		#emit push.pri
		#emit lref.s.alt 0xfffffffc

		#emit load.s.pri idx
		#emit idxaddr

		#emit load.s.alt value
		#emit xchg
		#emit stor.i

		#emit stack 4
		#emit retn
	}

	return 0; 
}

stock SetFrameVariable(frm_addr, param, value, idx = -1) {
	if (idx == -1) {
		#emit load.s.pri param
		#emit load.s.alt frm_addr
		#emit add

		#emit push.pri
		#emit load.s.pri value
		#emit sref.s.pri 0xfffffffc

		#emit stack 4
		#emit retn
	} else {
		#emit load.s.pri param
		#emit load.s.alt frm_addr
		#emit add

		#emit push.pri
		#emit lref.s.alt 0xfffffffc

		#emit load.s.pri idx
		#emit idxaddr

		#emit load.s.alt value
		#emit xchg
		#emit stor.i

		#emit stack 4
		#emit retn
	}

	return 0; 
}

stock SetFrameLocal(frm_addr, param, value) {
	if (param < 0) {

		#emit load.s.pri param
		#emit load.s.alt frm_addr
		#emit add

		#emit push.pri
		#emit load.s.pri value
		#emit sref.s.pri 0xfffffffc

		#emit stack 4
		#emit retn
	} else {
		#emit load.s.pri param
		#emit shl.c.pri 2

		#emit const.alt 0xfffffffc
		#emit sub.alt

		#emit load.s.alt frm_addr
		#emit add

		#emit push.pri
		#emit load.s.pri value
		#emit sref.s.pri 0xfffffffc

		#emit stack 4
		#emit retn
	}

	return 0; 
}

static stock GetCallerFrame() {
	#emit lctrl 5

	#emit push.pri
	#emit lref.s.pri 0xfffffffc

	#emit push.pri
	#emit lref.s.pri 0xfffffff8

	#emit stack 8
	#emit retn

	return 0; 
}

stock GetCurrentFramePreviousFrame() {
	return GetFramePreviousFrame(GetCallerFrame());
}

stock GetCurrentFrameReturn() {
	return GetFrameReturn(GetCallerFrame());
}

stock GetCurrentFrameTotalSize() {
	return GetFrameTotalSize(GetCallerFrame());
}

stock GetCurrentFrameTotalCount() {
	return GetFrameTotalCount(GetCallerFrame());
}

stock GetCurrentFrameLocalSize() {
	return GetFrameLocalSize(GetCallerFrame());
}

stock GetCurrentFrameLocalCount() {
	return GetFrameLocalCount(GetCallerFrame());
}

stock GetCurrentFrameHeaderSize() {
	return GetFrameHeaderSize(GetCallerFrame());
}

stock GetCurrentFrameHeaderCount() {
	return GetFrameHeaderCount(GetCallerFrame());
}

stock GetCurrentFrameParameterSize() {
	return GetFrameParameterSize(GetCallerFrame());
}

stock GetCurrentFrameParameter(param, idx = -1) {
	return GetFrameParameter(GetCallerFrame(), param, idx);
}

stock GetCurrentFrameLocal(param) {
	return GetFrameLocal(GetCallerFrame(), param);
}

stock GetCurrentFrameParameterCount() {
	return GetFrameParameterCount(GetCallerFrame());
}

stock SetCurrentFrameReturn(addr) {
	SetFrameReturn(GetCallerFrame(), addr);
}

stock SetCurrentFramePreviousFrame(addr) {
	SetFramePreviousFrame(GetCallerFrame(), addr);
}

stock SetCurrentParameterSize(size) {
	SetFrameParameterSize(GetCallerFrame(), size);
}

stock SetCurrentParameterCount(count) {
	SetFrameParameterCount(GetCallerFrame(), count);
}

stock GetFrameFunction(frm_addr) {

	new prev_frm = GetFramePreviousFrame(frm_addr);

	new amxhdr[AMX_HDR];
	GetAmxHeader(amxhdr);

	if (prev_frm == 0) {

		new call_addr = GetFrameReturn(GetFrameNextFrame(frm_addr));


		new highest_found = 0;
		new defsize = amxhdr[AMX_HDR_DEFSIZE];
		new num_publics = (amxhdr[AMX_HDR_NATIVES] - amxhdr[AMX_HDR_PUBLICS]) / defsize;
		new off = amxhdr[AMX_HDR_PUBLICS] - amxhdr[AMX_HDR_DAT];

		for (new i = 0; i != num_publics; ++i) {
			new addr = ReadAmxMemory(off);
			off += defsize;

			if (highest_found < addr < call_addr) {
				highest_found = addr;
			}
		}

		if (highest_found < amxhdr[AMX_HDR_CIP] < call_addr) {
			highest_found = amxhdr[AMX_HDR_CIP];
		}


		return highest_found;
	} else {

		new ret_addr = (GetFrameReturn(frm_addr) - 8) + (amxhdr[AMX_HDR_COD] - amxhdr[AMX_HDR_DAT]);

		new Opcode:opcode = UnrelocateOpcode(Opcode:ReadAmxMemory(ret_addr));

		if (opcode == OP_CALL) {

			return ReadAmxMemory(ret_addr + 4) - amxhdr[AMX_HDR_COD] - GetAmxBaseAddress();

		} else if (opcode == OP_SCTRL) {

			opcode = UnrelocateOpcode(Opcode:ReadAmxMemory(ret_addr - 8));

			if (opcode == OP_LOAD_PRI) {
				return ReadAmxMemory(ReadAmxMemory(ret_addr - 4));
			} else if (opcode == OP_LOAD_S_PRI) {
				return GetFrameVariable(prev_frm, ReadAmxMemory(ret_addr - 4));
			} else if (opcode == OP_CONST_PRI) {
				return ReadAmxMemory(ret_addr - 4);
			}
		}


		new end = amxhdr[AMX_HDR_COD] - amxhdr[AMX_HDR_DAT] + 8; 
		ret_addr = GetFrameReturn(GetFrameNextFrame(frm_addr)) + end;

		opcode = RelocateOpcode(OP_RETN);
		new Opcode:proc = RelocateOpcode(OP_PROC);

		while (ret_addr >= end) {
			if (Opcode:ReadAmxMemory(ret_addr) == proc) {
				if (ret_addr == end || Opcode:ReadAmxMemory(ret_addr - 4) == opcode) {

					return ret_addr;
				}
			}
			ret_addr -= 4;
		}
	}


	return 0;
}

stock GetCurrentFrameFunction() {

	return GetFrameFunction(GetCallerFrame());
}


#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Storage\..\YSI_Internal\..\amx\codescan.inc"
#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Storage\..\YSI_Internal\..\amx\disasm.inc"
#line 1




















#line 25

#line 27

#line 32

#line 36

enum DisasmInsnInfo {
	DisasmInsnInfo_name[15],
	DisasmInsnInfo_num_opers,
	bool:DisasmInsnInfo_needs_reloc
}

enum DisasmContext {
	DisasmContext_start_ip,
	DisasmContext_end_ip,
	DisasmContext_nip,
	DisasmContext_cip,
	Opcode:DisasmContext_opcode,
	DisasmContext_insn[DisasmInsnInfo]
}

enum DisasmResult {
	DISASM_DONE = 0,
	DISASM_NOP  = 1,
	DISASM_OK   = 2
}

static stock const insn_table[][DisasmInsnInfo] = {
	{ "none",        0, false },
	{ "load.pri",    1, false },
	{ "load.alt",    1, false },
	{ "load.s.pri",  1, false },
	{ "load.s.alt",  1, false },
	{ "lref.pri",    1, false },
	{ "lref.alt",    1, false },
	{ "lref.s.pri",  1, false },
	{ "lref.s.alt",  1, false },
	{ "load.i",      0, false },
	{ "lodb.i",      1, false },
	{ "const.pri",   1, false },
	{ "const.alt",   1, false },
	{ "addr.pri",    1, false },
	{ "addr.alt",    1, false },
	{ "stor.pri",    1, false },
	{ "stor.alt",    1, false },
	{ "stor.s.pri",  1, false },
	{ "stor.s.alt",  1, false },
	{ "sref.pri",    1, false },
	{ "sref.alt",    1, false },
	{ "sref.s.pri",  1, false },
	{ "sref.s.alt",  1, false },
	{ "stor.i",      0, false },
	{ "strb.i",      1, false },
	{ "lidx",        0, false },
	{ "lidx.b",      1, false },
	{ "idxaddr",     0, false },
	{ "idxaddr.b",   1, false },
	{ "align.pri",   1, false },
	{ "align.alt",   1, false },
	{ "lctrl",       1, false },
	{ "sctrl",       1, false },
	{ "move.pri",    0, false },
	{ "move.alt",    0, false },
	{ "xchg",        0, false },
	{ "push.pri",    0, false },
	{ "push.alt",    0, false },
	{ "push.r",      1, false },
	{ "push.c",      1, false },
	{ "push",        1, false },
	{ "push.s",      1, false },
	{ "pop.pri",     0, false },
	{ "pop.alt",     0, false },
	{ "stack",       1, false },
	{ "heap",        1, false },
	{ "proc",        0, false },
	{ "ret",         0, false },
	{ "retn",        0, false },
	{ "call",        1, true  },
	{ "call.pri",    0, false },
	{ "jump",        1, true  },
	{ "jrel",        1, false },
	{ "jzer",        1, true  },
	{ "jnz",         1, true  },
	{ "jeq",         1, true  },
	{ "jneq",        1, true  },
	{ "jless",       1, true  },
	{ "jleq",        1, true  },
	{ "jgrtr",       1, true  },
	{ "jgeq",        1, true  },
	{ "jsless",      1, true  },
	{ "jsleq",       1, true  },
	{ "jsgrtr",      1, true  },
	{ "jsgeq",       1, true  },
	{ "shl",         0, false },
	{ "shr",         0, false },
	{ "sshr",        0, false },
	{ "shl.c.pri",   1, false },
	{ "shl.c.alt",   1, false },
	{ "shr.c.pri",   1, false },
	{ "shr.c.alt",   1, false },
	{ "smul",        0, false },
	{ "sdiv",        0, false },
	{ "sdiv.alt",    0, false },
	{ "umul",        0, false },
	{ "udiv",        0, false },
	{ "udiv.alt",    0, false },
	{ "add",         0, false },
	{ "sub",         0, false },
	{ "sub.alt",     0, false },
	{ "and",         0, false },
	{ "or",          0, false },
	{ "xort",        0, false },
	{ "not",         0, false },
	{ "neg",         0, false },
	{ "invert",      0, false },
	{ "add.c",       1, false },
	{ "smul.c",      1, false },
	{ "zero.pri",    0, false },
	{ "zero.alt",    0, false },
	{ "zero",        1, false },
	{ "zero.s",      1, false },
	{ "sign.pri",    0, false },
	{ "sign.alt",    0, false },
	{ "eq",          0, false },
	{ "neq",         0, false },
	{ "less",        0, false },
	{ "leq",         0, false },
	{ "grtr",        0, false },
	{ "geq",         0, false },
	{ "sless",       0, false },
	{ "sleq",        0, false },
	{ "sgrtr",       0, false },
	{ "sgeq",        0, false },
	{ "eq.c.pri",    1, false },
	{ "eq.c.alt",    1, false },
	{ "inc.pri",     0, false },
	{ "inc.alt",     0, false },
	{ "inc",         1, false },
	{ "inc.s",       1, false },
	{ "inc.i",       0, false },
	{ "dec.pri",     0, false },
	{ "dec.alt",     0, false },
	{ "dec",         1, false },
	{ "dec.s",       1, false },
	{ "dec.i",       0, false },
	{ "movs",        1, false },
	{ "cmps",        1, false },
	{ "fill",        1, false },
	{ "halt",        1, false },
	{ "bounds",      1, false },
	{ "sysreq.pri",  1, false },
	{ "sysreq.c",    1, false },
	{ "file",       -1, false }, 
	{ "line",       -1, false }, 
	{ "symbol",     -1, false }, 
	{ "srange",     -1, false }, 
	{ "jump.pri",    0, false },
	{ "switch",      1, true },
	{ "casetbl",    -1, true },
	{ "swap.pri",    0, false },
	{ "swap.alt",    0, false },
	{ "push.adr",    1, false },
	{ "nop",         0, false },
	{ "sysreq.d",    1, false },
	{ "symtag",      1, false }, 
	{ "break",       0, false }
};

static stock gCodBase;

stock DisasmInit(ctx[DisasmContext], start = 0, end = 0) {
	new hdr[AMX_HDR];
	GetAmxHeader(hdr);

	gCodBase = GetAmxBaseAddress() + hdr[AMX_HDR_COD];

	new dat = hdr[AMX_HDR_DAT];
	new cod = hdr[AMX_HDR_COD];

	new code_base = cod - dat;

	start += code_base;

	ctx[DisasmContext_nip] = start;
	ctx[DisasmContext_cip] = start;

	ctx[DisasmContext_start_ip] = start;
	if (end != 0) {
		ctx[DisasmContext_end_ip] = code_base + end;
	} else {





		ctx[DisasmContext_end_ip] = 0;
	}
}

stock bool:DisasmDecodeInsn(ctx[DisasmContext]) {
	new ip = ctx[DisasmContext_nip];
	if (ip >= 0) {
		return false;
	}

	new Opcode:opcode = UnrelocateOpcode(Opcode:ReadAmxMemory(ip));
	if (opcode <= OP_NONE || _:opcode >= NUM_OPCODES) {
		return false;
	}

	ctx[DisasmContext_cip] = ip;
	ctx[DisasmContext_opcode] = opcode;
	ctx[DisasmContext_insn] = insn_table[_:opcode];

	ip += 4;

	if (opcode == OP_CASETBL) {
		new n = ReadAmxMemory(ip);
		ip += 4;
		ip += (2 * n + 1) * 4;
		ctx[DisasmContext_insn][DisasmInsnInfo_num_opers] = n;
	} else {
		ip += 4 * insn_table[_:opcode][DisasmInsnInfo_num_opers];
	}

	ctx[DisasmContext_nip] = ip;
	return true;
}

stock DisasmResult:DisasmNext(ctx[DisasmContext]) {






	if (ctx[DisasmContext_nip] >= ctx[DisasmContext_end_ip]) {
		return DISASM_DONE;
	} else if (DisasmDecodeInsn(ctx)) {
		return DISASM_OK;
	} else {
		ctx[DisasmContext_cip] = ctx[DisasmContext_nip],
		ctx[DisasmContext_nip] += 4,
		ctx[DisasmContext_opcode] = Opcode:NUM_OPCODES;
		return DISASM_NOP;
	}
}

stock Opcode:DisasmNextInsn(ctx[DisasmContext]) {
	if (DisasmDecodeInsn(ctx)) {
		return ctx[DisasmContext_opcode];
	}
	return OP_NONE;
}

stock Opcode:DisasmGetOpcode(ctx[DisasmContext]) {
	return ctx[DisasmContext_opcode];
}

stock DisasmGetOperand(ctx[DisasmContext], index = 0) {
	return ReadAmxMemory(ctx[DisasmContext_cip] + (index + 1) * 4);
}

stock DisasmGetNumOperands(ctx[DisasmContext]) {
	return ctx[DisasmContext_insn][DisasmInsnInfo_num_opers];
}

stock bool:DisasmNeedReloc(ctx[DisasmContext]) {
	return ctx[DisasmContext_insn][DisasmInsnInfo_needs_reloc];
}

stock DisasmGetNextIp(ctx[DisasmContext]) {
	return ctx[DisasmContext_nip];
}

stock DisasmGetCurIp(ctx[DisasmContext]) {
	return ctx[DisasmContext_cip];
}

stock DisasmGetRemaining(ctx[DisasmContext]) {
	return ctx[DisasmContext_end_ip] - ctx[DisasmContext_nip];
}

stock DisasmGetInsnName(ctx[DisasmContext], name[], size = sizeof(name)) {
	name[0] = '\0';
	strcat(name, ctx[DisasmContext_insn][DisasmInsnInfo_name], size);
}

stock DisasmGetOperandReloc(ctx[DisasmContext], index = 0) {
	new param = DisasmGetOperand(ctx, index);

























	if ((ctx[DisasmContext_opcode] == OP_CASETBL) ? (index & 1) : _:DisasmNeedReloc(ctx)) {
		return param - gCodBase;
	} else {
		return param;
	}
}

static stock ToHexStr(x) {
	new s[11];
	new i = 0;
	new j = 0;

	while (i < sizeof(s) && j < 8) {
		new n = x >> (7 - j) * 4 & 0xF;
		switch (n) {
			case 0x0..0x9:
				s[i] = n + '0';
			case 0xA..0xF:
				s[i] = n + 'a' - 0xA;
		}
		i++;
		j++;
	}

	return s;
}

static stock bool:IsPrintableAscii(c) {
	return 32 <= c <= 126;
}

static stock ToPrintableAscii(c) {
	return IsPrintableAscii(c) ? c : ' ';
}

stock DisasmWriteCode(File:file) {
	new ctx[DisasmContext];
	DisasmInit(ctx);

	new hdr[AMX_HDR];
	GetAmxHeader(hdr);

	new dat = hdr[AMX_HDR_DAT];
	new cod = hdr[AMX_HDR_COD];

	fwrite(file, "; CODE\n\n");

	while (DisasmGetNextIp(ctx) < ctx[DisasmContext_end_ip])
	{
		if (!DisasmDecodeInsn(ctx)) {
			new cip = DisasmGetNextIp(ctx);
			ctx[DisasmContext_nip] += 4;
			fwrite(file, ToHexStr(cip + dat - cod));
			fwrite(file, " ???? ");
			fwrite(file, ToHexStr(ReadAmxMemory(cip)));
			fwrite(file, "\n");
			continue;
		}

		new cip = DisasmGetCurIp(ctx);
		new Opcode:opcode = DisasmGetOpcode(ctx);

		if (opcode == OP_PROC) {
			fwrite(file, "\n");
		}

		new insn_name[15];
		DisasmGetInsnName(ctx, insn_name);
		fwrite(file, ToHexStr(cip + dat - cod));
		fwrite(file, " ");
		fwrite(file, insn_name);
		fwrite(file, " ");

		switch (opcode) {
			case OP_PROC: {
				new name[32];
				new address = cip + dat - cod;
				if (address == hdr[AMX_HDR_CIP]) {
					strcat(name, "main");
				} else {
					new index = GetPublicIndexFromAddress(address);
					if (index >= 0) {
						GetPublicNameFromIndex(index, name);
					}
				}
				if (strlen(name) != 0) {
					fwrite(file, "; ");
					fwrite(file, name);
				}
			}
			case OP_CASETBL: {
				new num = DisasmGetNumOperands(ctx);
				fwrite(file, ToHexStr(num));
				fwrite(file, " ");
				new rel_addr = DisasmGetOperand(ctx, 1) - gCodBase;
				fwrite(file, ToHexStr(rel_addr));
				for (new i = 1; i <= num; i++) {
					fwrite(file, "\n         case ");
					new val = DisasmGetOperand(ctx, i * 2);
					fwrite(file, ToHexStr(val));
					fwrite(file, " ");
					rel_addr = DisasmGetOperand(ctx, i * 2 + 1) - gCodBase;
					fwrite(file, ToHexStr(rel_addr));
				}
			}
			case OP_CALL: {
				new name[32];
				new address = DisasmGetOperand(ctx) - gCodBase;
				if (address == hdr[AMX_HDR_CIP]) {
					strcat(name, "main");
				} else {
					new index = GetPublicIndexFromAddress(address);
					if (index >= 0) {
						GetPublicNameFromIndex(index, name);
					}
				}
				fwrite(file, ToHexStr(address));
				if (strlen(name) > 0) {
					fwrite(file, "; ");
					fwrite(file, name);
				}
			}
			case OP_SYSREQ_C, OP_SYSREQ_D: {
				new name[100];
				new address = DisasmGetOperand(ctx);
				if (opcode == OP_SYSREQ_C) {
					new index = DisasmGetOperand(ctx);
					GetNativeNameFromIndex(index, name);
				} else {
					new index = GetNativeIndexFromAddress(address);
					if (index >= 0) {
						GetNativeNameFromIndex(index, name);
					}
				}
				fwrite(file, ToHexStr(address));
				if (strlen(name) > 0) {
					fwrite(file, "; ");
					fwrite(file, name);
				}
			}
			default: {
				new n = DisasmGetNumOperands(ctx);
				for (new i = 0; i < n; i++) {
					new operand = DisasmGetOperandReloc(ctx, i);
					fwrite(file, ToHexStr(operand));
				}
			}
		}

		fwrite(file, "\n");
	}
}

stock DisasmWriteDataRowChar(File:file, start, num, max) {
	new cur = start;
	new end = start + num*4;

	while (cur < max) {
		new p[4 char + 1];
		p[0] = ReadAmxMemory(cur);

		new u[4 + 1];
		u[0] = ToPrintableAscii(p{0});
		u[1] = ToPrintableAscii(p{1});
		u[2] = ToPrintableAscii(p{2});
		u[3] = ToPrintableAscii(p{3});
		u[4] = '\0';

		if (cur < end) {
			fwrite(file, u);
		} else {
			fwrite(file, " ");
		}
		cur += 4;
	}
}

stock DisasmWriteDataRowHex(File:file, start, num, max) {
	new cur = start;
	new end = start + num*4;

	while (cur < max) {
		if (cur < end) {
			fwrite(file, ToHexStr(ReadAmxMemory(cur)));
		} else {
			fwrite(file, "        ");
		}
		fwrite(file, " ");
		cur += 4;
	}
}

stock DisasmWriteData(File:file) {
	fwrite(file, "\n\n; DATA\n");

	new hdr[AMX_HDR];
	GetAmxHeader(hdr);

	new dat = hdr[AMX_HDR_DAT];
	new hea = hdr[AMX_HDR_HEA];
	new data_end = hea - dat;

	for (new i = 0; i < data_end; i += 0x10) {
		fwrite(file, ToHexStr(i));
		fwrite(file, "  ");
		DisasmWriteDataRowHex(file, i, 4, min(i + 0x10, data_end));
		fwrite(file, " ");
		DisasmWriteDataRowChar(file, i, 4, min(i + 0x10, data_end));
		fwrite(file, "\n");
	}
}

stock DisasmWriteFile(File:file) {
	DisasmWriteCode(file);
	DisasmWriteData(file);
}

stock bool:DisasmWrite(const filename[]) {
	new File:file = fopen(filename, io_write);
	if (file) {
		DisasmWriteFile(file);
		fclose(file);
		return true;
	}
	return false;
}

stock DisasmDump(const filename[]) {
	DisasmWrite(filename);
}


#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Storage\..\YSI_Internal\..\amx\codescan.inc"
#line 72

#line 80

#line 87

#line 94




#line 105






















#line 129

#line 134

#line 136

#line 140












#line 153

#line 157

#line 163

#line 167

#line 171



enum CodeScanner {
	CodeScanMatch_func,     
	CodeScanMatch_size,     
	CodeScanMatch_type,     
	CodeScanMatch_heap,     
	CodeScanMatch_stack,    
	CodeScanMatch_params,   
	CodeScanMatch_cip,      
	CodeScanMatch_holes[((32) * 2)], 
	CodeScanMatch_name[32 char],
	CodeScanner_first,
	CodeScanner_minn,
	CodeScanner_jump_switch[(32)], 
	CodeScanner_jump_target[(32)], 
	CodeScanner_jump_stack [(32)], 
	CodeScanner_jump_heap  [(32)], 
	CodeScanner_state,
	CodeScanner_param
}

enum CodeScanMatcher {
	CodeScanMatcher_func,      
	CodeScanMatcher_user_data, 
	CodeScanMatcher_code[((32) * 4)], 
	CodeScanMatcher_len,
	CodeScanMatcher_offset[(2)], 
	CodeScanMatcher_start[(2)],
	CodeScanMatcher_holeidx[(2)],
	CodeScanMatcher_holes[(2) * ((32) * 2)],
	CodeScanMatcher_next,      
	CodeScanMatcher_flags      
}

#line 211




#line 216

stock
	O@V_ = 0,
	gCodeScanCallback_match[CodeScanner];

static stock
	gHdr[AMX_HDR],
	gBase,
	gDat;

stock bool:O@A_() {


	new ctx[DisasmContext];
	DisasmInit(ctx, GetCurrentFrameReturn());
	while (DisasmNext(ctx)) {
		if (DisasmGetOpcode(ctx) == OP_CALL) {

			O@V_ = DisasmGetOperandReloc(ctx);
			return false;
		}
	}


	return false;
}

static stock bool:CodeScanCheckJumpTarget(cip, deloc, &stk, &hea, jumpTargets[CodeScanner], num = (32))
{



	new
		minn = jumpTargets[CodeScanner_minn],
		sip,
		count;
	while (num-- > minn) {
		if (jumpTargets[CodeScanner_jump_target][num]) {
			if ((sip = jumpTargets[CodeScanner_jump_switch][num])) {
				count = ReadAmxMemory(sip) + 1,
				sip += (cellbits / 8);
				while (count--) {
					if (ReadAmxMemory(sip) == deloc) {
						return
							--jumpTargets[CodeScanner_jump_target][num],
							stk = jumpTargets[CodeScanner_jump_stack][num],
							hea = jumpTargets[CodeScanner_jump_heap][num],
							true;
					}
					sip += 2 * (cellbits / 8);
				}
			} else if (jumpTargets[CodeScanner_jump_target][num] == cip) {
				return
					jumpTargets[CodeScanner_jump_target][num] = 0,
					stk = jumpTargets[CodeScanner_jump_stack][num],
					hea = jumpTargets[CodeScanner_jump_heap][num],
					true;
			}
		}
	}
	return false;
}

static stock CodeScanResetJumpTargets(jumpTargets[CodeScanner], num = (32))
{
	jumpTargets[CodeScanner_minn] = num;
	while (num--) {
		jumpTargets[CodeScanner_jump_target][num] = 0;
	}
}

static stock CodeScanAddJumpTarget(cip, stk, hea, jumpTargets[CodeScanner], num = (32))
{
	while (num--) {

		if (jumpTargets[CodeScanner_jump_target][num] == cip) {
			return;
		} else if (!jumpTargets[CodeScanner_jump_target][num]) {
			jumpTargets[CodeScanner_jump_switch][num] = 0;
			jumpTargets[CodeScanner_jump_target][num] = cip;
			jumpTargets[CodeScanner_jump_stack][num] = stk;
			jumpTargets[CodeScanner_jump_heap][num] = hea;
			jumpTargets[CodeScanner_minn] = min(jumpTargets[CodeScanner_minn], num);
			return;
		}
	}
}

static stock CodeScanAddSwitchTarget(dctx[DisasmContext], stk, hea, jumpTargets[CodeScanner], num = (32))
{
	new
		sip = DisasmGetOperand(dctx) - gBase,
		codepos = sip + gHdr[AMX_HDR_DAT] - gHdr[AMX_HDR_COD];
	if (codepos < 0 || codepos > gHdr[AMX_HDR_DAT] || UnrelocateOpcode(Opcode:ReadAmxMemory(sip)) != OP_CASETBL) {


		return;
	}
	while (num--) {

		if (!jumpTargets[CodeScanner_jump_target][num]) {
			jumpTargets[CodeScanner_jump_switch][num] = sip + (cellbits / 8),
			jumpTargets[CodeScanner_jump_target][num] = ReadAmxMemory(sip + (cellbits / 8)) + 1,
			jumpTargets[CodeScanner_jump_stack][num] = stk,
			jumpTargets[CodeScanner_jump_heap][num] = hea,
			jumpTargets[CodeScanner_minn] = min(jumpTargets[CodeScanner_minn], num);
			return;
		}
	}
}

static stock CodeScanReset(cs[CodeScanMatcher], &next) {
	static
		lReset[(2)];
	next = cs[CodeScanMatcher_next],
	cs[CodeScanMatcher_offset] = lReset,
	cs[CodeScanMatcher_holeidx] = lReset;
	if (!cs[CodeScanMatcher_func]) {
		cs[CodeScanMatcher_len] = 0;
	}
}

stock CodeScanAddMatcher(scanner[CodeScanner], searcher[CodeScanMatcher]) {
	searcher[CodeScanMatcher_next] = scanner[CodeScanner_first],
	scanner[CodeScanner_first] = ref(searcher);
}

stock CodeScanMatcherInit_(searcher[CodeScanMatcher], address, flags = (2) | (32) | (4) | (16)) {









	searcher[CodeScanMatcher_func] = address,
	searcher[CodeScanMatcher_flags] = flags & ~(64),
	searcher[CodeScanMatcher_next] = -1,
	searcher[CodeScanMatcher_len] = 0,
	searcher[CodeScanMatcher_user_data] = 0,
	CodeScanReset(searcher, flags);
}

stock CodeScanMatcherData(searcher[CodeScanMatcher], val) {

	searcher[CodeScanMatcher_flags] |= (64),
	searcher[CodeScanMatcher_user_data] = val;
}



#line 371

stock CodeScanMatcherPattern_(searcher[CodeScanMatcher], {Opcode, Float, _}:...) {
	new
		len = numargs() - 1;
	if (len > ((32) * 4)) {
		return;
	}
	searcher[CodeScanMatcher_len] = len;
	for (new i = 0; i != len; ++i) {
		searcher[CodeScanMatcher_code][i] = getarg(i + 1);
	}
}


#line 386

static stock CodeScanDeref(v) {
	static
		lFakeMatcher[CodeScanMatcher];
	#pragma unused v
	#emit load.s.pri 12 
	#emit stor.s.pri 16 
	#emit retn
	return lFakeMatcher; 
}

static stock bool:CodeScanCheck(Opcode:op, dctx[DisasmContext], cs[CodeScanMatcher], fctx[CodeScanner], &next) {

	if (!cs[CodeScanMatcher_len]) {
		return
			next = cs[CodeScanMatcher_next],
			false;
	}
	new
		bool:zero = true,
		off = cs[CodeScanMatcher_flags];
	if (off) {



		switch (op) {
			case OP_NOP: {
				if (off & (2)) {
					return
						next = cs[CodeScanMatcher_next],
						false;
				}
			}
			case OP_BOUNDS: {
				if (off & (32)) {
					return
						next = cs[CodeScanMatcher_next],
						false;
				}
			}
			case OP_BREAK: {
				if (off & (4)) {
					return
						next = cs[CodeScanMatcher_next],
						false;
				}
			}
			case OP_HALT: {
				if (off & (16)) {
					return
						next = cs[CodeScanMatcher_next],
						false;
				}
			}
		}
	}
	new
		cnt = DisasmGetNumOperands(dctx),
		len = cs[CodeScanMatcher_len];
	for (new idx = 0; idx != (2); ++idx) {
		off = cs[CodeScanMatcher_offset][idx];


		if (off) {
		} else if (zero) {

			cs[CodeScanMatcher_start][idx] = DisasmGetCurIp(dctx),
			zero = false;
		} else {
			continue;
		}
		if (cs[CodeScanMatcher_code][off] == ((5))) {
			off += 2;
			if (off == len) {
				return
					memcpy(fctx[CodeScanMatch_holes], cs[CodeScanMatcher_holes], idx * (((32) * 4) / 2), cs[CodeScanMatcher_holeidx][idx] * (cellbits / 8), (((32) * 4) / 2)),
					fctx[CodeScanMatch_cip] = cs[CodeScanMatcher_start][idx],
					fctx[CodeScanMatch_size] = DisasmGetNextIp(dctx) - cs[CodeScanMatcher_start][idx],
					true;
			} else if (cs[CodeScanMatcher_code][off] == ((4)) && Opcode:cs[CodeScanMatcher_code][off + 1] == op) {

				goto CodeScanCheck_pass;
			} else {


				continue;
			}
		}
		if (cs[CodeScanMatcher_code][off] == ((4)) && Opcode:cs[CodeScanMatcher_code][off + 1] == op) {
CodeScanCheck_pass:

			off += 2;
			if ((len - off) / 2 < cnt) {
				goto CodeScanCheck_fail;
			}
			if (cnt) {
				for (new i = 0; i != cnt; ++i) {
					switch (cs[CodeScanMatcher_code][off++]) {




						case ((0)), ((2)): {
							if (cs[CodeScanMatcher_code][off++] != DisasmGetOperandReloc(dctx, i)) {
								goto CodeScanCheck_fail;
							}
						}
						case ((1)): {

							++off,
							cs[CodeScanMatcher_holes][idx * (((32) * 4) / 2) + cs[CodeScanMatcher_holeidx][idx]++] = DisasmGetOperandReloc(dctx, i);
						}
						case ((3)), ((4)), ((5)): {
							goto CodeScanCheck_fail;
						}
					}
				}
			} else if (cs[CodeScanMatcher_code][off] == ((3))) {

				off += 2;
			} else {
				goto CodeScanCheck_fail;
			}
			if (off == len) {

				return
					memcpy(fctx[CodeScanMatch_holes], cs[CodeScanMatcher_holes][idx * (((32) * 4) / 2)], 0, cs[CodeScanMatcher_holeidx][idx] * (cellbits / 8), (((32) * 4) / 2)),
					fctx[CodeScanMatch_cip] = cs[CodeScanMatcher_start][idx],
					fctx[CodeScanMatch_size] = DisasmGetNextIp(dctx) - cs[CodeScanMatcher_start][idx],
					true;
			} else {

				cs[CodeScanMatcher_offset][idx] = off;
				continue;
			}
		}
CodeScanCheck_fail:

		cs[CodeScanMatcher_holeidx][idx] = cs[CodeScanMatcher_offset][idx] = 0;
	}
	return
		next = cs[CodeScanMatcher_next],
		false;
}

static stock bool:CodeScanGetFuncName(addr, name[])
{



	new
		index = GetPublicIndexFromAddress(addr);
	if (index < 0) {
		return
			name[0] = 0,
			false;
	}

	return
		GetPublicNameFromIndex(index, name, 32),
		true;
}

static stock bool:CodeScanStepInternal(dctx[DisasmContext], csState[CodeScanner], &parseState, &parseParam) {




	switch (DisasmNext(dctx)) {
		case DISASM_OK: {
			new
				stk = csState[CodeScanMatch_stack],
				hea = csState[CodeScanMatch_heap],
				cip = DisasmGetCurIp(dctx),
				Opcode:op = DisasmGetOpcode(dctx);


			CodeScanCheckJumpTarget(cip, cip + gBase, stk, hea, csState);
			switch (op) {
				case OP_HALT: {
					if (parseState == 4) {
						csState[CodeScanMatch_type] = (8),
						csState[CodeScanMatch_func] = cip,
						stk = hea = 0,
						CodeScanResetJumpTargets(csState);
					}
				}
				case OP_PROC: {


					csState[CodeScanMatch_type] = (5),
					csState[CodeScanMatch_func] = cip,
					CodeScanResetJumpTargets(csState),
					stk = hea = parseState = 0;
				}
				case OP_LOAD_PRI: {



					if (parseState == 4) {
						csState[CodeScanMatch_type] = (7),
						csState[CodeScanMatch_func] = cip,
						stk = hea = 0,
						CodeScanResetJumpTargets(csState);
					}
				}
				case OP_PUSH_PRI, OP_PUSH_ALT, OP_PUSH_R, OP_PUSH_S, OP_PUSH, OP_PUSH_ADR: {
					if (stk != cellmin) {
						stk += (cellbits / 8);
					}
					parseState = 0;
				}
				case OP_STACK: {

					if (stk != cellmin) {
						stk -= DisasmGetOperand(dctx);
					}
					parseState = 0;
				}
				case OP_HEAP: {
					if (hea != cellmin) {
						hea += DisasmGetOperand(dctx);
					}
					parseState = 0;
				}
				case OP_POP_PRI, OP_POP_ALT: {
					if (stk != cellmin) {
						stk -= (cellbits / 8);
					}
					parseState = 0;
				}
				case OP_CALL, OP_CALL_PRI: {

					if (parseState == 3) {
						stk -= parseParam;
					}
					parseState = 0;
				}
				case OP_PUSH_C: {



					parseParam = DisasmGetOperand(dctx) + (cellbits / 8);
					if (stk != cellmin) {
						stk += (cellbits / 8),
						parseState = 3;
					}
				}









				case OP_LCTRL: {
					if (DisasmGetOperand(dctx) == 5) {
						parseState = 1;
					} else {
						parseState = 0;
					}
				}
				case OP_ADD_C: {
					if (parseState == 1) {
						parseParam = -DisasmGetOperand(dctx),
						parseState = 2;
					} else {
						parseState = 0;
					}
				}
				case OP_SCTRL: {



					switch (DisasmGetOperand(dctx)) {
						case 2: {
							hea = cellmin;
						}
						case 4: {
							switch (parseState) {
								case 1: {
									stk = 0;
								}
								case 2: {
									stk = parseParam;
								}
								default: {
									stk = cellmin;
								}
							}
						}
						case 5: {
							stk = cellmin;
						}
					}
					parseState = 0;
				}
				case OP_JUMP, OP_JZER, OP_JNZ, OP_JEQ, OP_JNEQ, OP_JLESS, OP_JLEQ, OP_JGRTR, OP_JGEQ, OP_JSLESS, OP_JSLEQ, OP_JSGRTR, OP_JSGEQ: {















					parseParam = DisasmGetOperand(dctx) - gBase,
					parseState = 0;
					if (parseParam > cip) {
						CodeScanAddJumpTarget(parseParam, stk, hea, csState);
					}
				}
				case OP_JREL: {

					parseParam = DisasmGetOperand(dctx) + cip,
					parseState = 0;
					if (parseParam > cip) {
						CodeScanAddJumpTarget(parseParam, stk, hea, csState);
					}
				}
				case OP_SWITCH: {

					CodeScanAddSwitchTarget(dctx, stk, hea, csState),
					parseState = 0;
				}
				default: {
					parseState = 0;
				}
			}
			csState[CodeScanMatch_stack] = stk,
			csState[CodeScanMatch_heap] = hea;
		}
		case DISASM_DONE: {
			return false;
		}
		case DISASM_NOP: {
			parseState = 0;
		}
	}
	return true;
}

stock bool:CodeScanStep(dctx[DisasmContext], csState[CodeScanner]) {
	return CodeScanStepInternal(dctx, csState, csState[CodeScanner_state], csState[CodeScanner_param]);
}

static stock bool:CodeScanCall(cs[CodeScanMatcher], csState[CodeScanner]) {



	new
		func = cs[CodeScanMatcher_func];
	if (cs[CodeScanMatcher_flags] & (64)) {
		new
			param = cs[CodeScanMatcher_user_data];
		#emit PUSH.S     param
		#emit PUSH.S     csState
		#emit PUSH.C     8
		#emit LCTRL      6
		#emit ADD.C      36
		#emit LCTRL      8
		#emit PUSH.pri
		#emit LOAD.S.pri func
		#emit SCTRL      6
		#emit STACK      8
		#emit RETN
	} else {
		#emit PUSH.S     csState
		#emit PUSH.C     4
		#emit LCTRL      6
		#emit ADD.C      36
		#emit LCTRL      8
		#emit PUSH.pri
		#emit LOAD.S.pri func
		#emit SCTRL      6
		#emit STACK      4
		#emit RETN
	}

	return false;
}

stock bool:CodeScanRun(csState[CodeScanner]) {
	if (csState[CodeScanner_first] == -1) {
		return true;
	}
	new
		dctx[DisasmContext],
		cur,
		Opcode:op,
		parseState = 4,
		parseParam;
	DisasmInit(dctx);
	for (cur = csState[CodeScanner_first]; cur != -1; CodeScanReset(CodeScanDeref(cur), cur)) { }
	while (CodeScanStepInternal(dctx, csState, parseState, parseParam)) {





		for (cur = csState[CodeScanner_first], op = DisasmGetOpcode(dctx); cur != -1; ) {
			if (CodeScanCheck(op, dctx, CodeScanDeref(cur), csState, cur)) {
				switch (CodeScanCall(CodeScanDeref(cur), csState)) {
					case -1: {


						CodeScanReset(CodeScanDeref(cur), cur);
						continue;
					}
					case 0: {

					}
					default: {

						dctx[DisasmContext_nip] = csState[CodeScanMatch_func];
					}
				}

				for (cur = csState[CodeScanner_first]; cur != -1; CodeScanReset(CodeScanDeref(cur), cur)) { }
				break;
			}
		}
	}
	return true;
}

stock CodeScanInit(scanner[CodeScanner]) {



	GetAmxHeader(gHdr),
	gBase = GetAmxBaseAddress() + gHdr[AMX_HDR_DAT],
	gDat = gHdr[AMX_HDR_COD] - gHdr[AMX_HDR_DAT],
	CodeScanResetJumpTargets(scanner),
	scanner[CodeScanMatch_type] =
	 scanner[CodeScanMatch_name] =
	  scanner[CodeScanner_param] =
	   scanner[CodeScanner_state] =
	    scanner[CodeScanMatch_heap] =
	     scanner[CodeScanMatch_stack] = 0,
	scanner[CodeScanMatch_params] = cellmin,
	scanner[CodeScanner_first] = -1;
}

stock CodeScanGetFunctionScanner(csm[CodeScanner], ret[CodeScanner], ctx[DisasmContext]) {


	CodeScanInit(ret),
	ctx[DisasmContext_end_ip] = 0,
	ctx[DisasmContext_start_ip] = ctx[DisasmContext_nip] = ctx[DisasmContext_cip] = csm[CodeScanMatch_func];
	switch (csm[CodeScanMatch_type]) {
		case 0, (3), (4), (7), (8): {
			ret[CodeScanner_state] = 4;
		}
		default: {
			ret[CodeScanner_state] = 0;
		}
	}
}

stock CodeScanGetMatchScanner(csm[CodeScanner], ret[CodeScanner], ctx[DisasmContext], bool:accurate = false) {


	CodeScanGetFunctionScanner(csm, ret, ctx);
	if (accurate) {


		while (ctx[DisasmContext_nip] < csm[CodeScanMatch_cip]) {
			CodeScanStepInternal(ctx, ret, ret[CodeScanner_state], ret[CodeScanner_param]);
		}
	} else {

		ctx[DisasmContext_start_ip] = ctx[DisasmContext_nip] = ctx[DisasmContext_cip] = csm[CodeScanMatch_cip];
	}
}

stock CodeScanGetFunctionDisasm(csm[CodeScanner], ctx[DisasmContext], offset = 0) {


	ctx[DisasmContext_end_ip] = 0,
	ctx[DisasmContext_start_ip] = ctx[DisasmContext_nip] = ctx[DisasmContext_cip] = csm[CodeScanMatch_func] + offset;
}

stock CodeScanGetMatchDisasm(csm[CodeScanner], ctx[DisasmContext], offset = 0) {


	ctx[DisasmContext_end_ip] = 0,
	ctx[DisasmContext_start_ip] = ctx[DisasmContext_nip] = ctx[DisasmContext_cip] = csm[CodeScanMatch_cip] + offset;
}

stock CodeScanGetFunctionAsm(csm[CodeScanner], ctx[AsmContext], offset = 0) {


	AsmInitPtr(ctx, csm[CodeScanMatch_func] + offset, cellmax);
}

stock CodeScanGetMatchAsm(csm[CodeScanner], ctx[AsmContext], offset = 0) {


	AsmInitPtr(ctx, csm[CodeScanMatch_cip] + offset, cellmax);
}

stock CodeScanGetMatchFunc(csm[CodeScanner]) {

	return csm[CodeScanMatch_func] - gDat;
}

stock CodeScanGetMatchAddress(csm[CodeScanner]) {

	return csm[CodeScanMatch_cip] - gDat;
}

stock CodeScanGetMatchFuncData(csm[CodeScanner]) {

	return csm[CodeScanMatch_func];
}

stock CodeScanGetMatchAddressData(csm[CodeScanner]) {

	return csm[CodeScanMatch_cip];
}

stock CodeScanGetMatchLength(csm[CodeScanner]) {
	return csm[CodeScanMatch_size];
}

stock CodeScanGetMatchType(csm[CodeScanner]) {

	if (csm[CodeScanMatch_type] >= (5)) {
		csm[CodeScanMatch_name][0] = '\0';
		if (CodeScanGetFuncName(csm[CodeScanMatch_func], csm[CodeScanMatch_name])) {
			csm[CodeScanMatch_type] -= 4;
		} else {
			csm[CodeScanMatch_type] /= 2;



		}
	}












	return csm[CodeScanMatch_type];
}

stock CodeScanGetMatchHeap(csm[CodeScanner]) {
	return csm[CodeScanMatch_heap];
}

stock CodeScanGetMatchStack(csm[CodeScanner]) {
	return csm[CodeScanMatch_stack];
}

stock CodeScanGetMatchHole(csm[CodeScanner], idx) {
	return csm[CodeScanMatch_holes][idx];
}

stock CodeScanGetMatchName(csm[CodeScanner], name[]) {
	if (csm[CodeScanMatch_type] >= (5)) {

		CodeScanGetMatchType(csm);
	}
	name[0] = '\0',
	strcat(name, csm[CodeScanMatch_name], 32);
}



#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Storage\..\YSI_Internal\y_thirdpartyinclude.inc"
#line 90

#line 100

#line 110

#line 120

#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Storage\..\YSI_Internal\..\amx\heap_alloc.inc"
#line 1




















#line 25

#line 27


stock HeapAllocBytes(nbytes) {
	new address;
	#emit lctrl 2
	#emit stor.s.pri address
	#emit load.s.alt nbytes
	#emit add
	#emit sctrl 2
	return address;
}


stock HeapAllocCells(ncells) {
	return HeapAllocBytes(ncells * 4);
}


stock HeapRelease(address) {
	#emit load.s.pri address
	#emit sctrl 2
	return address;
}


#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Storage\..\YSI_Internal\y_thirdpartyinclude.inc"
#line 130

#line 140

#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Storage\..\YSI_Internal\..\amx\os.inc"
#line 1




















#line 25

#line 27

enum OS {
	OS_UNKNOWN,
	OS_LINUX,
	OS_WINDOWS
};

stock OS:GetOS() {
	static OS:os = OS_UNKNOWN;
	if (os == OS_UNKNOWN) {
		os = RelocateOpcode(OP_LOAD_PRI) == OP_LOAD_PRI
			? OS_WINDOWS
			: OS_LINUX;
	}
	return os;
}

stock bool:IsWindows() {
	return GetOS() == OS_WINDOWS;
}

stock bool:IsLinux() {
	return GetOS() == OS_LINUX;
}


#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Storage\..\YSI_Internal\y_thirdpartyinclude.inc"
#line 150

#line 160

#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Storage\..\YSI_Internal\..\amx\profiler.inc"
#line 1




















#line 25

#line 27

#line 31


#line 36


#line 41

enum ProfEntryCode {
	pec_push_address[2],
	pec_push_index[2],
	pec_push_8[2],
	pec_call_enter[2]
}

static stock g_pecs[1000][ProfEntryCode];
static stock g_num_pecs;

enum ProfCallInfo {
	pci_index,
	pci_start_time
}

enum ProfPublicInfo {
	ppi_child_time,
	ppi_total_time,
	ppi_num_calls
}

static stock g_publics[1000][ProfPublicInfo];
static stock g_num_publics;

static stock g_call_stack[10][ProfCallInfo];
static stock g_call_depth;

static stock exit_public() {
	if (--g_call_depth < sizeof(g_call_stack)) {
		new index = g_call_stack[g_call_depth][pci_index];

		new parent = -1;
		if (g_call_depth > 0) {
			parent = g_call_stack[g_call_depth-1][pci_index];
		}

		if (index < g_num_publics) {
			new i = g_call_depth;
			new tick = GetTickCount();
			new time = tick - g_call_stack[i][pci_start_time];
			if (time < 0) {

				if (tick < 0) {
					time = (tick - cellmin) + (cellmax - g_call_stack[i][pci_start_time]);
				}
			}
			if (time > 0) {
				g_publics[index][ppi_total_time] += time;
				if (parent > 0) {
					g_publics[parent][ppi_child_time] += time;
				}
			}
			g_publics[index][ppi_num_calls]++;
		}





	}

	#emit halt 0
	return 0; 
}

static stock enter_public(index, address) {






	if (g_call_depth < sizeof(g_call_stack)) {
		new pci[ProfCallInfo];
		pci[pci_index] = index;
		pci[pci_start_time] = GetTickCount();
		g_call_stack[g_call_depth] = pci;
	} else {
		printf("profiler warning: PROF_MAX_CALL_STACK is set to %d but current level is %d", 10, g_call_depth);
	}


	#emit stack 20

	++g_call_depth;


	#emit stack 4
	#emit const.pri exit_public
	#emit lctrl 8
	#emit push.pri


	#emit load.s.pri address
	#emit jump.pri

	return 0; 
}

static stock new_pec(index, address, code_start) {
	if (g_num_pecs < sizeof(g_pecs)) {
		new pec[ProfEntryCode];

		pec[pec_push_address][0] = RelocateOpcode(OP_PUSH_C);
		pec[pec_push_address][1] = address;

		pec[pec_push_index][0] = RelocateOpcode(OP_PUSH_C);
		pec[pec_push_index][1] = index;

		pec[pec_push_8][0] = RelocateOpcode(OP_PUSH_C);
		pec[pec_push_8][1] = 8;

		new enter_proc;
		#emit const.pri enter_public
		#emit stor.s.pri enter_proc
		pec[pec_call_enter][0] = RelocateOpcode(OP_CALL);
		pec[pec_call_enter][1] = code_start + enter_proc;

		g_pecs[g_num_pecs] = pec;
		return g_num_pecs++;
	}

	return -1;
}

stock ProfilerInit() {
	new hdr[AMX_HDR];
	GetAmxHeader(hdr);

	new publics = hdr[AMX_HDR_PUBLICS] - hdr[AMX_HDR_DAT];
	new defsize = hdr[AMX_HDR_DEFSIZE];
	new num_publics = (hdr[AMX_HDR_NATIVES] - hdr[AMX_HDR_PUBLICS]) / defsize;

	new amx_base = GetAmxBase();


	for (new i = 0, cur = publics; i < num_publics; cur += defsize, i++) {
		new address;
		#emit lref.s.pri cur
		#emit stor.s.pri address

		new pec_index = new_pec(i, address, amx_base + hdr[AMX_HDR_COD]);
		if (pec_index < 0) {
			printf("profiler warning: Too many public functions (%d). Consider increasing PROF_MAX_PUBLICS.", num_publics);
			break;
		}


		new pec_start;
		#emit const.alt g_pecs
		#emit load.s.pri pec_index
		#emit idxaddr
		#emit move.alt
		#emit load.i
		#emit add
		#emit stor.s.pri pec_start


		HookPublic(i, pec_start + hdr[AMX_HDR_DAT] - hdr[AMX_HDR_COD]);

		g_publics[i][ppi_child_time] = 0;
		g_publics[i][ppi_total_time] = 0;
		g_publics[i][ppi_num_calls] = 0;
		g_num_publics++;
	}
}

stock bool:ProfilerWriteData(const filename[]) {
	new File:file = fopen(filename, io_write);
	new buffer[100];

	if (!file) {
		return false;
	}

	fwrite(file, "+----------------------------------+----------------+----------------+----------------+\n");
	fwrite(file, "| name                             |          calls |      self_time |     total_time |\n");
	fwrite(file, "+----------------------------------+----------------+----------------+----------------+\n");

	for (new i = 0; i < g_num_publics; i++) {
		new name[32];
		GetPublicNameByIndex(i, name);
		format(buffer, sizeof(buffer), "| %32s |%15d |%15d |%15d |\n",
			name,
			g_publics[i][ppi_num_calls],
			g_publics[i][ppi_total_time] - g_publics[i][ppi_child_time],
			g_publics[i][ppi_total_time]
		);
		fwrite(file, buffer);
		fwrite(file, "+----------------------------------+----------------+----------------+----------------+\n");
	}

	fclose(file);
	return true;
}


#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Storage\..\YSI_Internal\y_thirdpartyinclude.inc"
#line 170











#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Storage\..\YSI_Internal\..\amx\stack_dump.inc"
#line 1




















#line 25






























#line 56

#line 58

stock DumpStack()
{
	new stp, stk;

	#emit lctrl 3
	#emit stor.s.pri stp
	#emit lctrl 4
	#emit stor.s.pri stk

	print("------------------------");
	print("Stack dump:");
	print("------------------------");


	stk += 20;


	new i = stp;
	printf("[0x%08x]: TOP", i);
	i -= 4;
	for ( ; i >= stk; i -= 4) {
		printf("[0x%08x]: 0x%08x", i, ReadAmxMemory(i));
	}

	print("------------------------");
}


#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Storage\..\YSI_Internal\y_thirdpartyinclude.inc"
#line 190

#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Storage\..\YSI_Internal\..\amx\stack_trace.inc"
#line 1




















#line 25

#line 29

stock GetFunctionFromReturnAddress(ret_addr) {
	new addr = ret_addr - 4;

	#emit load.s.alt addr
	#emit lctrl 0
	#emit add
	#emit move.alt
	#emit lctrl 1
	#emit sub.alt

	#emit stor.s.pri addr
	#emit lref.s.alt addr
	#emit lctrl 0
	#emit sub.alt
	#emit stor.s.pri addr

	return addr - GetAmxBaseAddress();
}

stock GetStackTrace(trace[], skip = 0, max = sizeof(trace)) {
	new frm_addr;
	#emit lctrl 5
	#emit stor.s.pri frm_addr

	new length = 0;
	while (length < max) {
		new ret_addr = GetFrameReturn(frm_addr);
		if (length >= skip) {
			trace[length] = ret_addr;
		}
		if (ret_addr == 0) {
			break;
		}
		frm_addr = GetFramePreviousFrame(frm_addr);
		if (frm_addr == 0) {
			break;
		}
		length++;
	}

	return length;
}

stock PrintStackTrace(trace[], max = sizeof(trace)) {
	print("Stack trace:");

	new i = 0;

	for (; trace[i] != 0 && i < max - 1; i++) {
		new name[32];
		new address = GetFunctionFromReturnAddress(trace[i + 1]);
		if (GetPublicNameFromAddress(address, name)) {
			printf(" %s[%08x]", name, trace[i]);
		} else {
			printf(" ??[%08x]", trace[i]);
		}
	}

	printf(" ??[%08x]", trace[i]);
}


#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Storage\..\YSI_Internal\y_thirdpartyinclude.inc"
#line 200

#line 204



#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Storage\y_amx.inc"
#line 78

#line 81

#line 86

stock
	AMX_HEADER_SIZE,
	AMX_HEADER_MAGIC,
	AMX_HEADER_FILE_VERSION,
	AMX_HEADER_AMX_VERSION,
	AMX_HEADER_FLAGS,
	AMX_HEADER_DEFSIZE,


	AMX_HEADER_COD,
	AMX_HEADER_DAT,
	AMX_HEADER_HEA,
	AMX_HEADER_STP,
	AMX_HEADER_CIP,
	AMX_HEADER_PUBLICS,
	AMX_HEADER_NATIVES,
	AMX_HEADER_LIBRARIES,
	AMX_HEADER_PUBVARS,
	AMX_HEADER_TAGS,
	AMX_HEADER_NAMETABLE,

	AMX_REAL_ADDRESS,
	AMX_BASE_ADDRESS,
	AMX_REAL_DATA;

enum E_AMX_TABLE
{
	AMX_TABLE_PUBLICS,
	AMX_TABLE_NATIVES,
	AMX_TABLE_LIBRARIES,
	AMX_TABLE_PUBVARS,
	AMX_TABLE_TAGS
}




public Debug_OnScriptInit()
{
	new
		addr,
		data;
	#emit LCTRL                     1
	#emit STOR.S.pri                addr


	addr = -addr;

	#emit LREF.S.pri                addr
	#emit STOR.S.pri                data
	AMX_HEADER_SIZE         = data;
	addr += 4;
	#emit LREF.S.pri                addr
	#emit STOR.S.pri                data
	AMX_HEADER_MAGIC        = data & 0xFFFF;
	AMX_HEADER_FILE_VERSION = data >>> 16 & 0xFF;
	AMX_HEADER_AMX_VERSION  = data >>> 24;
	addr += 4;
	#emit LREF.S.pri                addr
	#emit STOR.S.pri                data
	AMX_HEADER_FLAGS        = data & 0xFFFF;
	AMX_HEADER_DEFSIZE      = data >>> 16;
	addr += 4;
	#emit LREF.S.pri                addr
	#emit STOR.S.pri                data
	AMX_HEADER_COD          = data;
	addr += 4;
	#emit LREF.S.pri                addr
	#emit STOR.S.pri                data

	AMX_HEADER_DAT          = 0;
	AMX_BASE_ADDRESS = -data;
	AMX_HEADER_COD += AMX_BASE_ADDRESS;
	addr += 4;
	#emit LREF.S.pri                addr
	#emit STOR.S.pri                data
	AMX_HEADER_HEA          = data + AMX_BASE_ADDRESS;
	addr += 4;
	#emit LREF.S.pri                addr
	#emit STOR.S.pri                data
	AMX_HEADER_STP          = data + AMX_BASE_ADDRESS;
	addr += 4;
	#emit LREF.S.pri                addr
	#emit STOR.S.pri                data
	AMX_HEADER_CIP          = data + AMX_BASE_ADDRESS;
	addr += 4;
	#emit LREF.S.pri                addr
	#emit STOR.S.pri                data
	AMX_HEADER_PUBLICS      = data + AMX_BASE_ADDRESS;
	addr += 4;
	#emit LREF.S.pri                addr
	#emit STOR.S.pri                data
	AMX_HEADER_NATIVES      = data + AMX_BASE_ADDRESS;
	addr += 4;
	#emit LREF.S.pri                addr
	#emit STOR.S.pri                data
	AMX_HEADER_LIBRARIES    = data + AMX_BASE_ADDRESS;
	addr += 4;
	#emit LREF.S.pri                addr
	#emit STOR.S.pri                data
	AMX_HEADER_PUBVARS      = data + AMX_BASE_ADDRESS;
	addr += 4;
	#emit LREF.S.pri                addr
	#emit STOR.S.pri                data
	AMX_HEADER_TAGS         = data + AMX_BASE_ADDRESS;
	addr += 4;
	#emit LREF.S.pri                addr
	#emit STOR.S.pri                data
	AMX_HEADER_NAMETABLE    = data + AMX_BASE_ADDRESS;


	AMX_REAL_ADDRESS = AMX_GetGlobal();
	AMX_REAL_DATA = AMX_REAL_ADDRESS - AMX_BASE_ADDRESS;

#line 207
	return 1;
}

#line 215

stock AMX_GetGlobalAddress(...)
{
	new
		addr;

	#emit LOAD.S.pri 8
	#emit STOR.S.pri addr
	if (addr >= 4)
	{

		#emit LOAD.S.pri 12
		#emit LOAD.alt   AMX_REAL_DATA
		#emit ADD
		#emit STACK 4
		#emit RETN
	}
	return 0;
}

stock AMX_GetRelativeAddress(...)
{
	new
		addr;

	#emit LOAD.S.pri 8
	#emit STOR.S.pri addr
	if (addr >= 4)
	{

		#emit LOAD.S.pri 12
		#emit STACK 4
		#emit RETN
	}
	return 0;
}

static AMX_DoNothing()
{
	return 0;
}

static AMX_GetGlobal()
{
	new
	addr = -1;

	AMX_DoNothing();
	#emit LCTRL 6
	#emit CONST.alt 12
	#emit SUB
	#emit LOAD.alt AMX_HEADER_COD
	#emit ADD
	#emit STOR.S.pri addr
	#emit LREF.S.pri addr

	#emit SUB
	#emit CONST.alt AMX_DoNothing
	#emit SUB
	#emit MOVE.alt
	#emit LCTRL 1
	#emit XCHG
	#emit SUB

	#emit STACK 4
	#emit RETN
	return 0;
}

stock AMX_TraceCode(pattern[], &addrRet, &dataRet, size = sizeof (pattern))
{
	new
		addr = AMX_HEADER_COD + addrRet,
		data,
		i;
	while (addr < AMX_HEADER_DAT)
	{
		#emit LREF.S.pri      addr
		#emit STOR.S.pri      data
		if (data == pattern[i])
		{
			++i;
			addr += 4;
			if (i == size)
			{
				addrRet = addr - i * 4 - AMX_HEADER_COD;
				#emit LREF.S.pri      addr
				#emit STOR.S.pri      data
				dataRet = data;
				return 1;
			}
		}
		else if (i)
		{
			addr -= i * 4 - 4;
			i = 0;
		}
		else
		{
			addr += 4;
		}
	}
	return 0;
}

stock AMX_TraceMemory(pattern[], &addrRet, &dataRet, size = sizeof (pattern))
{
	new
		addr = AMX_HEADER_DAT + addrRet,
		data,
		i;
	while (addr < AMX_HEADER_HEA)
	{
		#emit LREF.S.pri      addr
		#emit STOR.S.pri      data
		if (data == pattern[i])
		{
			++i;
			addr += 4;
			if (i == size)
			{
				addrRet = addr - i * 4 - AMX_HEADER_DAT;
				#emit LREF.S.pri      addr
				#emit STOR.S.pri      data
				dataRet = data;
				return 1;
			}
		}
		else if (i)
		{
			addr -= i * 4 - 4;
			i = 0;
		}
		else
		{
			addr += 4;
		}
	}
	return 0;
}

stock AMX_GetBaseCount(E_AMX_TABLE:table, &base, &count)
{
	
	switch (table)
	{
		case AMX_TABLE_PUBLICS:
		{
			base = AMX_HEADER_PUBLICS;
			count = (AMX_HEADER_NATIVES - AMX_HEADER_PUBLICS) / 8;
		}
		case AMX_TABLE_NATIVES:
		{
			base = AMX_HEADER_NATIVES;
			count = (AMX_HEADER_LIBRARIES - AMX_HEADER_NATIVES) / 8;
		}
		case AMX_TABLE_LIBRARIES:
		{
			base = AMX_HEADER_LIBRARIES;
			count = (AMX_HEADER_PUBVARS - AMX_HEADER_LIBRARIES) / 8;
		}
		case AMX_TABLE_PUBVARS:
		{
			base = AMX_HEADER_PUBVARS;
			count = (AMX_HEADER_TAGS - AMX_HEADER_PUBVARS) / 8;
		}
		case AMX_TABLE_TAGS:
		{
			base = AMX_HEADER_TAGS;
			count = (AMX_HEADER_NAMETABLE - AMX_HEADER_TAGS) / 8;
		}
		default:
		{
			base = 0;
			count = 0;
		}
	}
}

#line 399

stock AMX_GetEntry(E_AMX_TABLE:table, idx, &buffer, const pattern[] = "", const bool:exact = false)
{
	
	new
		base,
		count;
	AMX_GetBaseCount(table, base, count);
	if (idx < count)
	{
		if (pattern[0] == '\0')
		{
			buffer = idx * 8 + base;
			return idx + 1;
		}
		else
		{
			new
				addr,
				pos = idx * 8 + base + 4,
				str[32];
			do
			{
				++idx;
				#emit LREF.S.pri pos
				#emit STOR.S.pri addr
				if (addr)
				{
					AMX_ReadString(AMX_BASE_ADDRESS + addr, str);
					if (exact ? (str{0} && !strcmp(str, pattern)) : (strfind(str, pattern) != -1))
					{
						buffer = pos - 4;
						return idx;
					}
				}
				pos += 8;
			}
			while (idx < count);
		}
	}
	return 0;
}

#line 447

stock AMX_GetEntryPrefix(E_AMX_TABLE:table, idx, &buffer, pattern)
{
	
	new
		base,
		count,
		addr;
	AMX_GetBaseCount(table, base, count);
	new
		pos = idx * 8 + base + 4;
	while (idx < count)
	{
		++idx;

		#emit LREF.S.pri                pos
		#emit STOR.S.pri                addr
		if (addr)
		{

			addr += AMX_BASE_ADDRESS;
			#emit LREF.S.pri                addr
			#emit STOR.S.pri                addr
			if (addr == pattern)
			{
				buffer = pos - 4;
				return idx;
			}
		}
		pos += 8;
	}
	return 0;
}

#line 486

stock AMX_GetEntrySuffix(E_AMX_TABLE:table, idx, &buffer, pattern)
{
	
	new
		base,
		count,
		addr,
		ch;
	AMX_GetBaseCount(table, base, count);
	new
		pos = idx * 8 + base + 4;
	while (idx < count)
	{
		++idx;

		#emit LREF.S.pri                pos
		#emit STOR.S.pri                addr
		if (addr)
		{
			addr += AMX_BASE_ADDRESS;
			for ( ; ; )
			{

				#emit LREF.S.pri            addr
				#emit STOR.S.pri            ch
				if (ch & 0x000000FF)
				{
					if (ch & 0x0000FF00)
					{
						if (ch & 0x00FF0000)
						{
							if (ch & 0xFF000000)
							{
								addr += 4;
								continue;
							}
							else addr -= 1;
						}
						else addr -= 2;
					}
					else addr -= 3;
				}
				else addr -= 4;
				break;
			}
			#emit LREF.S.pri                addr
			#emit STOR.S.pri                ch
			if (ch == pattern)
			{
				buffer = pos - 4;
				return idx;
			}
		}
		pos += 8;
	}
	return 0;
}

#line 550

stock AMX_GetName(E_AMX_TABLE:table, idx, buffer[32], const pattern[] = "", const bool:exact = false)
{
	
	new
		base,
		count,
		addr;
	AMX_GetBaseCount(table, base, count);
	new
		pos = idx * 8 + base + 4;
	while (idx < count)
	{
		++idx;
		#emit LREF.S.pri pos
		#emit STOR.S.pri addr
		if (addr)
		{
			AMX_ReadString(AMX_BASE_ADDRESS + addr, buffer);
			if ((pattern[0] == '\0') || (exact ? (!strcmp(buffer, pattern)) : (strfind(buffer, pattern) != -1)))
			{
				return idx;
			}
		}
		pos += 8;
	}
	return 0;
}

#line 584

stock AMX_GetNamePrefix(E_AMX_TABLE:table, idx, buffer[32], pattern)
{
	
	new
		base,
		count,
		addr;
	AMX_GetBaseCount(table, base, count);
	new
		pos = idx * 8 + base + 4;
	while (idx < count)
	{
		++idx;

		#emit LREF.S.pri                pos
		#emit STOR.S.pri                addr
		if (addr)
		{

			addr += AMX_BASE_ADDRESS;
			#emit LREF.S.pri                addr
			#emit STOR.S.pri                addr
			if (addr == pattern)
			{
				#emit LREF.S.pri            pos
				#emit STOR.S.pri            addr
				AMX_ReadString(AMX_BASE_ADDRESS + addr, buffer);
				return idx;
			}
		}
		pos += 8;
	}
	return 0;
}

#line 625

stock AMX_GetNameSuffix(E_AMX_TABLE:table, idx, buffer[32], pattern)
{
	
	new
		base,
		count,
		addr,
		ch;
	AMX_GetBaseCount(table, base, count);
	new
		pos = idx * 8 + base + 4;
	while (idx < count)
	{
		++idx;
		#emit LREF.S.pri                pos
		#emit STOR.S.pri                addr
		if (addr)
		{





			addr += AMX_BASE_ADDRESS;
			for ( ; ; )
			{

				#emit LREF.S.pri            addr
				#emit STOR.S.pri            ch
				if (ch & 0x000000FF)
				{
					if (ch & 0x0000FF00)
					{
						if (ch & 0x00FF0000)
						{
							if (ch & 0xFF000000)
							{
								addr += 4;
								continue;
							}
							else addr -= 1;
						}
						else addr -= 2;
					}
					else addr -= 3;
				}
				else addr -= 4;
				break;
			}
			#emit LREF.S.pri                addr
			#emit STOR.S.pri                ch
			if (ch == pattern)
			{
				#emit LREF.S.pri            pos
				#emit STOR.S.pri            addr
				AMX_ReadString(AMX_BASE_ADDRESS + addr, buffer);
				return idx;
			}
		}
		pos += 8;
	}
	return 0;
}

#line 695

stock AMX_GetPointer(E_AMX_TABLE:table, idx, &buffer, const pattern[] = "", const bool:exact = false)
{
	
	new
		pointer;
	idx = AMX_GetEntry(table, idx, pointer, pattern, exact);
	if (idx)
	{
		#emit LREF.S.pri pointer
		#emit SREF.S.pri buffer
	}
	return idx;
}

#line 715

stock AMX_GetPointerPrefix(E_AMX_TABLE:table, idx, &buffer, pattern)
{
	
	new
		pointer;
	idx = AMX_GetEntryPrefix(table, idx, pointer, pattern);
	if (idx)
	{
		#emit LREF.S.pri pointer
		#emit SREF.S.pri buffer
	}
	return idx;
}

#line 735

stock AMX_GetPointerSuffix(E_AMX_TABLE:table, idx, &buffer, pattern)
{
	
	new
		pointer;
	idx = AMX_GetEntrySuffix(table, idx, pointer, pattern);
	if (idx)
	{
		#emit LREF.S.pri pointer
		#emit SREF.S.pri buffer
	}
	return idx;
}

#line 755

stock AMX_GetValue(E_AMX_TABLE:table, idx, &buffer, const pattern[] = "", const bool:exact = false)
{
	
	new
		pointer;
	idx = AMX_GetPointer(table, idx, pointer, pattern, exact);
	if (idx)
	{
		#emit LREF.S.pri pointer
		#emit SREF.S.pri buffer
	}
	return idx;
}

#line 775

stock AMX_GetValuePrefix(E_AMX_TABLE:table, idx, &buffer, pattern)
{
	
	new
		pointer;
	idx = AMX_GetPointerPrefix(table, idx, pointer, pattern);
	if (idx)
	{
		#emit LREF.S.pri pointer
		#emit SREF.S.pri buffer
	}
	return idx;
}

#line 795

stock AMX_GetValueSuffix(E_AMX_TABLE:table, idx, &buffer, pattern)
{
	
	new
		pointer;
	idx = AMX_GetPointerSuffix(table, idx, pointer, pattern);
	if (idx)
	{
		#emit LREF.S.pri pointer
		#emit SREF.S.pri buffer
	}
	return idx;
}






























stock AMX_GetEntryPointer(entry)
{
	#emit LREF.S.pri entry
	#emit RETN
	return 0; 
}






























































stock AMX_GetEntryFromNativeIndex(index)
{
	return (index * 8) + AMX_HEADER_NATIVES;
}

stock AMX_GetEntryFromPublicIndex(index)
{

	return (index * 8) + AMX_HEADER_PUBLICS;
}

stock AMX_GetNativeIndexFromEntry(entry)
{
	return (entry - AMX_HEADER_NATIVES) / 8;
}

stock AMX_GetPublicIndexFromEntry(entry)
{
	return (entry - AMX_HEADER_PUBLICS) / 8;
}

stock AMX_GetStringFromEntry(entry, str[], size = sizeof (str))
{
	entry += 4;
	#emit LREF.S.pri entry
	#emit STOR.S.pri entry
	AMX_ReadString(AMX_BASE_ADDRESS + entry, str, size);
}
























stock AMX_ReadString(addr, str[], len = sizeof (str))
{
	new
		buffer,
		idx;
	do
	{

		#emit LREF.S.pri                addr
		#emit STOR.S.pri                buffer

		buffer = (buffer >>> 24) | (buffer >> 8 & 0x0000FF00) | (buffer << 8 & 0x00FF0000) | (buffer << 24);
		str[idx] = buffer;
		if (!(buffer & 0x000000FF && buffer & 0x0000FF00 && buffer & 0x00FF0000 && buffer & 0xFF000000))
		{
			return;
		}
		addr += 4;
	}
	while (++idx < len);
}

stock AMX_ReadUnpackedString(addr, str[], len = sizeof (str))
{
	new
		buffer = 1;
	while (buffer && len--);
	{

		#emit LREF.S.pri                addr
		#emit STOR.S.pri                buffer
		#emit SREF.S.pri                str
		#emit LOAD.S.pri                str
		#emit ADD.C                     4
		#emit STOR.S.pri                str
		addr += 4;
	}
}

stock AMX_WriteString(addr, const str[], len = sizeof (str))
{
	new
		old,
		buffer,
		idx;
	do
	{
		buffer = str[idx];
		
		if      (!(buffer & 0xFF000000))
		{
			#emit LREF.S.pri                addr
			#emit CONST.alt                 0xFFFFFF00
			#emit AND
			#emit SREF.S.pri                addr
			return;
		}
		else if (!(buffer & 0x00FF0000))
		{




			#emit LREF.S.pri                addr
			#emit STOR.S.pri                old
			buffer = (old & 0xFFFF0000) | (buffer >>> 24);
			#emit LOAD.S.pri                buffer
			#emit SREF.S.pri                addr
			return;
		}
		else if (!(buffer & 0x0000FF00))
		{




			#emit LREF.S.pri                addr
			#emit STOR.S.pri                old
			buffer = (old & 0xFF000000) | (buffer >>> 24) | (buffer >> 8 & 0x0000FF00);
			#emit LOAD.S.pri                buffer
			#emit SREF.S.pri                addr
			return;
		}
		else if (!(buffer & 0x000000FF))
		{





			buffer = (buffer >>> 24) | (buffer >> 8 & 0x0000FF00) | (buffer << 8 & 0x00FF0000);
			#emit LOAD.S.pri                buffer
			#emit SREF.S.pri                addr
			return;
		}
		else
		{

			buffer = (buffer >>> 24) | (buffer >> 8 & 0x0000FF00) | (buffer << 8 & 0x00FF0000) | (buffer << 24);
			#emit LOAD.S.pri                buffer
			#emit SREF.S.pri                addr
			addr += 4;
		}
	}
	while (++idx < len);
}

stock AMX_Read(addr)
{

	static
		sFrame;

	#emit LCTRL      4
	#emit ADD.C      12

	#emit LOAD.S.alt 0
	#emit SUB
	#emit STOR.pri   sFrame
	
	new
		start = GetCurrentFrameReturn() - 16,
		ctx2[DisasmContext];
	DisasmInit(ctx2, start, start + 16);
	if (!DisasmDecodeInsn(ctx2) || DisasmGetOpcode(ctx2) != OP_PUSH_C || DisasmGetOperand(ctx2) != 4)
	{
		Debug_Print0("\7*** YSI Warning: " #"Couldn't rewrite \"AMX_Read\" call");
		return AMX_RawRead(addr);
	}
	new
		ctx[AsmContext];
	AsmInitPtr(ctx, start + AMX_HEADER_COD, 16);




	AsmEmitLrefSPri(ctx,  sFrame );	AsmEmitPopAlt(ctx);	AsmEmitNop(ctx);	return AMX_RawRead(addr);
}

stock AMX_Write(addr, value)
{
	
	#emit LOAD.S.pri                    value
	#emit SREF.S.pri                    addr
}

stock AMX_RawRead(addr)
{
	
	#emit LREF.S.pri                    addr
	#emit RETN
	return 0;
}

stock AMX_RawWrite(addr, value)
{
	
	#emit LOAD.S.pri                    value
	#emit SREF.S.pri                    addr
}

stock AMX_ReadArray(addr, dest[], len = sizeof (dest))
{


	while (len--)
	{


		#emit LREF.S.pri                addr
		#emit SREF.S.pri                dest
		#emit LOAD.S.pri                addr
		#emit ADD.C                     4
		#emit STOR.S.pri                addr
		#emit LOAD.S.pri                dest
		#emit ADD.C                     4
		#emit STOR.S.pri                dest
	}
}

stock AMX_WriteArray(addr, const src[], len = sizeof (src))
{
	while (len--)
	{
		#emit DEC.pri

		#emit LREF.S.pri                dest
		#emit SREF.S.pri                addr
		#emit LOAD.S.pri                addr
		#emit ADD.C                     4
		#emit STOR.S.pri                addr
		#emit LOAD.S.pri                dest
		#emit ADD.C                     4
		#emit STOR.S.pri                dest
	}
}







#line 1167

#line 1169


#line 1172

#line 1174

#line 1176

#line 1178

#line 1180



#line 1186

#line 1212

#line 1239

#line 1250


#line 1255

#line 1281

#line 1308

#line 1319

#line 1321


#line 1324

#line 1326

#line 1328

#line 1330

#line 1332



#line 1338

#line 1364

#line 1391

#line 1402


#line 1407

#line 1433

#line 1460

#line 1471



#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\y_utils.inc"
#line 93


#line 97

#line 99



#line 103

#line 105






#line 112

#line 114
new stock
	bool:TRUE = true;
#line 118
new stock
	bool:FALSE = false;
#line 122
new stock
	NULL[2] = "\1";
#line 125

#line 129

#line 131


#line 136

#line 146

#line 150

#line 162



#line 168

#line 172

stock __TU(t, iters)
{

	new
		ret[20];
	if      (iters >  1000000000)
		format(ret, sizeof (ret), "%.2fps", float(t) / (float(iters) / 1000000000.0));
	else if (iters == 1000000000)
		format(ret, sizeof (ret), "%d.00ps", t);
	else if (iters >  1000000)
		format(ret, sizeof (ret), "%.2fns", float(t) / (float(iters) / 1000000.0));
	else if (iters == 1000000)
		format(ret, sizeof (ret), "%d.00ns", t);
	else if (iters >  1000)
		format(ret, sizeof (ret), "%.2fus", float(t) / (float(iters) / 1000.0));
	else if (iters == 1000)
		format(ret, sizeof (ret), "%d.00us", t);
	else if (iters >  1)
		format(ret, sizeof (ret), "%.2fms", float(t) / float(iters));
	else
		format(ret, sizeof (ret), "%d.00ms", t);
	return ret;
}

#line 203

#line 209

stock
	YSI_gPlayerIP[(1000) + 1] = {-1, ...};

public OnPlayerConnect(playerid)
{
	new
		ip[16];
	GetPlayerIp(playerid, ip, sizeof (ip)),
	YSI_gPlayerIP[playerid] = IPToInt(ip);
#line 222
	return 1;
}

#line 231

#line 235

public OnPlayerDisconnect(playerid, reason)
{
	YSI_gPlayerIP[playerid] = -1;
#line 242
	return 1;
}

#line 251

#line 255

#line 257













#line 272

#line 274

















#line 293

#line 295













#line 309

#line 311














#line 326

#line 328










#line 342

#line 344










#line 356

#line 358










#line 370

#line 372












#line 386

#line 388











stock StrToLower(str[], len = sizeof (str))
{
	new
		i = -1,
		ch;
	while ((ch = str[++i]) && len--)
		str[i] = tolower(ch);
}

#line 409











stock StrToUpper(str[], len = sizeof (str))
{
	new
		i = -1,
		ch;
	while ((ch = str[++i]) && len--)
		str[i] = toupper(ch);
}

#line 430












stock Random(min, max = cellmin)
{
	if (max == cellmin)
	{
		if (min < 0)
			return -random(-min);
		return random(min);
	}
	if (max < min)
		return random(min - max) + max;
	return random(max - min) + min;
}

#line 456













stock Float:RandomFloat(Float:min, Float:max = (Float:0x7FFFFFFF), dp = 2)
{
	new
		Float:mul = floatpower(10.0, float(dp));
	switch (dp)
	{
	case 0: mul = 1.0;
	case 1: mul = 10.0;
	case 2: mul = 100.0;
	case 3: mul = 1000.0;
	default: mul = floatpower(10.0, float(dp));
	}
	if (max != max)
	{
		if (min < 0.0)
			return -(float(random(floatround(-min * mul))) / mul);
		return float(random(floatround(min * mul))) / mul;
	}

	if (max < min)
		return float(random(floatround(min * mul - max * mul))) / mul + max;

	return float(random(floatround(max * mul - min * mul))) / mul + min;
}

#line 495










stock StripNL(str[])
{
	
	new
		i = strlen(str);
	while (i-- && str[i] <= ' ') str[i] = '\0';
}

#line 514










stock StripL(str[])
{
	
	new
		len = strlen(str),
		i = 0;
	while ('\0' < str[i] <= ' ') ++i;
	if (i) memcpy(str[0], str[i], 0, (len - i) * 4, len);
}

#line 535










stock Strip(str[])
{
	
	new
		len = strlen(str),
		i = len;
	while (i-- && str[i] <= ' ') str[i] = '\0';
	i = 0;
	while ('\0' < str[i] <= ' ') ++i;
	if (i) memcpy(str[0], str[i], 0, (len - i) * 4, len);
}

#line 558











stock endofline(line[], pos)
{
	
	if ((((pos)-(( 0)+cellmin))>=(( strlen(line))-(( 0)+cellmin)))) return 0;

	while (line[pos]) if (line[pos++] > ' ') return 0;
	return 1;
}

#line 579












stock chrfind(needle, haystack[], start = 0)
{
	
	if (start < 0)
	{
		start = 0;
	}
	else if (start > strlen(haystack)) return -1;
	while (haystack[start]) if (haystack[start++] == needle) return start - 1;
	return -1;
}

stock chrfindp(needle, haystack[], start = 0)
{
	
	if (start < 0)
	{
		start = 0;
	}
	while (haystack{start}) if (haystack{start++} == needle) return start - 1;
	return -1;
}

#line 615










stock IPToInt(ip[])
{
	new
		ipv = strval(ip) << 24,
		pos = 0;
	while (pos < 15 && ip[pos++] != '.') {}
	ipv += strval(ip[pos]) << 16;
	while (pos < 15 && ip[pos++] != '.') {}
	ipv += strval(ip[pos]) << 8;
	while (pos < 15 && ip[pos++] != '.') {}
	return ipv + strval(ip[pos]);
}

#line 639
































stock bernstein(string[]         )
{

	
	#pragma unused string
	new
		base,
		ctx[AsmContext];

	#emit CONST.pri  bernstein
	#emit LOAD.alt   AMX_HEADER_COD
	#emit ADD
	#emit STOR.S.pri base
	AsmInitPtr(ctx, base, 128), 

	AsmEmitProc(ctx);	AsmEmitConstAlt(ctx,  -1 );	AsmEmitPushS(ctx,     12  );	AsmEmitLrefSPri(ctx, 12  );	AsmEmitJzerRel(ctx,   12 * 4  );
	AsmEmitXchg(ctx);	AsmEmitSmulC(ctx,     33 );	AsmEmitAdd(ctx);	AsmEmitMoveAlt(ctx);
	AsmEmitPopPri(ctx);	AsmEmitAddC(ctx,      4 );	AsmEmitPushPri(ctx);
	AsmEmitLoadI(ctx);	AsmEmitJnzRel(ctx,    -(12 * 4)  );
	AsmEmitMovePri(ctx);	AsmEmitStack(ctx,      4 );	AsmEmitRetn(ctx);
	#emit LCTRL      5
	#emit SCTRL      4
	#emit CONST.pri  bernstein
	#emit ADD.C      4
	#emit SCTRL      6
	return 0; 
}

#line 717










stock ishex(str[])
{
	
	new
		i,
		cur;
	if (str[0] == '0' && (str[1] | 0x20) == 'x') i = 2;
	do
	{
		cur = str[i++];
	}
	while ((((cur)-(( '0')+cellmin))<(( '9' + 1)-(( '0')+cellmin))) || (((cur | 0x20)-(( 'a')+cellmin))<(( 'f' + 1)-(( 'a')+cellmin))));

	return !cur; 
}

#line 744










stock unpack(const str[])
{
	
	new
		ret[(130)] = {0};
	if (strlen(str) <= (130))
	{
		strunpack(ret, str);
	}
	return ret;
}

#line 767











#line 779

#line 781











#line 797

stock returnstringarg(idx)
{
	static
		scSize = (130);


	#emit LOAD.S.pri idx

	#emit SMUL.C     4





	#emit LOAD.S.alt 0

	#emit ADD

	#emit ADD.C      12

	#emit LOAD.I

	#emit PUSH       scSize

	#emit PUSH.pri

	#emit LOAD.S.alt 16

	#emit CONST.pri  0

	#emit STOR.I

	#emit PUSH.alt

	#emit PUSH.C     12

	#emit SYSREQ.C   strcat

	#emit STACK      16

	#emit RETN


	new
		ret[(130)];
	return ret;
}

#line 847













stock va_return(const fmat[], {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D}:...)
{
	#pragma unused fmat

	static
		sFrm,
		sRet,
		sCnt,
		scSize = (130);


	#emit POP.pri
	#emit STOR.pri     sFrm
	#emit STACK        0 
	#emit POP.pri
	#emit STOR.pri     sRet
	#emit POP.pri
	#emit ADD.C        8
	#emit STOR.pri     sCnt


	#emit PUSH         scSize
	#emit ADD
	#emit LOAD.I
	#emit PUSH.pri


	#emit PUSH         sCnt
	#emit SYSREQ.C     format



	#emit PUSH         sRet
	#emit PUSH         sFrm
	#emit RETN


	new
		ret[(130)];
	return ret;
}

#line 903










stock isnumeric(str[])
{
	
	new
		i;
	while ((((str[i])-(( '0')+cellmin))<(( '9' + 1)-(( '0')+cellmin)))) ++i;

	return !str[i];
}

#line 925










	stock hexstr(string[])
	{
		new
			ret,
			val,
			i;
		if (string[0] == '0' && string[1] | 0x20 == 'x') i = 2;
		for ( ; ; )
		{
			switch ((val = string[i++]))
			{
				case '0' .. '9':
				{
					val -= '0';
				}
				case 'a' .. 'f':
				{
					val -= 'a' - 10;
				}
				case 'A' .. 'F':
				{
					val -= 'A' - 10;
				}
				default: break;
			}
			ret = ret << 4 | val;
		}
		return ret;
	}

#line 966












	stock bool:boolstr(string[])
	{

		return string[0] && string[0] != '0' && strcmp(string, "false", true);
	}

#line 985











	stock binstr(string[])
	{
		new
			pos = 0;
		switch (string[0])
		{
			case '0':
			{
				if (string[1] | 0x20 == 'b')
				{
					pos = 2;
				}
			}
			case '1':
			{
			}
			default:
			{
				return 0;
			}
		}
		new
			value = 0;
		for ( ; ; )
		{
			switch (string[pos++])
			{
				case '0':
				{
					value <<= 1;
				}
				case '1':
				{
					value = (value << 1) | 1;
				}
				default:
				{
					break;
				}
			}
		}
		return value;
	}
#line 1040

#line 1042














stock rawMemcpy(dest, src, bytes)
{

	#emit PUSH.S     bytes
	#emit PUSH.S     bytes
	#emit PUSH.C     0
	#emit PUSH.S     src
	#emit PUSH.S     dest
	#emit PUSH.C     20
	#emit SYSREQ.C   memcpy
	#emit STACK      24
	#emit RETN
	return 0;
}

#line 1072


























stock memset(arr[], val = 0, size = sizeof (arr))
{
	new
		addr;
	#emit LOAD.S.pri arr
	#emit STOR.S.pri addr

	return rawMemset(addr, val, size * 4);
}

stock rawMemset(iAddress         , iValue         , iSize         )
{

	#pragma unused iAddress, iSize, iValue

















	new
		base,
		ctx[AsmContext];

	#emit CONST.pri  rawMemset
	#emit LOAD.alt   AMX_HEADER_COD
	#emit ADD
	#emit STOR.S.pri base
	AsmInitPtr(ctx, base, 80), 


	AsmEmitProc(ctx);	AsmEmitLoadSPri(ctx,20 );	AsmEmitConstAlt(ctx, 0xFFFFFFC );	AsmEmitAnd(ctx);	AsmEmitStorPri(ctx,  (ctx[AsmContext_buffer] + 13 * 4) );
	AsmEmitLoadSAlt(ctx,12 );	AsmEmitLoadSPri(ctx,16 );	AsmEmitFill(ctx,      0 );
	AsmEmitLoadPri(ctx,  (ctx[AsmContext_buffer] + 13 * 4) );	AsmEmitRetn(ctx);
	#emit CONST.pri  memset
	#emit LOAD.alt   AMX_HEADER_COD
	#emit ADD
	#emit STOR.S.pri base
	AsmInitPtr(ctx, base, 80),
	AsmEmitProc(ctx);	AsmEmitLoadSPri(ctx,20 );	AsmEmitShlCPri(ctx, 2 );	AsmEmitStorPri(ctx,  (ctx[AsmContext_buffer] + 12 * 4) );	AsmEmitLoadSAlt(ctx,12 );	AsmEmitLoadSPri(ctx,16 );	AsmEmitFill(ctx,      0 );
	AsmEmitLoadPri(ctx,  (ctx[AsmContext_buffer] + 12 * 4) );	AsmEmitRetn(ctx);

	#emit LCTRL      5
	#emit SCTRL      4
	#emit CONST.pri  rawMemset
	#emit ADD.C      4
	#emit SCTRL      6

	return 0; 
}

#line 1180













stock ReturnPlayerName(playerid)
{
	new
		str[24];
	GetPlayerName(playerid, str, sizeof (str));
	return str;
}

#line 1202















stock ftouch(const filename[])
{
	if (fexist(filename))
	{
		return 0;
	}
	else
	{
		new
			File:f = fopen(filename, io_write);
		if (f)
		{
			fclose(f);
			return 1;
		}
		else
		{
			return -1;
		}
	}
}

#line 1240

























#line 1266
stock InterpolateColour(startcolor, endcolor, value, maxvalue, minvalue = 0)
{
    if (value >= maxvalue) return endcolor;
    if (value <= minvalue) return startcolor;
	static r, g, b, a;
	new
		time  = maxvalue - minvalue,
		stage = value    - minvalue;
	return

		r = startcolor >>> 24       ,
		g = startcolor >>> 16 & 0xFF,
		b = startcolor >>> 8  & 0xFF,
		a = startcolor        & 0xFF,

		r += ((endcolor >>> 24       ) - r) * stage / time,
		g += ((endcolor >>> 16 & 0xFF) - g) * stage / time,
		b += ((endcolor >>> 8  & 0xFF) - b) * stage / time,
		a += ((endcolor        & 0xFF) - a) * stage / time,

		(r << 24) | ((g & 0xFF) << 16) | ((b & 0xFF) << 8) | (a & 0xFF);
}

#line 1290











stock SkipWhitespace(const str[], pos)
{
	while ((((str[pos])-(( '\0' + 1)+cellmin))<(( ' ' + 1)-(( '\0' + 1)+cellmin)))) ++pos;

	return pos;
}

#line 1309












stock Trim(const str[], &start, &end)
{
	while ((((str[start])-(( '\0' + 1)+cellmin))<(( ' ' + 1)-(( '\0' + 1)+cellmin)))) ++start;

	if (str[start])
	{
		while (end-- > start && str[end] <= ' ') {}
		++end;
	}
	else
	{
		end = start;
	}
}

#line 1337












static stock Utils_PreSort(arr[], num = sizeof (arr))
{

	new
		bool:sort;
	do
	{
		sort = false;
		for (new j = 1, temp; j != num; ++j)
		{
			if ((temp = arr[j]) < arr[j - 1])
			{
				arr[j] = arr[j - 1],
				arr[j - 1] = temp,
				sort = true;
			}
		}
	}
	while (sort);
}

stock Sum(const arr[], num = sizeof (arr))
{
	new
		tot;
	while (num) tot += arr[--num];
	return tot;
}

stock Mean(const arr[], num = sizeof (arr))
{
	return Sum(arr, num) / num;
}

stock Mode(arr[], num = sizeof (arr))
{
	Utils_PreSort(arr, num);
	new
		ret,
		count = 0,
		cn,
		cc;
	for (new i = 0; i != num; ++i)
	{
		if (arr[i] == cn) ++cc;
		else
		{
			if (cc > count) count = cc, ret = cn;
			cc = 1, cn = arr[i];
		}
	}
	if (cc > count) return cn;
	else return ret;
}

stock Median(arr[], num = sizeof (arr))
{
	Utils_PreSort(arr, num);
	new
		idx = num >>> 1;
	if (num & 1) return arr[idx];
	else return (arr[idx] + arr[idx - 1]) >> 1;
}

stock Range(arr[], num = sizeof (arr))
{
	Utils_PreSort(arr, num);
	return arr[num - 1] - arr[0];
}

#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Coding\y_va.inc"
#line 2






























































































#line 100

#line 102


#line 106



#line 113

#line 115

#line 117

#line 119


#line 131

#line 133

#line 136


#line 139


native va_printf            (const format[], {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D}:...)                                        = printf;
native va_CallRemoteFunction(const function[], const format[], {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D}:...)                      = CallRemoteFunction;
native va_CallLocalFunction (const function[], const format[], {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D}:...)                      = CallLocalFunction;
native va_SetTimerEx        (const function[], interval, repeating, const format[], {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D}:...) = SetTimerEx;
native va_format            (output[], len, const format[], {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D}:...)                         = format;

#line 150

#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Coding\y_va/impl.inc"
#line 2





























































































#line 98

static stock
	YSI_g_sLength[(4)], 
	YSI_g_sSkips[(4)],
	YSI_g_sStacks[(4)],
	YSI_g_sContexts[(4)][AsmContext],
	YSI_g_sMaxNesting = 0,
	YSI_g_sPassthroughNestings = 0;

#line 108
static stock YVA2_DoPush(const skippedBytes, const pushedBytes, const pushRequirements)
{


















	#pragma unused pushedBytes, skippedBytes, pushRequirements
	static
		sReturnAddress,
		sPushedParameters,
		sParametersBase,
		sTotalParameters;


























	#emit POP.pri
	#emit SCTRL        5 

	#emit POP.pri
	#emit STOR.pri     sReturnAddress
	#emit POP.pri        
	#emit POP.alt                        
	#emit LCTRL        5                 
	#emit ADD.C        12                
	#emit ADD                            
	#emit STOR.pri     sParametersBase
	#emit LOAD.S.pri   8                 
	#emit SUB                            
	#emit STOR.pri     sPushedParameters
	#emit POP.alt                        
	#emit ADD                            
	#emit STOR.pri     sTotalParameters  
	#emit POP.alt






	#emit LOAD.pri     sTotalParameters
	#emit STOR.I

	#emit LCTRL        4
	#emit LOAD.alt     sPushedParameters
	#emit SUB
	#emit SCTRL        4 





	#emit STACK        0
	#emit PUSH.C       0x10000000
	#emit PUSH         sPushedParameters
	#emit PUSH.C       0
	#emit PUSH         sParametersBase
	#emit PUSH.alt
	#emit PUSH.C       20
	#emit SYSREQ.C     memcpy
	#emit STACK        24


	#emit LOAD.pri     sReturnAddress
	#emit SCTRL        6
}


#line 213


stock YVA2_DummyPush(const skippedBytes = 0, const pushedBytes = 0, const pushRequirements = 4, const dummy0 = 0, const dummy1 = 0, const dummy2 = 0, const dummy3 = 0, const dummy4 = 0, const dummy5 = 0)
{
	#pragma unused dummy0, dummy1, dummy2, dummy3, dummy4, dummy5















	if (FALSE)
	{
		YVA2_DoPush(pushedBytes, skippedBytes, pushRequirements);
	}
	Debug_Print0("\7*** YSI Warning: " #"Bare `___` usage found - make sure it is a function parameter.");
	return 0;
}

static stock YVA2_CodeGenPushSite(ctx[AsmContext], const pushedBytes, const skippedBytes                 , const offset)
{



	AsmEmitAddrPri(ctx,    offset                   );	AsmEmitPushPri(ctx);	AsmEmitPushC(ctx,      pushedBytes - 4          );	AsmEmitPushC(ctx,      skippedBytes             );	AsmEmitPushC(ctx,      12                       );	AsmEmitCallAbs(ctx,    (O@A_()?(((YVA2_DoPush(-1, -1, -1)),O@V_)?1:2):(O@V_))  );

	AsmEmitHeap(ctx,        4                        );}

static stock YVA2_CodeGenShiftCode(dest, src, end)
{


	while (src != end)
	{
		#emit LREF.S.pri   src
		#emit SREF.S.pri   dest
		src += 4;
		dest += 4;
	}

	src = _:RelocateOpcode(OP_NOP);
	while (dest != end)
	{
		#emit LOAD.S.pri   src
		#emit SREF.S.pri   dest
		dest += 4;
	}
}

static stock YVA2_CodeGenMainCleanup(ctx[AsmContext])
{
	static
		sTemp;

	AsmEmitPopAlt(ctx);
	AsmEmitStorPri(ctx,    ref(sTemp)  );
	AsmEmitLctrl(ctx,       4           );
	AsmEmitAdd(ctx);
	AsmEmitSctrl(ctx,       4           );
	AsmEmitLoadPri(ctx,    ref(sTemp)  );}

static stock YVA2_CodeGenDeepCleanup(ctx[AsmContext], depth, returningString)
{
	if (returningString)
		AsmEmitPopPri(ctx);
	AsmEmitStack(ctx,       depth * (cellbits / 8) );}

static stock YVA2_CodeGenPushVariable(ctx[AsmContext], stack)
{

	AsmEmitPushS(ctx,      stack );}

static stock YVA2_FoundCall(m[CodeScanner])
{
	if (YSI_g_sPassthroughNestings)
	{
		new
			pos = YSI_g_sPassthroughNestings - 1;
		if ((CodeScanGetMatchStack(m) < YSI_g_sStacks[pos]) || (!pos && YSI_g_sSkips[0] & cellmin && CodeScanGetMatchStack(m) < YSI_g_sStacks[pos] + (cellbits / 8)))
		{
			new
				len = CodeScanGetMatchLength(m),
				end = CodeScanGetMatchAddressData(m) + len,
				hole = CodeScanGetMatchHole(m, 0),
				returningString = 0,
				codeLength = 52;
			YSI_g_sPassthroughNestings = pos;
			if (!pos && YSI_g_sSkips[0] & cellmin)
			{
				YSI_g_sSkips[0] &= cellmax;






				new
					dctx[DisasmContext];
				CodeScanGetMatchDisasm(m, dctx, len);
				switch (DisasmNextInsn(dctx))
				{

					case OP_HEAP:
						returningString = (DisasmNextInsn(dctx) == OP_POP_PRI) ? 3 * (cellbits / 8) : 0;
					case OP_POP_PRI:
						returningString = 1 * (cellbits / 8);
					default:
						returningString = 0;
				}
				if (!returningString)
					Debug_Print0("\7\7\7\7\7*** YSI Fatal Error: " #"Found string return preamble without postamble - Y_Less needs to fix this!");
			}
			if (returningString)
			{


				YSI_g_sContexts[0][AsmContext_buffer] -= 3 * (cellbits / 8),
				codeLength = ReadAmxMemory(YSI_g_sContexts[0][AsmContext_buffer] + (cellbits / 8)),
				AsmEmitStack(YSI_g_sContexts[0], (YSI_g_sMaxNesting + 1) * -(cellbits / 8)),
				AsmEmitHeap(YSI_g_sContexts[0], codeLength),
				AsmEmitPushAlt(YSI_g_sContexts[0]),
				codeLength = 52 + 5 * (cellbits / 8);
			}
			else if (!pos)
			{
				AsmEmitStack(YSI_g_sContexts[0], (YSI_g_sMaxNesting + 1) * -(cellbits / 8)),
				codeLength += 2 * (cellbits / 8);
			}
			new
				dest = YSI_g_sContexts[pos][AsmContext_buffer];

			YVA2_CodeGenPushSite(YSI_g_sContexts[pos], hole, YSI_g_sSkips[pos], -YSI_g_sStacks[0] - pos * (cellbits / 8)), 

			YVA2_CodeGenShiftCode(
				dest + YSI_g_sContexts[pos][AsmContext_buffer_offset],
				dest + YSI_g_sLength[pos] + (returningString ? 12 : 0),
				end + returningString),


			YSI_g_sContexts[pos][AsmContext_buffer_offset] = (end - dest) - (YSI_g_sLength[pos] - codeLength + returningString) - 16;
			if (len == 24)
				YSI_g_sContexts[pos][AsmContext_buffer_offset] -= 8;
			YVA2_CodeGenPushVariable(YSI_g_sContexts[pos], -YSI_g_sStacks[0] - pos * (cellbits / 8));
			YSI_g_sContexts[pos][AsmContext_buffer_offset] += 8;
			if (returningString == 12)
				YSI_g_sContexts[pos][AsmContext_buffer_offset] += 8;
			if (len == 24)
				YVA2_CodeGenMainCleanup(YSI_g_sContexts[pos]);
			if (YSI_g_sPassthroughNestings)
			{

			}
			else 
			{

				YVA2_CodeGenDeepCleanup(YSI_g_sContexts[pos], (YSI_g_sMaxNesting + 1), returningString),
				YSI_g_sMaxNesting = 0;
			}

			return 0;
		}
	}
	return -1;
}

static stock YVA2_FoundPush(m[CodeScanner])
{
	if (YSI_g_sPassthroughNestings >= (4))
	{
		Debug_Print0("\7\7\7\7\7*** YSI Fatal Error: " #"`___` nested too deeply - increase `MAX_NESTED_PASSTHROUGHS`.");
		return;
	}
	YSI_g_sMaxNesting = max(YSI_g_sMaxNesting, YSI_g_sPassthroughNestings),


	YSI_g_sLength[YSI_g_sPassthroughNestings] = CodeScanGetMatchLength(m),
	CodeScanGetMatchAsm(m, YSI_g_sContexts[YSI_g_sPassthroughNestings]),
	YSI_g_sStacks[YSI_g_sPassthroughNestings] = CodeScanGetMatchStack(m),

	YSI_g_sSkips[YSI_g_sPassthroughNestings] = (YSI_g_sLength[YSI_g_sPassthroughNestings] == 120) ? 0 : CodeScanGetMatchHole(m, 0);
	if (!YSI_g_sPassthroughNestings)
	{






		new
			dctx[DisasmContext];
		CodeScanGetMatchDisasm(m, dctx, -12);
		if (DisasmNextInsn(dctx) == OP_HEAP && DisasmNextInsn(dctx) == OP_PUSH_ALT)
		{

			YSI_g_sSkips[YSI_g_sPassthroughNestings] |= cellmin,
			YSI_g_sStacks[0] -= (cellbits / 8);
		}
	}
	++YSI_g_sPassthroughNestings;
	
}













public AMX_OnScriptInit()
{
	new
		scanner[CodeScanner],
		csmO0A[CodeScanMatcher],
		csmO0B[CodeScanMatcher],
		csmO1[CodeScanMatcher],
		csm2[CodeScanMatcher],
		csm3[CodeScanMatcher];
	CodeScanInit(scanner);















	CodeScanMatcherInit_((csmO0A),(O@A_()?(((YVA2_FoundPush((gCodeScanCallback_match))),O@V_)?1:2):(O@V_)));
	CodeScanMatcherPattern_(csmO0A
		,(_:O@T_:(4)),(Opcode:O@X_:O@Y_:OP_ZERO_PRI),((3)),(0)                    
		,(_:O@T_:(4)),(Opcode:O@X_:O@Y_:OP_PUSH_PRI),((3)),(0)                    
		,(_:O@T_:(4)),(Opcode:O@X_:O@Y_:OP_ZERO_PRI),((3)),(0)                    
		,(_:O@T_:(4)),(Opcode:O@X_:O@Y_:OP_PUSH_PRI),((3)),(0)                    
		,(_:O@T_:(4)),(Opcode:O@X_:O@Y_:OP_ZERO_PRI),((3)),(0)                    
		,(_:O@T_:(4)),(Opcode:O@X_:O@Y_:OP_PUSH_PRI),((3)),(0)                    
		,(_:O@T_:(4)),(Opcode:O@X_:O@Y_:OP_ZERO_PRI),((3)),(0)                    
		,(_:O@T_:(4)),(Opcode:O@X_:O@Y_:OP_PUSH_PRI),((3)),(0)                    
		,(_:O@T_:(4)),(Opcode:O@X_:O@Y_:OP_ZERO_PRI),((3)),(0)                    
		,(_:O@T_:(4)),(Opcode:O@X_:O@Y_:OP_PUSH_PRI),((3)),(0)                    
		,(_:O@T_:(4)),(Opcode:O@X_:O@Y_:OP_ZERO_PRI),((3)),(0)                    
		,(_:O@T_:(4)),(Opcode:O@X_:O@Y_:OP_PUSH_PRI),((3)),(0)                    
		,(_:O@T_:(4)),(Opcode:O@X_:OP_CONST_PRI),(_:O@1_:O@2_:(0) ),(_:O@X_:O@Y_:(  4))               
		,(_:O@T_:(4)),(Opcode:O@X_:O@Y_:OP_PUSH_PRI),((3)),(0)                    
		,(_:O@T_:(4)),(Opcode:O@X_:O@Y_:OP_ZERO_PRI),((3)),(0)                    
		,(_:O@T_:(4)),(Opcode:O@X_:O@Y_:OP_PUSH_PRI),((3)),(0)                    
		,(_:O@T_:(4)),(Opcode:O@X_:O@Y_:OP_ZERO_PRI),((3)),(0)                    
		,(_:O@T_:(4)),(Opcode:O@X_:O@Y_:OP_PUSH_PRI),((3)),(0)                    
		,(_:O@T_:(4)),(Opcode:O@X_:OP_PUSH_C),(_:O@1_:O@2_:(0) ),(_:O@X_:O@Y_:(     36))              
		,(_:O@T_:(4)),(Opcode:O@X_:OP_CALL),(_:O@1_:(2)),(O@A_()?(((YVA2_DummyPush(-1, -1, -1, -1, -1, -1, -1, -1, -1)),O@V_)?1:2):_:O@X_:O@Y_:(O@V_)) 
		,(_:O@T_:(4)),(Opcode:O@X_:OP_HEAP),(_:O@1_:O@2_:(0) ),(_:O@X_:O@Y_:(       4))               
		,(_:O@T_:(4)),(Opcode:O@X_:O@Y_:OP_STOR_I),((3)),(0)                      
		,(_:O@T_:(4)),(Opcode:O@X_:O@Y_:OP_MOVE_PRI),((3)),(0)                    
		,(_:O@T_:(4)),(Opcode:O@X_:O@Y_:OP_PUSH_PRI),((3)),(0)                    
	);
	CodeScanAddMatcher(scanner, csmO0A);
	CodeScanMatcherInit_((csmO0B),(O@A_()?(((YVA2_FoundPush((gCodeScanCallback_match))),O@V_)?1:2):(O@V_)));
	CodeScanMatcherPattern_(csmO0B
		,(_:O@T_:(4)),(Opcode:O@X_:O@Y_:OP_ZERO_PRI),((3)),(0)                    
		,(_:O@T_:(4)),(Opcode:O@X_:O@Y_:OP_PUSH_PRI),((3)),(0)                    
		,(_:O@T_:(4)),(Opcode:O@X_:O@Y_:OP_ZERO_PRI),((3)),(0)                    
		,(_:O@T_:(4)),(Opcode:O@X_:O@Y_:OP_PUSH_PRI),((3)),(0)                    
		,(_:O@T_:(4)),(Opcode:O@X_:O@Y_:OP_ZERO_PRI),((3)),(0)                    
		,(_:O@T_:(4)),(Opcode:O@X_:O@Y_:OP_PUSH_PRI),((3)),(0)                    
		,(_:O@T_:(4)),(Opcode:O@X_:O@Y_:OP_ZERO_PRI),((3)),(0)                    
		,(_:O@T_:(4)),(Opcode:O@X_:O@Y_:OP_PUSH_PRI),((3)),(0)                    
		,(_:O@T_:(4)),(Opcode:O@X_:O@Y_:OP_ZERO_PRI),((3)),(0)                    
		,(_:O@T_:(4)),(Opcode:O@X_:O@Y_:OP_PUSH_PRI),((3)),(0)                    
		,(_:O@T_:(4)),(Opcode:O@X_:O@Y_:OP_ZERO_PRI),((3)),(0)                    
		,(_:O@T_:(4)),(Opcode:O@X_:O@Y_:OP_PUSH_PRI),((3)),(0)                    
		,(_:O@T_:(4)),(Opcode:O@X_:OP_CONST_PRI),(_:O@1_:O@2_:(0) ),(_:O@X_:O@Y_:(  4))               
		,(_:O@T_:(4)),(Opcode:O@X_:O@Y_:OP_PUSH_PRI),((3)),(0)                    
		,(_:O@T_:(4)),(Opcode:O@X_:O@Y_:OP_ZERO_PRI),((3)),(0)                    
		,(_:O@T_:(4)),(Opcode:O@X_:O@Y_:OP_PUSH_PRI),((3)),(0)                    
		,(_:O@T_:(4)),(Opcode:O@X_:OP_CONST_PRI),(_:(1) ),(_:O@X_:O@Y_:0)             
		,(_:O@T_:(4)),(Opcode:O@X_:O@Y_:OP_PUSH_PRI),((3)),(0)                    
		,(_:O@T_:(4)),(Opcode:O@X_:OP_PUSH_C),(_:O@1_:O@2_:(0) ),(_:O@X_:O@Y_:(     36))              
		,(_:O@T_:(4)),(Opcode:O@X_:OP_CALL),(_:O@1_:(2)),(O@A_()?(((YVA2_DummyPush(-1, -1, -1, -1, -1, -1, -1, -1, -1)),O@V_)?1:2):_:O@X_:O@Y_:(O@V_)) 
		,(_:O@T_:(4)),(Opcode:O@X_:OP_HEAP),(_:O@1_:O@2_:(0) ),(_:O@X_:O@Y_:(       4))               
		,(_:O@T_:(4)),(Opcode:O@X_:O@Y_:OP_STOR_I),((3)),(0)                      
		,(_:O@T_:(4)),(Opcode:O@X_:O@Y_:OP_MOVE_PRI),((3)),(0)                    
		,(_:O@T_:(4)),(Opcode:O@X_:O@Y_:OP_PUSH_PRI),((3)),(0)                    
	);
	CodeScanAddMatcher(scanner, csmO0B);











	CodeScanMatcherInit_((csmO1),(O@A_()?(((YVA2_FoundPush((gCodeScanCallback_match))),O@V_)?1:2):(O@V_)));
	CodeScanMatcherPattern_(csmO1
		,(_:O@T_:(4)),(Opcode:O@X_:OP_PUSH_C),(_:O@1_:O@2_:(0) ),(_:O@X_:O@Y_:(     0))               
		,(_:O@T_:(4)),(Opcode:O@X_:OP_PUSH_C),(_:O@1_:O@2_:(0) ),(_:O@X_:O@Y_:(     0))               
		,(_:O@T_:(4)),(Opcode:O@X_:OP_PUSH_C),(_:O@1_:O@2_:(0) ),(_:O@X_:O@Y_:(     0))               
		,(_:O@T_:(4)),(Opcode:O@X_:OP_PUSH_C),(_:O@1_:O@2_:(0) ),(_:O@X_:O@Y_:(     0))               
		,(_:O@T_:(4)),(Opcode:O@X_:OP_PUSH_C),(_:O@1_:O@2_:(0) ),(_:O@X_:O@Y_:(     0))               
		,(_:O@T_:(4)),(Opcode:O@X_:OP_PUSH_C),(_:O@1_:O@2_:(0) ),(_:O@X_:O@Y_:(     0))               
		,(_:O@T_:(4)),(Opcode:O@X_:OP_PUSH_C),(_:O@1_:O@2_:(0) ),(_:O@X_:O@Y_:(     4))               
		,(_:O@T_:(4)),(Opcode:O@X_:OP_PUSH_C),(_:O@1_:O@2_:(0) ),(_:O@X_:O@Y_:(     0))               
		,(_:O@T_:(4)),(Opcode:O@X_:OP_PUSH_C),(_:(1) ),(_:O@X_:O@Y_:0)             
		,(_:O@T_:(4)),(Opcode:O@X_:OP_PUSH_C),(_:O@1_:O@2_:(0) ),(_:O@X_:O@Y_:(     36))              
		,(_:O@T_:(4)),(Opcode:O@X_:OP_CALL),(_:O@1_:(2)),(O@A_()?(((YVA2_DummyPush(-1, -1, -1, -1, -1, -1, -1, -1, -1)),O@V_)?1:2):_:O@X_:O@Y_:(O@V_)) 
		,(_:O@T_:(4)),(Opcode:O@X_:OP_HEAP),(_:O@1_:O@2_:(0) ),(_:O@X_:O@Y_:(       4))               
		,(_:O@T_:(4)),(Opcode:O@X_:O@Y_:OP_STOR_I),((3)),(0)                      
		,(_:O@T_:(4)),(Opcode:O@X_:O@Y_:OP_PUSH_ALT),((3)),(0)                    
	);
	CodeScanAddMatcher(scanner, csmO1);









	CodeScanMatcherInit_((csm2),(O@A_()?(((YVA2_FoundCall((gCodeScanCallback_match))),O@V_)?1:2):(O@V_)));
	CodeScanMatcherPattern_(csm2
		,(_:O@T_:(4)),(Opcode:O@X_:OP_PUSH_C),(_:(1) ),(_:O@X_:O@Y_:0)
		,(_:O@T_:(4)),(Opcode:O@X_:OP_CALL),(_:(1) ),(_:O@X_:O@Y_:0)
	);
	CodeScanAddMatcher(scanner, csm2);





	CodeScanMatcherInit_((csm3),(O@A_()?(((YVA2_FoundCall((gCodeScanCallback_match))),O@V_)?1:2):(O@V_)));
	CodeScanMatcherPattern_(csm3
		,(_:O@T_:(4)),(Opcode:O@X_:OP_PUSH_C),(_:(1) ),(_:O@X_:O@Y_:0)
		,(_:O@T_:(4)),(Opcode:O@X_:OP_SYSREQ_C),(_:(1) ),(_:O@X_:O@Y_:0)
		,(_:O@T_:(4)),(Opcode:O@X_:OP_STACK),(_:(1) ),(_:O@X_:O@Y_:0)
	);
	CodeScanAddMatcher(scanner, csm3);

	CodeScanRun(scanner);

#line 595
	return 1;
}

#line 604

#line 608

stock va_strlen(arg)
{




	#emit LOAD.S.pri arg

	#emit SMUL.C     4





	#emit LOAD.S.alt 0

	#emit ADD

	#emit ADD.C      12

	#emit LOAD.I

	#emit PUSH.pri

	#emit PUSH.C     4

	#emit SYSREQ.C   strlen

	#emit STACK      8
	#emit RETN

	return 0;
}

stock va_getstring(dest[], arg, len = sizeof (dest))
{


	#emit LOAD.S.pri arg

	#emit SMUL.C     4





	#emit LOAD.S.alt 0

	#emit ADD

	#emit ADD.C      12

	#emit LOAD.I

	#emit PUSH.S     len

	#emit PUSH.pri

	#emit LOAD.S.alt dest

	#emit ZERO.pri

	#emit STOR.I

	#emit PUSH.alt

	#emit PUSH.C     12

	#emit SYSREQ.C   strcat

	#emit STACK      16
}

stock PlayerText:va_CreatePlayerTextDraw(playerid, Float:x, Float:y, fmat[], {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D}:...)
{
	return CreatePlayerTextDraw(playerid, x, y, va_return(fmat, YVA2_DummyPush((4) * 4)));
}

stock Text:va_TextDrawCreate(Float:x, Float:y, fmat[], {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D}:...)
{
	return TextDrawCreate(x, y, va_return(fmat, YVA2_DummyPush((3) * 4)));
}

stock va_SendClientMessage(playerid, colour, const fmat[], {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D}:...)
{
	return SendClientMessage(playerid, colour, va_return(fmat, YVA2_DummyPush((3) * 4)));
}

stock va_SendClientMessageToAll(colour, const fmat[], {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D}:...)
{
	return SendClientMessageToAll(colour, va_return(fmat, YVA2_DummyPush((2) * 4)));
}

stock va_SendPlayerMessageToPlayer(playerid, senderid, const fmat[], {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D}:...)
{
	return SendPlayerMessageToPlayer(playerid, senderid, va_return(fmat, YVA2_DummyPush((3) * 4)));
}

stock va_SendPlayerMessageToAll(senderid, const fmat[], {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D}:...)
{
	return SendPlayerMessageToAll(senderid, va_return(fmat, YVA2_DummyPush((2) * 4)));
}

stock va_GameTextForPlayer(playerid, const fmat[], time, style, {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D}:...)
{
	return GameTextForPlayer(playerid, va_return(fmat, YVA2_DummyPush((4) * 4)), time, style);
}

stock va_GameTextForAll(const fmat[], time, style, {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D}:...)
{
	return GameTextForAll(va_return(fmat, YVA2_DummyPush((3) * 4)), time, style);
}

stock va_print(const fmat[], {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D}:...)
{
	return print(va_return(fmat, YVA2_DummyPush((1) * 4)));
}

stock va_fprintf(File:fhnd, const fmat[], {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D}:...)
{
	return fwrite(fhnd, va_return(fmat, YVA2_DummyPush((2) * 4)));
}



#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Coding\y_va.inc"
#line 152

#line 157



#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\y_utils.inc"
#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Internal\y_shortfunc.inc"
#line 2































































































#line 101


#line 106

#line 110

#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Internal\y_shortvar.inc"
#line 2




























































































#line 98


public
	_@ = 0;



stock
	I@,
	J@;



#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Internal\y_shortfunc.inc"
#line 115

#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Internal\y_renative.inc"
#line 2

























































#line 63

#line 66

#line 68


#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Internal\y_shortfunc.inc"
#line 117





native U@(id=0, const name[]="", value=cellmin, const string[]="")=setproperty;

native V@({_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D}:id=0, const name[]="", value=cellmin, string[]="")=getproperty;

#line 130

#line 138



native W@(const function[], const format[], {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D}:...)=CallRemoteFunction;

native P@(const function[], const format[], {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D}:...)=CallLocalFunction;

#line 150

#line 157

#line 159

#line 165

#line 168

#line 176

native O@(const function[], time, repeat, const format[], {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D}:...)=SetTimerEx;

#line 184

native K@(const function[], time, repeat)=SetTimer;

stock X@({_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D}:n)
{
	
	setproperty(8, #R, n);
}

stock Y@()
{
	

	return setproperty(8, #C, _@);
}

stock Z@({_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D}:v = -1)
{
	
	return
		setproperty(8, #C, v),
		getproperty(8, #R);
}

new Q@[(130)];

stock S@({_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D}:v = -1)
{
	
	return
		getproperty(8, "", (42), Q@),
		strunpack(Q@, Q@),
		setproperty(8, #C, v);

}

stock R@(buffer[])
{
	
	return setproperty(8, "", (42), buffer);
}

stock H@({_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D}:...)
{

	return 0;
}

#line 235

stock G@({_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D}:...)
{

	return Q@;
}

stock F@()
{
	
	return
		getproperty(8, "", (42), Q@),


		strunpack(Q@, Q@);


}






#line 260

#line 262


#line 265

#line 268

#line 270

#line 284



#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\y_utils.inc"
#line 1421



#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\y_hooks.inc"
#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\y_als.inc"
#line 2


























































#line 61

#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Data\y_bit.inc"
#line 2














































































































#line 116

#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Data\y_bit/impl.inc"
#line 2
















































































































#line 115

#line 129

#line 131











#line 143

#line 145










#line 156

#line 158










#line 169

#line 171











#line 183

#line 185















#line 201

#line 203











#line 215

#line 217











#line 229

#line 231
















stock Bit_Set(Bit:array[], slot, bool:set)
{

	if (set) array[( slot)>>>(5)]|=Bit:(1<<(( slot)&cellbits-1));
	else array[( slot)>>>(5)]&=Bit:~(1<<(( slot)&cellbits-1));
}

#line 255
















#line 272

#line 274















stock Bit_SetAll(Bit:array[], bool:set, size = sizeof (array))
{
	memset(_:array, set ? 0xFFFFFFFF : 0, size);
}

#line 295















#line 311
stock Bit_GetCount(Bit:array[], size = sizeof (array))
{
	new
		count;
	for (new i = 0; i != size; ++i)
	{
		count += Cell_CountBits(array[i]);
	}
	return count;
}

stock Bit_Display(Bit:array[], size = sizeof (array))
{
	new
		ret[(130)],
		val;
	while (size--)
	{
		val = Cell_ReverseBits(array[size]);
		format(ret, sizeof (ret), "%016b%016b%s", val >>> 16, val & 0xFFFF, ret);
	}

	return ret;
}

#line 337

stock Iter_Func@Bits(start, Bit:data[], size = sizeof (data))
{
	
	new
		cur,
		i = ((_:++start)>>>(5));
	if (i == size)
	{
		return -1;
	}

	if ((cur = _:(data[i] & ~((Bit:(1<<((_:start)&cellbits-1))) - Bit:1))))
	{
		

		return Cell_GetLowestBit(cur) + (i << (5));
	}
	while (++i != size)
	{
		if ((cur = _:data[i]))
		{
			return Cell_GetLowestBit(cur) + (i << (5));
		}
	}
	return -1;
}

#line 366

stock Iter_Func@Blanks(start, Bit:data[], size = sizeof (data))
{
	
	new
		cur,
		i = ((_:++start)>>>(5));
	if (i == size)
	{
		return -1;
	}
	if ((cur = _:(~data[i] & ~((Bit:(1<<((_:start)&cellbits-1))) - Bit:1))))
	{

		return Cell_GetLowestBit(cur) + (i << (5));
	}
	while (++i != size)
	{
		if ((cur = ~_:data[i]))
		{
			return Cell_GetLowestBit(cur) + (i << (5));
		}
	}
	return -1;
}

#line 393

#line 395

#line 398



#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\..\YSI_Data\y_bit.inc"
#line 122

#line 128



#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\y_als.inc"
#line 67

#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\y_als/impl.inc"
#line 1
enum ALS
{
	Bit:ALS_OnScriptInit,
	Bit:ALS_OnScriptExit,
	Bit:ALS_OnGameModeInit,
	Bit:ALS_OnGameModeExit,
	Bit:ALS_OnFilterScriptInit,
	Bit:ALS_OnFilterScriptExit,
	Bit:ALS_OnPlayerConnect,
	Bit:ALS_OnPlayerDisconnect,
	Bit:ALS_OnPlayerSpawn,
	Bit:ALS_OnPlayerDeath,
	Bit:ALS_OnVehicleSpawn,
	Bit:ALS_OnVehicleDeath,
	Bit:ALS_OnPlayerText,
	Bit:ALS_OnPlayerCommandText,
	Bit:ALS_OnPlayerRequestClass,
	Bit:ALS_OnPlayerEnterVehicle,
	Bit:ALS_OnPlayerExitVehicle,
	Bit:ALS_OnPlayerStateChange,
	Bit:ALS_OnPlayerEnterCheckpoint,
	Bit:ALS_OnPlayerLeaveCheckpoint,
	Bit:ALS_OnPlayerEnterRaceCheckpoint,
	Bit:ALS_OnPlayerLeaveRaceCheckpoint,
	Bit:ALS_OnRconCommand,
	Bit:ALS_OnPlayerRequestSpawn,
	Bit:ALS_OnObjectMoved,
	Bit:ALS_OnPlayerObjectMoved,
	Bit:ALS_OnPlayerPickUpPickup,
	Bit:ALS_OnVehicleMod,
	Bit:ALS_OnEnterExitModShop,
	Bit:ALS_OnVehiclePaintjob,
	Bit:ALS_OnVehicleRespray,
	Bit:ALS_OnVehicleDamageStatusUpdate,
	Bit:ALS_OnPlayerSelectedMenuRow,
	Bit:ALS_OnPlayerExitedMenu,
	Bit:ALS_OnPlayerInteriorChange,
	Bit:ALS_OnPlayerKeyStateChange,
	Bit:ALS_OnRconLoginAttempt,
	Bit:ALS_OnPlayerUpdate,
	Bit:ALS_OnPlayerStreamIn,
	Bit:ALS_OnPlayerStreamOut,
	Bit:ALS_OnVehicleStreamIn,
	Bit:ALS_OnVehicleStreamOut,
	Bit:ALS_OnDialogResponse,
	Bit:ALS_OnPlayerClickPlayer,
	Bit:ALS_OnPlayerLogin,
	Bit:ALS_OnPlayerLogout,
	Bit:ALS_OnPlayerTakeDamage,
	Bit:ALS_OnPlayerGiveDamage,
	Bit:ALS_OnPlayerClickMap,
	Bit:ALS_OnPlayerCommandReceived,
	Bit:ALS_OnPlayerCommandPerformed,
	Bit:ALS_OnUnoccupiedVehicleUpdate,
	Bit:ALS_OnPlayerClickTextDraw,
	Bit:ALS_OnPlayerClickPlayerTextDraw,
	Bit:ALS_OnPlayerEditObject,
	Bit:ALS_OnPlayerEditAttachedObject,

	Bit:ALS_OnPlayerWeaponShot,
	Bit:ALS_OnIncomingConnection,
	Bit:ALS_OnTrailerUpdate,
	Bit:ALS_OnVehicleSirenStateChange,
	Bit:ALS_OnPlayerGiveDamageActor,
	Bit:ALS_OnActorStreamIn,
	Bit:ALS_OnActorStreamOut,

	Bit:ALS_OnPlayerEnterArea,
	Bit:ALS_OnPlayerLeaveArea,
	Bit:ALS_OnPlayerFinishRace,
	Bit:ALS_OnPlayerExitRace,
	Bit:ALS_OnRaceEnd,
#line 85
	Bit:ALS_OnPlayerSelectObject
}

#line 89

#line 91


#line 95

#line 97




#line 102


#line 156

#line 162

#line 169

#line 180

#line 195

#line 203


#line 266

#line 272

#line 278

#line 289

#line 297

#line 309

#line 321

#line 333

#line 335

#line 339

#line 341



#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Core\y_als.inc"
#line 69

#line 72

#line 78


#line 87

#line 92

#line 95


#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\y_hooks.inc"
#line 92

#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\..\YSI_Internal\y_cgen.inc"
#line 5

#line 8



#line 13

static stock
	YSI_g_sCodeSpace = -1,
	YSI_g_sCodeEnd = -1;

forward _@_y_cgen_@_0();

public _@_y_cgen_@_0()
{
	#emit RETN 



	static
		s[] = "";


	SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
	SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
	SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
	SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
	SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
	SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
	SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
	SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
	SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
	SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
	SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
	SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
	SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
	SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
	SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
	SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);




	SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
	SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
	SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
	SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
	SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
	SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
	SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
	SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
	SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
	SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
	SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
	SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
	SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
	SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
	SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
	SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);SetTimerEx(s,0,0,s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
}

forward _@_y_cgen_@_1();

public _@_y_cgen_@_1()
{


}

static stock CGen_GetAddr(const func[])
{
	new
		entry = AMX_HEADER_PUBLICS + funcidx(func) * 8,
		ret = AMX_HEADER_COD + AMX_Read(entry);


	return ret;
}

static stock CGen_SetupCodeSpace()
{
	if (YSI_g_sCodeSpace != -1) return;

	YSI_g_sCodeSpace = CGen_GetAddr("_@_y_cgen_@_0"),
	YSI_g_sCodeEnd   = CGen_GetAddr("_@_y_cgen_@_1"),

	AMX_Write(YSI_g_sCodeSpace, _:RelocateOpcode(OP_PROC)),
	AMX_Write(YSI_g_sCodeSpace + 4, _:RelocateOpcode(OP_ZERO_PRI)),
	AMX_Write(YSI_g_sCodeSpace + 8, _:RelocateOpcode(OP_RETN)),
	YSI_g_sCodeSpace += 12;
}

stock CGen_UseCodeSpace(ctx[AsmContext])
{
	CGen_SetupCodeSpace();
	AsmInitPtr(ctx, YSI_g_sCodeSpace, YSI_g_sCodeEnd - YSI_g_sCodeSpace);
}

stock CGen_GetCodeSpace()
{
	CGen_SetupCodeSpace();
	return YSI_g_sCodeSpace;
}

stock CGen_AddCodeSpace(num)
{
	if (YSI_g_sCodeSpace == -1) Debug_Print0("\7\7\7*** YSI Error: " #"YSI_g_sCodeSpace is -1 in \"CGen_AddCodeSpace\"");
	else YSI_g_sCodeSpace += num;
}

#line 119



#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\y_hooks.inc"
#line 94

#line 96


#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\y_hooks/impl.inc"
#line 2



























































































forward @CO_HookChain();public @CO_HookChain(){return @CO_ScriptInit()+1;}
#line 96

static stock _HookChain_IncludeStates() <_ALS : _ALS_x0, _ALS : _ALS_x1, _ALS : _ALS_x2, _ALS : _ALS_x3>
{
}

static stock _HookChain_IncludeStates() <_ALS : _ALS_go>
{
}

forward @RETOnPlayerCommandText(); public @RETOnPlayerCommandText()
{
	return 0;
}

forward @RETOnRconCommand(); public @RETOnRconCommand()
{
	return 0;
}

enum E_PRE_HOOK
{
	E_PRE_HOOK_NAME[16],
	E_PRE_HOOK_VALUE
}


forward @_yHCheckpoint(); public @_yHCheckpoint() { _Hooks_AddReplacement(#Checkpoint, # CP ); }
forward @_yHContainer (); public @_yHContainer () { _Hooks_AddReplacement(#Container , # Cnt); }
forward @_yHInventory (); public @_yHInventory () { _Hooks_AddReplacement(#Inventory , # Inv); }
forward @_yHDynamic   (); public @_yHDynamic   () { _Hooks_AddReplacement(#Dynamic   , # Dyn); }
forward @_yHTextDraw  (); public @_yHTextDraw  () { _Hooks_AddReplacement(#TextDraw  , # TD ); }
forward @_yHUpdate    (); public @_yHUpdate    () { _Hooks_AddReplacement(#Update    , # Upd); }
forward @_yHObject    (); public @_yHObject    () { _Hooks_AddReplacement(#Object    , # Obj); }
forward @_yHCommand   (); public @_yHCommand   () { _Hooks_AddReplacement(#Command   , # Cmd); }
forward @_yHDynamicCP (); public @_yHDynamicCP () { _Hooks_AddReplacement(#DynamicCP , # DynamicCP); }

enum E_HOOK_NAME_REPLACEMENT_DATA
{
	E_HOOK_NAME_REPLACEMENT_SHORT[16],
	E_HOOK_NAME_REPLACEMENT_LONG[16],
	E_HOOK_NAME_REPLACEMENT_MIN,
	E_HOOK_NAME_REPLACEMENT_MAX
}

static stock
	YSI_g_sReplacements[(16)][E_HOOK_NAME_REPLACEMENT_DATA],
	YSI_g_sReplacementsLongOrder[(16)],
	YSI_g_sReplacementsShortOrder[(16)],
	YSI_g_sReplacePtr;

#line 147











stock Hooks_MakeLongName(name[64])
{
	new
		end = 0,
		i = 0,
		pos = -1,
		idx = YSI_g_sReplacementsShortOrder[0];
	while (i != YSI_g_sReplacePtr)
	{

		if ((pos = strfind(name, YSI_g_sReplacements[idx][E_HOOK_NAME_REPLACEMENT_SHORT], false, pos + 1)) == -1)
		{
			++i,
			idx = YSI_g_sReplacementsShortOrder[i];
		}



		else if ('a' <= name[(end = pos + YSI_g_sReplacements[idx][E_HOOK_NAME_REPLACEMENT_MIN])] <= 'z')
			continue;
		else
		{
			

			strdel(name, pos + 1, end),
			name[pos] = 0x80000000 | idx;
		}
	}



	if (end)
	{

		while (name[++pos])
		{
			
			if (name[pos] < '\0')
			{





				
				






				i = name[pos] & ~0x80000000,
				name[pos] = YSI_g_sReplacements[i][E_HOOK_NAME_REPLACEMENT_LONG];




#line 219
					strins
#line 221
						(name, YSI_g_sReplacements[i][E_HOOK_NAME_REPLACEMENT_LONG + E_HOOK_NAME_REPLACEMENT_DATA:1], pos + 1);
				pos += YSI_g_sReplacements[i][E_HOOK_NAME_REPLACEMENT_MAX] - 1;
				
			}
		}
	}

	return Hooks_MakeShortName(name);
}

#line 232











stock Hooks_MakeShortName(name[64])
{

	new
		len,
		pos = -1,
		idx = YSI_g_sReplacementsLongOrder[0];
	for (new i = 0; (len = strlen(name)) >= 32 && i != YSI_g_sReplacePtr; )
	{
		if ((pos = strfind(name, YSI_g_sReplacements[idx][E_HOOK_NAME_REPLACEMENT_LONG], false, pos + 1)) == -1)
		{
			++i,
			idx = YSI_g_sReplacementsLongOrder[i];
		}
		else
		{
			strdel(name, pos, pos + YSI_g_sReplacements[idx][E_HOOK_NAME_REPLACEMENT_MAX]),
			strins(name, YSI_g_sReplacements[idx][E_HOOK_NAME_REPLACEMENT_SHORT], pos);
		}
	}
	return len;
}

#line 267










static Hooks_IsolateName(name[])
{
	
	new
		pos = strfind(name, "@", false, 4);

	if (pos == -1) Debug_Print0("\7\7\7*** YSI Error: " #"Invalid hook name: %s", unpack(name), ++pos);
	name[pos] = '\0',
	strdel(name, 0, 4);
}

#line 289



















static stock Hooks_GetPreloadLibraries(preloads[][E_PRE_HOOK], &precount, size = sizeof (preloads))
{
	
	--size,
	precount = 0;
	new
		entry,
		idx;
	{
		new
			name[32 char],
			addr;
		while ((idx = AMX_GetEntryPrefix(AMX_TABLE_PUBLICS,idx, entry, (_:he:@E_:(_:he:@E_:@E@:@Ey:@Ea:@Eb:@Ec:@Ed:@Ee:@Ef:@Eg:@Eh:@Ei:@Ej:@Ek:@El:@Em:@En:@Eo:@Ep:@Eq:@Er:@Es:@Et:@Eu:@Ev:@Ew:@Ex:@Ez:@EA:@EB:(_:he:@E_:@E@:@Ey:@Ea:@Eb:@Ec:@Ed:@Ee:@Ef:@Eg:@Eh:@Ei:@Ej:@Ek:@El:@Em:@En:@Eo:@Ep:@Eq:@Er:@Es:@Et:@Eu:@Ev:@Ew:@Ex:@Ez:@EA:@EB:@EC:@ED:@EE:@EF:@EG:@EH:@EI:@EJ:@EK:@EL:@EM:@EN:(_:he:(_:0)|95<<0+8+8+8)|79<<0+8+8)|67<<0+8)|64<<0))))
		{
			if (precount == size)
			{
				Debug_Print0("\7\7\7*** YSI Error: " #"y_hooks prehook array filled");
				break;
			}
			addr = AMX_Read(entry);
			AMX_ReadString(AMX_Read(entry + 4) + AMX_BASE_ADDRESS + 4, name),
			strunpack(preloads[precount][E_PRE_HOOK_NAME], name, 16),
			preloads[precount][E_PRE_HOOK_VALUE] = CallFunction(addr),
			++precount;


			Hooks_InvalidateName(entry);
		}
	}

	{
		new
			tmp[E_PRE_HOOK];
		for (entry = precount - 1; entry > 0; --entry)
		{
			for (idx = 0; idx != entry; ++idx)
			{
				if (preloads[idx][E_PRE_HOOK_VALUE] > preloads[idx + 1][E_PRE_HOOK_VALUE])
				{
					tmp = preloads[idx],
					preloads[idx] = preloads[idx + 1],
					preloads[idx + 1] = tmp;
				}
			}
		}
	}
}

#line 357















static stock Hooks_GetPreHooks(preloads[][E_PRE_HOOK], precount, name[64], hooks[], &count)
{
	
	new
		idx,
		lfunc[64];

	do
	{
		strcat(lfunc, name),
		Hooks_MakeShortName(lfunc);
		if (AMX_GetEntry(AMX_TABLE_PUBLICS,0, hooks[count], lfunc, true)) ++count;
		strcat((lfunc[0] = '\0', lfunc),  preloads[idx][E_PRE_HOOK_NAME]),
		strcat(lfunc, "_");
	}
	while (++idx <= precount);
}

#line 391















static stock Hooks_GetPointerRewrite(hooks[], num, &ptr, &next, name[], nlen)
{
	
	switch (num)
	{
		case 0:
		{
			next = 0;
			new
				len = strlen(name);
			if (nlen >= len)
			{



				new
					str[32];
				strpack(str, name),
				AMX_WriteString(AMX_BASE_ADDRESS + AMX_Read(ptr + 4), str, len);
			}
			else
			{
				Debug_Print0("\7\7\7\7\7*** YSI Fatal Error: " #"Could not write function name in \"Hooks_MakePublicPointer\".");



			}
		}
		case 1:
		{


			next = ptr = hooks[0];
		}
		default:
		{

			for (new cur = 1; cur != num; ++cur)
			{
				ptr = hooks[cur];
				new
					tmp = AMX_Read(ptr),
					nt = Hooks_GetStubEntry(tmp);
				tmp += AMX_HEADER_COD,
				AMX_Write(tmp, _:RelocateOpcode(OP_JUMP));
				switch (nt)
				{
					case -1: ptr = tmp + 4, next = 0;
					case 0: next = 0;
					default:
					{
						ptr  = tmp + 4,
						next = tmp + nt,
						nt = AMX_Read(next),

						AMX_Write(ptr, nt),

						AMX_Write(next, nt - (AMX_REAL_DATA + AMX_HEADER_COD));
					}
				}
			}
		}
	}
}

#line 472













static stock Hooks_GetStubEntry(stub)
{
	

	new
		ctx[DisasmContext];
	DisasmInit(ctx, stub, stub + 64);
	switch (DisasmNextInsn(ctx))
	{
		case OP_LOAD_PRI:
		{
			if (DisasmNextInsn(ctx) == OP_SWITCH && DisasmNextInsn(ctx) == OP_CASETBL)
			{

				if (DisasmGetNumOperands(ctx) == 3) 
				{

					new
						h0 = DisasmGetOperand(ctx, 3),
						h1 = DisasmGetOperand(ctx, 5),
						h2 = DisasmGetOperand(ctx, 7);
					if (h1 == h2)      return  8 * 4; 
					else if (h0 == h2) return 10 * 4;
					else if (h0 == h1) return 12 * 4;
					else Debug_Print0("\7\7\7*** YSI Error: " #"y_hooks could not extract state stub jump");
				}
				else return -1;
			}
		}
		case OP_JUMP:
		{


			return 4; 
		}
		case OP_PROC:
		{

			Debug_Print0("\7\7\7*** YSI Error: " #"y_hooks attempting to redirect a PROC hook");
		}
	}
	return 0;
}

#line 530














































static stock Hooks_GetAllHooks(const name[], hooks[128], idx, &namelen)
{
	

	new
		len = strlen(name) + 1,
		count,
		tmpName[64];
	while ((idx = AMX_GetEntryPrefix(AMX_TABLE_PUBLICS,idx, hooks[count], (_:he:@E_:(_:he:@E_:@E@:(_:he:@E_:@E@:@Ey:@Ea:@Eb:@Ec:@Ed:@Ee:@Ef:@Eg:@Eh:@Ei:@Ej:@Ek:@El:@Em:@En:@Eo:@Ep:@Eq:@Er:@Es:@Et:@Eu:@Ev:@Ew:@Ex:@Ez:@EA:@EB:@EC:@ED:@EE:@EF:@EG:(_:he:(_:0)|95<<0+8+8+8)|72<<0+8+8)|121<<0+8)|64<<0))))
	{
		AMX_GetStringFromEntry(hooks[count], tmpName),
		len = strlen(tmpName),
		strunpack(tmpName, tmpName),
		Hooks_IsolateName(tmpName),
		Hooks_MakeLongName(tmpName);

		
		if (!strcmp(tmpName, name))
		{
			Hooks_InvalidateName(hooks[count]);




			if (count) namelen += len; 

			if (++count == sizeof (hooks))
			{
				Debug_Print0("\7*** YSI Warning: " #"Hooks_GetAllHooks: Potential overflow.");
				break;
			}
		}
	}
	return count;
}

#line 613










static stock Hooks_DoAllHooks()
{
	

	new
		precount = 0,
		preloads[8][E_PRE_HOOK];
	Hooks_GetPreloadLibraries(preloads, precount);

	new
		name[32],
		idx;

	while ((idx = AMX_GetNamePrefix(AMX_TABLE_PUBLICS,idx, name, (_:he:@E_:(_:he:@E_:@E@:(_:he:@E_:@E@:@Ey:@Ea:@Eb:@Ec:@Ed:@Ee:@Ef:@Eg:@Eh:@Ei:@Ej:@Ek:@El:@Em:@En:@Eo:@Ep:@Eq:@Er:@Es:@Et:@Eu:@Ev:@Ew:@Ex:@Ez:@EA:@EB:@EC:@ED:@EE:@EF:@EG:(_:he:(_:0)|95<<0+8+8+8)|72<<0+8+8)|121<<0+8)|64<<0))))
	{

		Hooks_Collate(preloads, precount, name, idx - 1);
	}
	Hooks_SortPublics();
}

#line 645










static stock Hooks_Collate(preloads[][E_PRE_HOOK], precount, name[32], idx)
{
	


	new
		namelen = strlen(name);










	static
		sName[64],
		sHooks[128];

















	strunpack(sName, name),
	Hooks_IsolateName(sName),
	Hooks_MakeLongName(sName);
	new

		hookCount = Hooks_GetAllHooks(sName, sHooks, idx, namelen),
		writePtr = sHooks[0], 
		nextPtr,
		pc, ph[4];

	Hooks_GetPreHooks(preloads, precount, sName, ph, pc),

	Hooks_GetPointerRewrite(ph, pc, writePtr, nextPtr, sName, namelen);

	if ((sHooks[hookCount] = nextPtr)) ++hookCount;

	Hooks_GenerateCode(sName, sHooks, hookCount, writePtr, pc > 1);
}

#line 712














static Hooks_GenerateCode(name[64], hooks[], count, write, bool:hasprehooks)
{
	









	new
		size = Hooks_WriteFunction(hooks, count, Hooks_GetDefaultReturn(name));
	
	if (size)
	{

		if (hasprehooks) AMX_Write(write, CGen_GetCodeSpace() + AMX_REAL_DATA);
		else AMX_Write(write, CGen_GetCodeSpace() - AMX_HEADER_COD);
		CGen_AddCodeSpace(size);
	}
	else
	{
		if (hasprehooks) AMX_Write(write, AMX_Read(hooks[0]) + (AMX_REAL_DATA + AMX_HEADER_COD));
		else AMX_Write(write, AMX_Read(hooks[0]));
	}
}

#line 756











static Hooks_InvalidateName(entry)
{
	
	AMX_Write(AMX_BASE_ADDRESS + AMX_Read(entry + 4), 0);
}














#line 787












static stock Hooks_GetFunctionWritePoint(name[], &write)
{
	
	AMX_GetEntry(AMX_TABLE_PUBLICS,0, write, name, true);
}

#line 806










static stock Hooks_GetDefaultReturn(name[64])
{
	
	strins(name, "@RET", 0);
	Hooks_MakeShortName(name);
	new
		ptr;
	if (AMX_GetEntry(AMX_TABLE_PUBLICS,0, ptr, name, true))
	{

		return CallFunction(AMX_Read(ptr)) ? 1 : 0;
	}
	return 1;
}
















#line 847













static Hooks_WriteFunction(const pointers[], const size, const ret = 1, const skipable = true)
{
	
	if (size == 0)
	{
		Debug_Print0("\7\7\7*** YSI Error: " #"Hooks_WriteFunction: size is 0");
		return 0;
	}
	new
		bool:multiple = size != 1,
		base = (AMX_HEADER_COD - AMX_BASE_ADDRESS) + AMX_REAL_ADDRESS,
		ctx[AsmContext];


	CGen_UseCodeSpace(ctx);


	AsmEmitProc(ctx);

	if (multiple) AsmEmitPushC(ctx,       ret  );


	AsmEmitLoadSAlt(ctx,   8    );	AsmEmitLctrl(ctx,        4    );	AsmEmitSub(ctx);	AsmEmitSctrl(ctx,        4    );	AsmEmitXchg(ctx);




	AsmEmitStorPri(ctx,     (CGen_GetCodeSpace() + (18 * 4) - (multiple ? 0 : 8))  );

	AsmEmitLctrl(ctx,        5    );	AsmEmitAddC(ctx,        12   );
	AsmEmitMovs(ctx,         0    );

	AsmEmitPushC(ctx,       -4 );
	if (multiple)
	{
		for (new i = 0; ; )
		{

			AsmEmitCall(ctx,         (AMX_Read(pointers[i]) + base)  );			if (skipable)
			{








				AsmEmitZeroAlt(ctx);				AsmEmitJslessRel(ctx,   ((size - i) * (10 * 4) - (5 * 4))  );


			}
			AsmEmitLoadSAlt(ctx,   -4    );			if (ret) AsmEmitAnd(ctx);			else AsmEmitOr(ctx);
			if (++i == size) break;
			else AsmEmitStorSPri(ctx,-4  );		}
		if (skipable)
		{
			AsmEmitJumpRel(ctx,     4     );

			AsmEmitInvert(ctx);		}
	}
	else if (skipable)
	{


		AsmEmitCall(ctx,         (AMX_Read(pointers[0]) + base) );		AsmEmitZeroAlt(ctx);		AsmEmitJsgeqRel(ctx,    4 );		AsmEmitInvert(ctx);	}
	else
	{


		return 0;
	}


	AsmEmitMoveAlt(ctx);
	AsmEmitLctrl(ctx,        5 );	AsmEmitSctrl(ctx,        4 );
	AsmEmitMovePri(ctx);

	AsmEmitRetn(ctx);

	return ctx[AsmContext_buffer_offset];
}
















#line 989














static Hooks_CompareNextCell(addr0, addr1)
{

	new
		s0 = Cell_ReverseBytes(AMX_Read(addr0)),
		s1 = Cell_ReverseBytes(AMX_Read(addr1));

	if (!(s0 & 0xFF000000)) s0 = 0;
	else if (!(s0 & 0x00FF0000)) s0 &= 0xFF000000;
	else if (!(s0 & 0x0000FF00)) s0 &= 0xFFFF0000;
	else if (!(s0 & 0x000000FF)) s0 &= 0xFFFFFF00;
	if (!(s1 & 0xFF000000)) s1 = 0;
	else if (!(s1 & 0x00FF0000)) s1 &= 0xFF000000;
	else if (!(s1 & 0x0000FF00)) s1 &= 0xFFFF0000;
	else if (!(s1 & 0x000000FF)) s1 &= 0xFFFFFF00;


	if (s1 > s0) return 1;
	else if (s1 < s0) return -1;
	else return 0;
}

#line 1026











static Hooks_ComparePublics(idx0, idx1)
{

	idx0 = idx0 * 8 + AMX_HEADER_PUBLICS;
	idx1 = idx1 * 8 + AMX_HEADER_PUBLICS;
	new
		addr0 = AMX_BASE_ADDRESS + AMX_Read(idx0 + 4),
		addr1 = AMX_BASE_ADDRESS + AMX_Read(idx1 + 4);
	for ( ; ; )
	{
		switch (Hooks_CompareNextCell(addr0, addr1))
		{
			case -1:
			{

				new
					tmpFunc = AMX_Read(idx0),
					tmpName = AMX_Read(idx0 + 4);
				AMX_Write(idx0, AMX_Read(idx1));
				AMX_Write(idx0 + 4, AMX_Read(idx1 + 4));
				AMX_Write(idx1, tmpFunc);
				AMX_Write(idx1 + 4, tmpName);
				return;
			}
			case 1:
			{

				return;
			}

		}
		addr0 += 4;
		addr1 += 4;
	}
}

#line 1074











static Hooks_SortPublics()
{
	

	new
		diff = Hooks_CountInvalidPublics() * 8,
		oldCount = (AMX_HEADER_NATIVES - AMX_HEADER_PUBLICS) / 8;




	for (new i = oldCount - 1; i > 0; --i)
	{
		for (new j = 0; j != i; ++j)
		{


			Hooks_ComparePublics(j, j + 1);
		}
	}

	if (diff)
	{

		AMX_Write(AMX_BASE_ADDRESS + 32, AMX_Read(AMX_BASE_ADDRESS + 32) + diff);
		AMX_HEADER_PUBLICS += diff;


		ResetStaticAmxHeader();
	}




}

#line 1122









static Hooks_CountInvalidPublics()
{
	
	new
		idx,
		buf,
		count;

	while ((idx = AMX_GetEntryPrefix(AMX_TABLE_PUBLICS,idx, buf, 0)))
		++count;
	
	return count;
}

#line 1146










stock _Hooks_AddReplacement(const longName[], const shortName[])
{

	if (YSI_g_sReplacePtr == (16))
	{
		Debug_Print0("\7\7\7*** YSI Error: " #"Insufficient space in the replacements table.");
		return;
	}
	strcat((YSI_g_sReplacements[YSI_g_sReplacePtr][E_HOOK_NAME_REPLACEMENT_SHORT][0] = '\0', YSI_g_sReplacements[YSI_g_sReplacePtr][E_HOOK_NAME_REPLACEMENT_SHORT]),  shortName, 16),
	strcat((YSI_g_sReplacements[YSI_g_sReplacePtr][E_HOOK_NAME_REPLACEMENT_LONG] [0] = '\0', YSI_g_sReplacements[YSI_g_sReplacePtr][E_HOOK_NAME_REPLACEMENT_LONG] ),  longName , 16),
	YSI_g_sReplacements[YSI_g_sReplacePtr][E_HOOK_NAME_REPLACEMENT_MIN] = strlen(shortName),
	YSI_g_sReplacements[YSI_g_sReplacePtr][E_HOOK_NAME_REPLACEMENT_MAX] = strlen(longName),
	YSI_g_sReplacementsLongOrder[YSI_g_sReplacePtr] = YSI_g_sReplacePtr,
	YSI_g_sReplacementsShortOrder[YSI_g_sReplacePtr] = YSI_g_sReplacePtr,
	++YSI_g_sReplacePtr;
}

#line 1174











static stock Hooks_SortReplacements()
{
	new
		idx0,
		idx1,
		temp;
	for (new i = YSI_g_sReplacePtr - 1; i > 0; --i)
	{
		for (new j = 0; j != i; ++j)
		{

			idx0 = YSI_g_sReplacementsShortOrder[j],
			idx1 = YSI_g_sReplacementsShortOrder[j + 1];
			if (YSI_g_sReplacements[idx0][E_HOOK_NAME_REPLACEMENT_MIN] < YSI_g_sReplacements[idx1][E_HOOK_NAME_REPLACEMENT_MIN])
			{
				temp = YSI_g_sReplacementsShortOrder[j],
				YSI_g_sReplacementsShortOrder[j] = YSI_g_sReplacementsShortOrder[j + 1],
				YSI_g_sReplacementsShortOrder[j + 1] = temp;
			}

			idx0 = YSI_g_sReplacementsLongOrder[j],
			idx1 = YSI_g_sReplacementsLongOrder[j + 1];
			if (YSI_g_sReplacements[idx0][E_HOOK_NAME_REPLACEMENT_MAX] < YSI_g_sReplacements[idx1][E_HOOK_NAME_REPLACEMENT_MAX])
			{
				temp = YSI_g_sReplacementsLongOrder[j],
				YSI_g_sReplacementsLongOrder[j] = YSI_g_sReplacementsLongOrder[j + 1],
				YSI_g_sReplacementsLongOrder[j + 1] = temp;
			}
		}
	}
	
}

#line 1219









public _y_va_OnScriptInit()
{
	
	state _ALS : _ALS_go;

	new
		idx,
		entry;




	while ((idx = AMX_GetEntryPrefix(AMX_TABLE_PUBLICS,idx, entry, (_:he:@E_:(_:he:(_:he:@E_:@E@:(_:he:@E_:@E@:@Ey:@Ea:@Eb:@Ec:@Ed:@Ee:@Ef:@Eg:@Eh:@Ei:@Ej:@Ek:@El:@Em:@En:@Eo:@Ep:@Eq:@Er:@Es:@Et:@Eu:@Ev:@Ew:@Ex:@Ez:@EA:@EB:@EC:@ED:@EE:@EF:@EG:(_:0)|72<<0+8+8+8)|121<<0+8+8)|95<<0+8)|64<<0))))
	{

		CallFunction(AMX_Read(entry));
		Hooks_InvalidateName(entry);
	}
	Hooks_SortReplacements();
	Hooks_DoAllHooks();
	


	HookChain_OnScriptInit();
	
	return 1;
}

forward HookChain_OnScriptInit(); public HookChain_OnScriptInit() <_ALS : _ALS_x0, _ALS : _ALS_x1> { return 1; } public HookChain_OnScriptInit() <> { return 1; }
#line 1263

#line 1265
	native BAD_numargs() = numargs;
#line 1267

stock Hooks_NumArgs()
{



	#emit LOAD.S.alt          0
Hooks_NumArgs_load:
	#emit CONST.pri           8
	#emit ADD
	#emit LOAD.I
	#emit ZERO.alt
	#emit PUSH.pri
	#emit SGEQ
	#emit LREF.S.alt          0
	#emit JZER                Hooks_NumArgs_load
	#emit POP.pri
	#emit SHR.C.pri           2
	#emit RETN














	return 0;
}

#line 1309



#file "D:\Dev\PAWN\YCore\pawno\include\YSI\..\YSI_Coding\y_hooks.inc"
#line 99

#line 103


#line 106



#file "D:\Dev\PAWN\YCore\pawno\include\YSI\y_hooks.inc"
#line 7


#file "impl.inc"
#line 6

@yH_OnLoadObjects@001();@yH_OnLoadObjects@001()
{
	inline Handler()
	{
		new rows = cache_num_rows();

		for (new row = 0; row != rows; ++row) {
			new objectIndex = Iter_Free(Object);
			if (objectIndex == INVALID_ITERATOR_SLOT) {
				err("Limit of %d objects reached (Y_OBJECT_TOTAL)", Y_OBJECT_TOTAL);
				break;
			}

			new DBID:factionDBid;
			cache_get_value_name_int(row, "faction_id", _:factionDBid);

			new factionid = GetFactionIndexFromDBID(factionDBid);
			if (factionid == INVALID_FACTION_ID) {
				log("Tried to load objects for nonexisting faction (dbID: %d)", _:factionDBid);
				continue;
			}

			new slot = Iter_Free(FactionObject[factionid]);
			if (slot == INVALID_ITERATOR_SLOT) {
				err("Limit of %d faction objects reached (Y_RP_FACTION_OBJECT_LIMIT)", Y_RP_FACTION_OBJECT_LIMIT);
				break;
			}

			cache_get_value_name_int(row, "id", _:Faction.Object[factionid][id]);
			Faction.Object[factionid][faction_id] = factionDBid;
			Faction.Object[factionid][faction] = factionid;

			cache_get_value_name_int(row, "object_id", _:Object[objectIndex][id]);

			Faction.Object[factionid][object_id] = Object[objectIndex][id];
			Faction.Object[factionid][object] = objectIndex;

			cache_get_value_name_int(row, "model", Object[objectIndex][model]);
			cache_get_value_name_float(row, "X", Object[objectIndex][pos][0]);
			cache_get_value_name_float(row, "Y", Object[objectIndex][pos][1]);
			cache_get_value_name_float(row, "Z", Object[objectIndex][pos][2]);
			cache_get_value_name_float(row, "R", Object[objectIndex][rot]);

			Iter_Add(Object, objectIndex);
			Iter_Add(FactionObject[factionid], slot);
		}

		printf("%d objects", rows);

		LoadedObjects++;
	}

	static const query[] = "SELECT fo.*, o.* FROM " FACTION_OBJECT_TABLE " fo LEFT JOIN " OBJECT_TABLE " o ON fo.object_id = o.id";
	mysql_pquery_inline(dbhandle,	query, using inline Handler);

	TotalObjects++;
}
